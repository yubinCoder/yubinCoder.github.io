<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP学习笔记</title>
    <link href="/2022/09/07/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/07/HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP学习笔记"><a href="#HTTP学习笔记" class="headerlink" title="HTTP学习笔记"></a>HTTP学习笔记</h1><h2 id="前后端通信"><a href="#前后端通信" class="headerlink" title="前后端通信"></a>前后端通信</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​前端指浏览器端。客户端指能和服务器通信的平台。后端一般指服务器端。</p><h3 id="前后端通信方式"><a href="#前后端通信方式" class="headerlink" title="前后端通信方式"></a>前后端通信方式</h3><ul><li><p>使用浏览器访问网页：在浏览器地址栏输入网址，按下回车</p></li><li><p><code>html</code>的标签</p><p>浏览器在解析HTML标签的时候，遇到一些特殊的标签，会再次向服务器发送请求。如<code>link</code>、<code>img</code> 、<code>script</code> 、 <code>iframe</code>等。</p><p>还有一些标签，浏览器解析的时候，不会向服务器发送请求，但是用户可以使用他们向服务器发送请求。如<code>a</code>、<code>form</code>标签。</p></li><li><p>3.<code>Ajax</code>和<code> Fetch</code></p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>​超文本：原先一个个单一的文本，通过超链接将其联系起来。由原先的单一的文本变成了可无限延伸扩展的超级文本、立体文本。</p><p>​<strong>超文本传输协议（HTTP，hyper text transfer protocol ）</strong>是一个用于传输超媒体文档（例如 HTML）的<a href="https://en.wikipedia.org/wiki/Application_Layer">应用层</a>协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。</p><h3 id="HTTP基本性质"><a href="#HTTP基本性质" class="headerlink" title="HTTP基本性质"></a>HTTP基本性质</h3><ul><li><p>简单易读</p></li><li><p>可拓展</p><p>在 HTTP&#x2F;1.0 中出现的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">HTTP headers</a> 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</p></li><li><p>无状态，有会话</p><p>在同一个连接中，两个执行成功的请求之间是没有关系的。</p><p>使用 HTTP 的头部扩展，HTTP Cookies 就可以解决这个问题。把 Cookies 添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p></li></ul><h3 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h3><p><img src="https://raw.githubusercontent.com/liujiaqi222/images/master/pics/20210621143529.png" alt="img"></p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>浏览器向服务器发送请求时，请求本身就是信息，叫请求报文。服务器向浏览器发送响应时传输的信息，叫响应报文。<code>http</code>报文指请求报文和响应报文。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png" alt="img"></p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>请求报文&#x3D;请求头(起始行+首部)+请求体 (get请求没有请求体)</p><p>响应报文&#x3D;响应头(起始行+首部)+响应体</p><p>GET请求，没有请求体，数据通过请求头携带；POST请求，有请求体，数据通过请求体携带。</p><p><img src="https://raw.githubusercontent.com/liujiaqi222/images/master/pics/20210621144322.png" alt="img"></p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP 方法是浏览器<strong>发送请求</strong>时采用的方法，与响应无关。HTTP方法用来定义对于资源采用什么样的操作，有各自的语义。</p><ul><li><code>get</code>请求用于获取数据，</li><li><code>post</code>用于创造数据，</li><li><code>put</code>用于更新数据，</li><li><code>delete</code>用于删除数据(增删改查)。</li></ul><p><strong>这些方法虽然有各自的语义，但并不是强制性的。</strong></p><p><code>RESTful</code>接口设计是一种接口设计风格，充分利用HTTP方法的语义。</p><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul><li>语义：</li></ul><p>​GET：获取数据；POST：创建数据</p><ul><li>发送数据</li></ul><p>​GET通过地址在请求头中携带数据，能够携带的数据量和地址的长度有关系，一般最多就几KB。</p><p>​POST既可以通过地址在请求头中携带数据，也可以通过请求体携带数据，理论上能携带数据的量是无限的 。</p><ul><li>缓存</li></ul><p>​GET可以被缓存，POST一般不会被缓存。</p><ul><li>安全性</li></ul><p>​GET和POST都不安全，发送密码或敏感信息时不要使用GET，主要是避免直接被他人窥屏或者通过历史记录找到你的密码。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>HTTP状态码是服务器对请求的处理结果，是服务器返回的。</p><p>100~199，消息：请求已经被接受，需要继续被处理。</p><p>200~299，成功</p><p>300~399，重定向</p><blockquote><p>301 moved permanently</p><p>302 move temporarily</p><p>304 not modified</p></blockquote><p>400~499 请求错误</p><p>500~599 服务器错误</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP请求</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>健身笔记(一)</title>
    <link href="/2022/09/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2022/09/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="健身笔记（一）"><a href="#健身笔记（一）" class="headerlink" title="健身笔记（一）"></a>健身笔记（一）</h1><h2 id="分化训练计划"><a href="#分化训练计划" class="headerlink" title="分化训练计划"></a>分化训练计划</h2><ul><li><h3 id="一分化（初入健身房）"><a href="#一分化（初入健身房）" class="headerlink" title="一分化（初入健身房）"></a>一分化（初入健身房）</h3></li><li><h3 id="两分化（开摆）"><a href="#两分化（开摆）" class="headerlink" title="两分化（开摆）"></a>两分化（开摆）</h3></li><li><h3 id="五分化"><a href="#五分化" class="headerlink" title="五分化."></a>五分化.</h3></li></ul><h2 id="随手记的健身思路"><a href="#随手记的健身思路" class="headerlink" title="随手记的健身思路"></a>随手记的健身思路</h2><h3 id="运动营养"><a href="#运动营养" class="headerlink" title="运动营养"></a>运动营养</h3><ul><li><p>概念</p><ul><li><p>七大营养素：碳水、蛋白质、脂肪、维生素、矿物质、膳食纤维、水</p></li><li><p>中国居民膳食指南</p></li></ul></li><li><p>碳蛋脂 </p><ul><li><p>消化吸收</p><ul><li><p>蛋白质脱氨基产生氨</p></li><li><p>脂肪代谢不完全会产生酮体</p></li><li><p>碳水是第一供能物质，有氧变成二氧化碳跟ATP,无氧呼吸变成乳酸跟ATP</p></li></ul></li><li><p>互为转换</p><ul><li><p><img src="https://api2.mubu.com/v3/document_image/491492fb-aa4f-401d-97ee-736b369e3786-18752647.jpg" alt="img"></p></li><li></li></ul></li></ul></li><li><p>碳水</p><ul><li><p>分类：</p><ul><li><p>单糖–问就叉出去！</p></li><li><p>简单碳水–双糖，如蔗糖、麦芽糖、乳糖、海藻糖</p></li><li><p>复杂碳水</p><ul><li><p>寡糖：三个以上十个一下的单糖：大豆低聚糖、低聚果糖</p></li><li><p>多糖：十分子以上的单糖聚合</p><ul><li><p>能消化吸收：淀粉、糖原</p></li><li><p>难消化吸收：膳食纤维</p></li></ul></li></ul></li></ul></li><li><p>人体内糖原形式：</p><ul><li><p>血糖→肝糖原→肌糖原 </p></li><li></li></ul></li></ul></li><li><p>蛋白质</p></li><li><p>脂肪</p></li><li><p>维生素</p></li><li><p>矿物质</p></li><li><p>膳食纤维</p></li><li><p>水</p></li></ul><h3 id="综合健身思路"><a href="#综合健身思路" class="headerlink" title="综合健身思路"></a>综合健身思路</h3><ul><li><p>生长激素与胰岛素是互为拮抗作用，较高的胰岛素水平会抑制脂肪分解，</p><ul><li><p>这里有点东西  ，研究碳水的话避不开</p></li><li><p>【待学习完善】</p></li></ul></li><li><p>移动焦点</p><ul><li><p>动作时关注的移动焦点，则其上游的肌群更容易被练到</p></li><li><p>把手掌作为移动焦点，则肘关节为上游关节，肱二头肌&#x2F;肱三头肌等大臂肌肉群则为上游肌群</p></li><li><p>关注手掌移动的话  则更容易锻炼到肱二头肌等</p></li><li><p>肘关节的上游关节是肩关节，背阔肌绕过肩关节连接在大臂上，因此肘关节的上游肌群为背阔肌</p></li><li><p>练背的移动关注点应该是在肘关节 肩关节</p></li><li><p>平板卧推的移动焦点为肘关节 （胸大肌绕过肩关节连接在大臂上）</p></li></ul></li><li><p>增力训练冲大重量很容易迷失自我  无效的自我感动</p></li><li><p>可以适当借力  但仍需要控制  宁轻勿假</p></li><li><p>离心控制</p><ul><li>都需要控制，控制运动轨迹 尤其是离心运动，是肌肉控制器械&#x2F;绳索&#x2F;哑铃等移动，而不是放弃控制，被其带动运动</li></ul></li><li><p>呼吸 节奏</p></li><li><p>削弱动作底部的肌肉牵张反射</p></li><li><p>练胸</p><ul><li><p>移动焦点法 卧推时关注的移动焦点应该是肘关节</p></li><li><p>注意小臂应该垂直于地面 避免侧向分立</p></li><li><p>双杠臂屈伸（下胸） 肘关节应该向后  如果是大臂向外打开（肘关节向外移动），则是侧重于锻炼三头</p></li><li><p>卧推时要注意顶峰收缩，不是简单地把哑铃杠铃往上推，卧推的本质是大臂的水平内收，是胸肌主导的发力模式。可以想象两个肘关节往内收，胸椎往前。</p></li></ul></li><li><p>练背</p><ul><li><p>器械高位下拉及器械坐姿划船应尝试两个不同的动作组合做组</p></li><li><p>尝试去控制运动轨迹 减少爆发力</p></li><li><p>送手不送肩</p></li><li><p>肩胛控制  （绳索划船体会）  肩上下回旋</p></li><li><p>俯身哑铃划船前期可以分前后脚站 注意转体细节</p></li></ul></li><li><p>练腿</p><ul><li><p>倒蹬机单侧重量上80kg  离心控制 避免爆发力 </p></li><li><p>深蹲、硬拉、哈克、倒蹬等练腿的复合型动作要避免力竭做组，力竭会超出神经负荷，影响恢复</p></li><li><p>股四头肌</p><ul><li><p>主要作用：膝伸  （屈膝→伸直膝盖）</p></li><li><p>组成：股内侧肌、股外侧肌、股直肌、股中间肌</p></li></ul></li><li><p>腘绳肌</p><ul><li><p>主要作用：髋伸（挺髋）（硬拉中明显体现）膝屈</p></li><li><p>组成：股二头肌、半腱肌、半膜肌</p></li></ul></li><li><p>膝伸与膝屈互为拮抗作用</p><ul><li><p>股四头肌与腘绳肌一个收缩一个拉伸</p></li><li><p>没错 类似于股二头肌跟股三头肌</p></li><li><p>膝盖健康很大程度上取决于拮抗作用是否平衡</p></li><li><p>练腿日要均衡锻炼</p></li></ul></li></ul></li><li><p>手臂</p><ul><li><p>主要肌群及运动功能</p><ul><li><p>肱二头肌：屈肩  屈肘 前臂旋后</p><ul><li><p>长头</p></li><li><p>短头</p></li></ul></li><li><p>肱三头肌：内收肩关节 伸肘</p><ul><li><p>外侧头</p></li><li><p>内侧头</p></li><li><p>长头</p></li></ul></li><li><p>小臂</p></li></ul></li><li><p>杠铃弯举：</p><ul><li><p>直臂曲臂杠铃选择：依据个人的手腕灵活程度进行选择，如果是手腕灵活度较低，则应优先选择曲臂杠铃。</p><ul><li>判断方式，手臂前举，掌心朝上，尝试外旋（大拇指方向）</li></ul></li><li></li></ul></li><li><p>随记备忘</p><ul><li><p>锤式弯举侧重于锻炼二头长头，后续应该补充完善二头锻炼动作，如常规的哑铃弯举（正手）</p></li><li><p>弯举时常见错误：手腕运动、握得太紧、手腕外旋角度过大、耸肩、肩膀前悬</p></li></ul></li><li><p>练腹</p><ul><li>悬垂举腿 骨盆位后倾  常见错误为前倾</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>健身笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node.js笔记</title>
    <link href="/2022/09/03/Node-js%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/03/Node-js%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js笔记"><a href="#Node-js笔记" class="headerlink" title="Node.js笔记"></a>Node.js笔记</h1><h2 id="1内置模块"><a href="#1内置模块" class="headerlink" title="1内置模块"></a>1内置模块</h2><h3 id="1-1fs文件系统模块"><a href="#1-1fs文件系统模块" class="headerlink" title="1.1fs文件系统模块"></a>1.1fs文件系统模块</h3><h4 id="fs基本用法"><a href="#fs基本用法" class="headerlink" title="fs基本用法"></a>fs基本用法</h4><ul><li><p>导入fs模块 <code>const fs =require(&#39;fs&#39;)</code>   fs是node.js内置的api 直接require调用即可</p></li><li><p><code>fs.readFile(path,[options,]callback)</code>用来读取指定文件中的内容</p></li><li><p><code>fs.wirteFile(file,data,[options,]callback)</code>用来向指定文件中写入内容</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span> (<span class="hljs-string">&#x27;fs&#x27;</span>) <br><span class="hljs-comment">//读取文件获得数据dataStr    报错则为err</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;.files/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,dataStr</span>)&#123;...&#125;)<br><br><span class="hljs-comment">//往文件写入指定内容  观察是否报错err</span><br><span class="hljs-keyword">const</span>  <span class="hljs-title class_">Msg</span>=<span class="hljs-string">&#x27;wirting&#x27;</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;.files/1.txt&#x27;</span>,<span class="hljs-title class_">Msg</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;...&#125;)<br></code></pre></td></tr></table></figure><h4 id="路径动态拼接问题"><a href="#路径动态拼接问题" class="headerlink" title="路径动态拼接问题"></a>路径动态拼接问题</h4><ul><li><p>在使用 fs 模块操作文件时，如果提供的操作路径是以 .&#x2F; 或 ..&#x2F; 开头的相对路径时，很容易出现路径动态拼接错误的问题。</p></li><li><p><strong>原因</strong>：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。</p></li><li><p><strong>解决方案</strong>：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 .&#x2F; 或 ..&#x2F; 开头的相对路径，从而防止路径动态拼接的问题。</p></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p><code>fs.writeFile(...)</code> 方法只能用来创建文件，不能用来创建路径，路径不存在则会报错</p></li><li><p>重复调用<code>fs.writeFile(...)</code> 写入同一个文件，新写入的内容会覆盖之前的旧内容</p></li></ul><h3 id="1-2path路径模块"><a href="#1-2path路径模块" class="headerlink" title="1.2path路径模块"></a>1.2path路径模块</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li><p>导入path模块 <code>const path =require(&#39;path&#39;)</code>   path是node.js内置的api 直接require调用即可</p></li><li><p><code>path.join()</code>方法，用来将多个路径片段拼接成一个完整的路径字符串</p></li><li><p><code>path.basename(path[,ext]) </code>方法，用来从路径字符串中，将文件名解析出来</p><p>path为文件所在路径，ext为文件拓展名，返回的是路径最后一部分，也就是文件名，如果ext生效，则不包含文件格式</p></li><li><p><code>path.extname(path) </code> 返回文件拓展名</p></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> pathStr1= path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/a&#x27;</span>,<span class="hljs-string">&#x27;/b/c&#x27;</span>,<span class="hljs-string">&#x27;../&#x27;</span>,<span class="hljs-string">&#x27;/d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-comment">//  \a\b\d\e</span><br><span class="hljs-keyword">const</span> pathStr2=path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;/files/1.txt&#x27;</span>)<br><span class="hljs-comment">//   当前文件所在目录\files\1.txt</span><br><span class="hljs-comment">//今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。</span><br><br><span class="hljs-keyword">const</span> pathStr3=<span class="hljs-string">&#x27;/a/b/c/d/index.html&#x27;</span><br><span class="hljs-keyword">let</span> fileName1 = path.<span class="hljs-title function_">basename</span>(pathStr3)  <span class="hljs-comment">//index.html</span><br><span class="hljs-keyword">let</span> fileName2 = path.<span class="hljs-title function_">basename</span>(pathStr3,<span class="hljs-string">&#x27;.html&#x27;</span>)  <span class="hljs-comment">//index</span><br><span class="hljs-keyword">let</span> fileName3 = path.<span class="hljs-title function_">basename</span>(pathStr3,)  <span class="hljs-comment">//.html</span><br></code></pre></td></tr></table></figure><h3 id="1-3-http模块"><a href="#1-3-http模块" class="headerlink" title="1.3 http模块"></a>1.3 http模块</h3><p>​导入http模块 <code>const http =require(&#39;http&#39;)</code>   path是node.js内置的api 直接require调用即可</p><h4 id="创建基本的web服务器"><a href="#创建基本的web服务器" class="headerlink" title="创建基本的web服务器"></a>创建基本的web服务器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 http 模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web 服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><span class="hljs-comment">// 3. 为服务器实例绑定 request 事件，监听客户端的请求</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Someone visit our web server.&#x27;</span>)    <br>&#125;)<br><span class="hljs-comment">// 4. 启动服务器</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="了解req请求对象"><a href="#了解req请求对象" class="headerlink" title="了解req请求对象"></a>了解req请求对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><span class="hljs-comment">// req 是请求对象，包含了与客户端相关的数据和属性</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// req.url 是客户端请求的 URL 地址</span><br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// req.method 是客户端请求的 method 类型</span><br>  <span class="hljs-keyword">const</span> method = req.<span class="hljs-property">method</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">`Your request url is <span class="hljs-subst">$&#123;url&#125;</span>, and request method is <span class="hljs-subst">$&#123;method&#125;</span>`</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br>  <span class="hljs-comment">// 调用 res.send() 方法，向客户端响应一些内容</span><br>  res.<span class="hljs-title function_">send</span>(str)<br>&#125;)<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 定义一个字符串，包含中文的内容</span><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">`您请求的 URL 地址是 <span class="hljs-subst">$&#123;req.url&#125;</span>，请求的 method 类型为 <span class="hljs-subst">$&#123;req.method&#125;</span>`</span><br>  <span class="hljs-comment">// 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题</span><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  <span class="hljs-comment">// res.send() 将内容响应给客户端</span><br>  res.<span class="hljs-title function_">send</span>(str)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h4 id="根据不同的url相应不同的内容"><a href="#根据不同的url相应不同的内容" class="headerlink" title="根据不同的url相应不同的内容"></a>根据不同的url相应不同的内容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 1. 获取请求的 url 地址</span><br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// 2. 设置默认的响应内容为 404 Not found</span><br>  <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span><br>  <span class="hljs-comment">// 3. 判断用户请求的是否为 / 或 /index.html 首页</span><br>  <span class="hljs-comment">// 4. 判断用户请求的是否为 /about.html 关于页面</span><br>  <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/&#x27;</span> || url === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (url === <span class="hljs-string">&#x27;/about.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br>  &#125;<br>  <span class="hljs-comment">// 5. 设置 Content-Type 响应头，防止中文乱码</span><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  <span class="hljs-comment">// 6. 使用 res.send() 把内容响应给客户端</span><br>  res.<span class="hljs-title function_">send</span>(content)<br>&#125;)<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2 模块化"></a>2 模块化</h2><h3 id="2-1-模块化基础"><a href="#2-1-模块化基础" class="headerlink" title="2.1 模块化基础"></a>2.1 模块化基础</h3><h4 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a><strong>模块分类</strong></h4><p>​Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：</p><ul><li><p>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</p></li><li><p>自定义模块（用户创建的每个 .js 文件，都是自定义模块）</p></li><li><p>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载</p></li></ul><h4 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a><strong>加载模块</strong></h4><p>​使用<code>require(...)</code> 方法，可以加载需要的内置模块、用户自定义模块（需要指定路径）、第三方模块进行使用。</p><h4 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a><strong>模块作用域</strong></h4><p>​和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做<strong>模块作用域</strong>。可以有效防止全局变量污染的问题</p><h4 id="模块向外共享"><a href="#模块向外共享" class="headerlink" title="模块向外共享"></a><strong>模块向外共享</strong></h4><ul><li><p><strong>module</strong> <strong>对象</strong></p><p>在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息</p></li><li><p><strong>module.exports</strong> <strong>对象</strong></p><p>在自定义模块中，可以使用 <code>module.exports </code>对象，将模块内的成员共享出去，供外界使用。</p><p>外界用 <code>require(...) </code>方法导入自定义模块时，得到的就是<code>module.exports</code>所指向的对象。如果没有指向，则指向<code>module.exports</code>上面的属性跟方法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在一个自定义模块中，默认情况下， module.exports = &#123;&#125;</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">20</span><br><span class="hljs-comment">// 向 module.exports 对象上挂载 username 属性</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zs&#x27;</span><br><span class="hljs-comment">// 向 module.exports 对象上挂载 sayHello 方法</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">age</span> = age<br><br><span class="hljs-comment">// 让 module.exports 指向一个全新的对象</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-string">&#x27;小黑&#x27;</span>,<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi!&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在外界使用 require 导入一个自定义模块的时候，得到的成员，</span><br><span class="hljs-comment">// 就是 那个模块中，通过 module.exports 指向的那个对象</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./11.自定义模块&#x27;</span>)<br><span class="hljs-comment">//&#123; nickname: &#x27;小黑&#x27;, sayHi: [Function: sayHi] &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m)<br><br><br></code></pre></td></tr></table></figure><ul><li><p><strong>exports</strong> <strong>对象</strong></p><p>由于 <code>module.exports </code>单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 <code>exports </code>对象。默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 <code>module.exports </code>指向的对象为准</p><p>为了防止混乱，建议不要在同一个模块中同时使用 <code>exports</code> 和<code> module.exports</code></p></li><li><p><strong>CommonJS</strong></p><ul><li><p>每个模块内部，module 变量代表当前模块。</p></li><li><p>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</p></li><li><p>加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块</p></li></ul></li></ul><h3 id="2-2-npm与包"><a href="#2-2-npm与包" class="headerlink" title="2.2 npm与包"></a>2.2 npm与包</h3><h4 id="包管理配置"><a href="#包管理配置" class="headerlink" title="包管理配置"></a><strong>包管理配置</strong></h4><ul><li><p><code>node_modules </code>文件夹用来存放所有已安装到项目中的包。<code>require() </code>导入第三方包时，就是从这个目录中查找并加载包。</p></li><li><p><code>package-lock.json </code>配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</p></li></ul><p>​<strong>注意</strong>：开发人员不要手动修改<code> node_modules</code>或 <code>package-lock.json</code> 文件中的任何代码，npm 包管理工具会自动维护它们。</p><ul><li><p><code> package.json</code> 包管理配置文件。用来记录与项目有关的一些配置信息。例如：l项目的名称、版本号、描述等l项目中都用到了哪些包l哪些包只在开发期间会用到哪些些包在开发和部署时都需要用到</p><ul><li><code>package.json </code>文件中，有一个 dependencies 节点，专门用来记录使用 npm install 命令安装了哪些包<ul><li>运行 npm install 命令（或 npm i），npm包管理工具会先读取<code>package.json</code>中的dependencies节点，读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中<br>  +  <code>npm uninstall packageName</code>  卸载指定名称的包，会自动从<code>package.json</code>中的dependencies中删除</li></ul></li></ul></li><li><p><strong>devDependencies</strong> <strong>节点</strong></p><ul><li><p>如果某些包<strong>只在项目开发阶段</strong>会用到，在<strong>项目上线之后不会用到</strong>，则建议把这些包记录到 devDependencies 节点中。</p><p>与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。dependencies 节点与 devDependencies节点属于平级</p></li><li><p>安装时指定节点 即可  <code>npm i packageName -D</code></p></li></ul></li></ul><h4 id="包管理分类"><a href="#包管理分类" class="headerlink" title="包管理分类"></a><strong>包管理分类</strong></h4><ul><li><p><strong>项目包</strong></p><ul><li><strong>概念：</strong>被安装到项目的 <code>node_modules </code>目录中的包，都是项目包</li><li><strong>开发依赖包</strong>（被记录到 <code>devDependencies</code> 节点中的包，只在开发期间会用到）</li><li><strong>核心依赖包</strong>（被记录到 <code>dependencies </code>节点中的包，在开发期间和项目上线之后都会用到）</li></ul></li><li><p><strong>全局包</strong></p><ul><li><p>在执行<code> npm install</code> 命令时，如果提供了 -g 参数，则会把包安装为全局包。</p><p>全局包会被安装到 <code>C:\Users\用户目录\AppData\Roaming\npm\node_modules </code>目录下。</p></li><li><p>①只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</p><p>②判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</p></li></ul><p>npm 包推荐</p><p>​<strong>i5ting_toc</strong>把 md 文档转为 html 页面的小工具</p></li></ul><h3 id="2-3-模块加载机制"><a href="#2-3-模块加载机制" class="headerlink" title="2.3 模块加载机制"></a>2.3 模块加载机制</h3><ul><li><p><strong>缓存机制</strong></p><p><strong>模块在第一次加载后会被缓存</strong>。 这也意味着多次调用 <code>require() </code>不会导致模块的代码被执行多次。</p><p>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p></li><li><p><strong>内置模块的加载机制</strong></p><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。</p><p>例如，<code>require(&#39;fs&#39;) </code>始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。</p></li><li><p><strong>自定义模块的加载机制</strong></p><p>使用 <code>require() </code>加载自定义模块时，必须指定以 .&#x2F; 或 ..&#x2F; 开头的路径标识符。在加载自定义模块时，如果没有指定 .&#x2F; 或 ..&#x2F; 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p><p>同时，在使用 <code>require() </code>导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p><p>①按照确切的文件名进行加载</p><p>②补全 .js 扩展名进行加载</p><p>③补全 .json 扩展名进行加载</p><p>④补全 .node 扩展名进行加载</p><ul><li>加载失败，终端报错</li></ul></li><li><p><strong>第三方模块的加载机制</strong></p><p>如果传递给 <code>require() </code>的模块标识符不是一个内置模块，也没有以 ‘.&#x2F;’ 或 ‘..&#x2F;’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 &#x2F;node_modules 文件夹中加载第三方模块。</p><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</p><p>例如，假设在 ‘C:\Users\itheima\project\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p><p>① C:\Users\itheima\project\node_modules\tools</p><p>② C:\Users\itheima\node_modules\tools</p><p>③ C:\Users\node_modules\tools</p><p>④ C:\node_modules\tools</p></li><li><p><strong>目录作为模块</strong></p><p>当把目录作为模块标识符，传递给<code>require()</code>进行加载的时候，有三种加载方式：</p><p>①在被加载的目录下查找一个叫做 <code>package.json</code> 的文件，并寻找 main 属性，作为<code>require()</code>加载的入口</p><p>②如果目录里没有 <code>package.json</code> 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js </code>文件。</p><p>③如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：<code>Error: Cannot find module &#39;xxx&#39;</code></p></li></ul><h2 id="3-Express"><a href="#3-Express" class="headerlink" title="3 Express"></a>3 Express</h2><h3 id="3-1-初识Express"><a href="#3-1-初识Express" class="headerlink" title="3.1 初识Express"></a>3.1 初识Express</h3><h4 id="Express项目结构"><a href="#Express项目结构" class="headerlink" title="Express项目结构"></a>Express项目结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/6066852-1141a10960763e9e.png?imageMogr2/auto-orient/strip" alt="img"></p><ul><li><p>node_modules文件夹<br>   这文件夹就是在创建完项目后，cd到项目目录执行npm install后生成的文件夹，下载了项目需要的依赖项</p></li><li><p>package.json文件<br> 此文件是项目的配置文件（可定义应用程序名，版本，依赖项等等）</p></li><li><p>node_modules文件夹下的依赖项是从哪里知道的呢？原因就是项目根目录下的这个package.json文件，执行npm install时会去找此文件中的dependencies，并安装指定的依赖项</p></li><li><p>public文件夹(包含images、javascripts、stylesheets)<br> 　这个文件夹做过Web开发的应该一看就知道，为了存放图片、脚本、样式等文件的</p></li><li><p>routes文件夹<br> 　用于存放路由文件，</p></li><li><p>views文件夹—ejs渲染的时候调用</p><p> 　用于存放模版文件</p></li></ul><h4 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a><strong>创建服务器</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 express</span><br> <span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br> <span class="hljs-comment">// 2. 创建 web 服务器</span><br> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br> <span class="hljs-comment">// 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容</span><br> app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>   <span class="hljs-comment">// 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象</span><br>   res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span> &#125;)<br> &#125;)<br> app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>   <span class="hljs-comment">// 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串</span><br>   res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br> &#125;)<br> app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>   <span class="hljs-comment">// 通过 req.query 可以获取到客户端发送过来的 查询参数</span><br>   <span class="hljs-comment">// 注意：默认情况下，req.query 是一个空对象</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>)<br>   res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<br> &#125;)<br> <span class="hljs-comment">// 注意：这里的 :id 是一个动态的参数</span><br> app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:ids/:username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>   <span class="hljs-comment">// req.params 是动态匹配到的 URL 参数，默认也是一个空对象</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>   res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<br> &#125;)<br><br> <span class="hljs-comment">// 3. 启动 web 服务器</span><br> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br> &#125;)<br></code></pre></td></tr></table></figure><h4 id="对外提供静态资源"><a href="#对外提供静态资源" class="headerlink" title="对外提供静态资源"></a><strong>对外提供静态资源</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br> <span class="hljs-comment">// 在这里，调用 express.static() 方法，快速的对外提供静态资源</span><br> app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./files&#x27;</span>))<br> <span class="hljs-comment">//默认无挂载路径前缀，Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。</span><br> <span class="hljs-comment">//因此，存放静态文件的目录名不会出现在 URL 中</span><br><span class="hljs-comment">//http://localhost:80/img/kitten.jpg</span><br><br> app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/files&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./files&#x27;</span>))<br> <span class="hljs-comment">//使用挂载路径前缀，通过带有 /files 前缀地址来访问 public 目录中的文件了</span><br> <span class="hljs-comment">//http://localhost:80/files/img/kitten.jpg</span><br><br><br> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br> &#125;)<br><br></code></pre></td></tr></table></figure><h4 id="res返回方法与内容"><a href="#res返回方法与内容" class="headerlink" title="res返回方法与内容"></a>res返回方法与内容</h4><p><code>res.send(...)</code> 常规给客户端请求返回内容</p><p><code>res.json(&#123;...&#125;)</code>  给客户端返回json数据</p><p><code>res.download(&#39;img.png&#39;)</code>  给客户端返回文件并直接下载</p><p><code>res.sendStatus(500)</code>  设置状态码</p><p><code>res.status(500).send(&#39;server error&#39;)</code>    <code>res.status(500).json(message:&#39;error&#39;)</code> 链式返回</p><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a><strong>nodemon</strong></h4><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。现在，我们可以使用 <a href="https://www.npmjs.com/package/nodemon">nodemon </a> 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。</p><p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局安装</span><br>npm install -g nodemon<br><span class="hljs-comment">//使用 </span><br>nodemon app.<span class="hljs-property">js</span>  <span class="hljs-comment">//app.js是需要执行的文件</span><br></code></pre></td></tr></table></figure><h3 id="3-2-模板引擎"><a href="#3-2-模板引擎" class="headerlink" title="3.2 模板引擎"></a>3.2 <strong>模板引擎</strong></h3><h4 id="使用ejs渲染html"><a href="#使用ejs渲染html" class="headerlink" title="使用ejs渲染html"></a>使用ejs渲染html</h4><p>​如果想要在客户端渲染html，我们可以使用 view engine，在这里将使用ejs这个npm包。<code>npm install ejs</code></p><p>​并在app.js中设置ejs为view engine  <code>app.set(&#39;view engine&#39;,&#39;ejs&#39;)</code></p><p>​之后使用<code>res.render(..)</code> 指定渲染  </p><p>​如<code>res.render(&#39;index&#39;)</code>   &#x2F;&#x2F;此处渲染的是 <code>.views.index.ejs</code>  views文件夹跟ejs格式是固定的 ejs本质结构跟html一致</p><h4 id="给html传递信息"><a href="#给html传递信息" class="headerlink" title="给html传递信息"></a>给html传递信息</h4><p>​通过render函数的第二个参数，可以给我们的html文件传递信息</p><p>​在ejs中 <code>&lt;%%&gt;</code>就相当于vue中的插槽<code>&#123;&#123;&#125;&#125;</code>，表示在这里使用js，<code>=</code> 表示在html中输出。</p><p>   <code>res.render(&#39;index&#39;,&#123;msg:&#39;msgword&#39;&#125;)</code></p><p>​在ejs文件中<code>&lt;h1&gt;这是ejs要渲染的html页面 &lt;%= msg %&gt;&lt;/h1&gt;</code></p><p>​但如果说我们给模板传了太多变量，到最后都不记得传没有传。比如这里我们并没有给模板引擎传name333这个变量，最后浏览器端就报错了。为了这个问题，在ejs文件中我们在变量前面加一个locals。没有name333，那浏览器就不会显示，不会报错！</p><h3 id="3-3-Express路由"><a href="#3-3-Express路由" class="headerlink" title="3.3 Express路由"></a>3.3 <strong>Express路由</strong></h3><h4 id="Express路由概念"><a href="#Express路由概念" class="headerlink" title="Express路由概念"></a><strong>Express路由概念</strong></h4><p>​在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。</p><p>​Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：</p><p>​<code>app.METHOD(PATH,HANDLER)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello world.&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Post Request.&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a><strong>模块化路由</strong></h4><p>为了方便对路由进行模块化的管理，Express <strong>不建议</strong>将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：</p><ul><li>创建路由模块对应的 .js 文件</li><li>调用 <code>express.Router() </code>函数创建路由对象</li><li>向路由对象上挂载具体的路由</li><li>使用<code>module.exports</code>向外共享路由对象</li><li>使用 <code>app.use() </code>函数注册路由模块</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//+++++++路由对象</span><br>    <span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>    <span class="hljs-comment">// app.use(&#x27;/files&#x27;, express.static(&#x27;./files&#x27;))</span><br><br>    <span class="hljs-comment">// 1. 导入路由模块</span><br>    <span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./03.router&#x27;</span>)<br>    <span class="hljs-comment">// 2. 注册路由模块</span><br>    app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)   <span class="hljs-comment">//使用挂载路径前缀</span><br><br>    <span class="hljs-comment">// 注意： app.use() 函数的作用，就是来注册全局中间件</span><br><br>    app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>    &#125;)<br><br><br><span class="hljs-comment">//+++++++路由模块</span><br>    <span class="hljs-comment">// 1. 导入 express</span><br>    <span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br>    <span class="hljs-comment">// 2. 创建路由对象</span><br>    <span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br>    <span class="hljs-comment">// 3. 挂载具体的路由</span><br>    router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)<br>    &#125;)<br>    router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>      res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)<br>        <span class="hljs-comment">//这里也可以把路由处理相应函数单独写成一个模块</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 4. 向外导出路由对象</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br><br></code></pre></td></tr></table></figure><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>假设我们现在有很多用户，如’&#x2F;users&#x2F;1’,’users&#x2F;2’,’users&#x2F;3’等。但我们不可能为每一个用户的请求地址都创建一个路由！</p><p>这时候，我们就可以使用动态路由，<code>router.get(&#39;/:id&#39;)</code>，通过使用<code>:</code>，告诉express匹配任意的参数后缀。</p><p>NOTE：注意一般要将动态路由放在最底部，因为express对于请求路径是从上往下匹配的。</p><h4 id="app-route"><a href="#app-route" class="headerlink" title="app.route()"></a>app.route()</h4><p>如果一个路径，既需要用到get，又需要用到put，delete，这时候我们可以用app.route()链式调用。在路由中，就是将<code>app.route()</code>换成<code>router.route()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/:id&#x27;</span>)<br>  .<span class="hljs-title function_">get</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`get user with id <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">put</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`update user with id <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">delete</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`delete user with id <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>);<br>  &#125;)<br></code></pre></td></tr></table></figure><h4 id="app-param-name-callback"><a href="#app-param-name-callback" class="headerlink" title="app.param(name,callback)"></a>app.param(name,callback)</h4><p>和上面一样在路由中写作<code>router.param()</code>。它的意思是如果各个路由的路径如果匹配到了app.param的第一个参数（也就是name），则执行后面的回调函数（callback）。</p><p>回调函数中的参数按顺序分别是请求对象，响应对象，next中间件，参数的值以及参数的名字，也就是<code>app.param(name,callback(req,res,next,id,name))</code></p><p><code>router.param()</code>本质上就是一种中间件，中间件就是<strong>请求发送到服务器后，但服务器还没有将响应返回客户端。</strong></p><p>经历了这个中间件，然后才会调用实际对应的路由（如果在这个中间件中调用了next()）。</p><p><strong>如果此时在该中间件的req或者res上挂载属性，之后的路由可以访问到</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>   <span class="hljs-comment">//此处可以获取到刚才在req上添加的user属性.</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">user</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`user&#x27;s id is <span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> users = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jiaqi&#x27;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sally&#x27;</span> &#125;];<br><br>router.<span class="hljs-title function_">param</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next, id</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//接下来其他路由可以访问到此时添加的user属性</span><br>  req.<span class="hljs-property">user</span> = users[id]<br>  <span class="hljs-title function_">next</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-4-Express中间件"><a href="#3-4-Express中间件" class="headerlink" title="3.4 Express中间件"></a>3.4 <strong>Express中间件</strong></h3><ul><li><p><strong>概念</strong></p><p>当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p><p>Express 的中间件，本质上就是一个 <strong>function</strong> <strong>处理函数</strong>，中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。</p><p><strong>next</strong> <strong>函数</strong>是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br>  <br><span class="hljs-comment">// // 定义一个最简单的中间件函数</span><br><span class="hljs-comment">// const mw = function (req, res, next) &#123;</span><br><span class="hljs-comment">//   console.log(&#x27;这是最简单的中间件函数&#x27;)</span><br><span class="hljs-comment">//   // 把流转关系，转交给下一个中间件或路由</span><br><span class="hljs-comment">//   next()</span><br><span class="hljs-comment">// &#125;</span><br>  <br><span class="hljs-comment">// // 将 mw 注册为全局生效的中间件</span><br><span class="hljs-comment">// app.use(mw)</span><br>  <br><span class="hljs-comment">// 这是定义全局中间件的简化形式</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是最简单的中间件函数&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br>  <br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了 / 这个路由&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了 /user 这个路由&#x27;</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)<br>&#125;)<br>  <br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)<br>&#125;)<br>  <br></code></pre></td></tr></table></figure></li><li><p><strong>作用</strong></p><p>多个中间件之间，<strong>共享同一份</strong> <strong>req</strong> <strong>和</strong> <strong>res</strong>。基于这样的特性，我们可以在上游的中间件中，<strong>统一</strong>为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</p></li><li><p><strong>定义多个全局中间件</strong></p><p>可以使用 <code>app.use()  </code>连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用</p></li><li><p><strong>局部生效的中间件</strong></p><p><strong>不使用</strong> <code>app.use() </code>定义的中间件，叫做局部生效的中间件</p><p>一个路由也可以使用多个局部生效的中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br>  <br><span class="hljs-comment">// 1. 定义中间件函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw1</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第一个局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br>  <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">mw2</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第二个局部生效的中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br>  <br><span class="hljs-comment">// 2. 创建路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, [mw1, mw2], <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)<br>&#125;)<br>  <br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br>  <br></code></pre></td></tr></table></figure></li><li><p><strong>注意事项</strong></p><p>①一定要在路由之前注册中间件</p><p>②客户端发送过来的请求，可以连续调用多个中间件进行处理</p><p>③执行完中间件的业务代码之后，不要忘记调用 <code>next() </code>函数</p><p>④为了防止代码逻辑混乱，调用 <code>next() </code>函数后不要再写额外的代码</p><p>⑤连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</p></li><li><p><strong>中间件的分类</strong></p><ul><li><p><strong>应用级别的中间件</strong>：通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 app 实例上的中间件，叫做应用级别的中间件</p></li><li><p><strong>路由级别的中间件</strong>：绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上</p></li><li><p><strong>错误级别的中间件</strong>：</p></li><li><p>错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。</p></li><li><p>错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 <code>(err, req, res, next)</code>。</p></li><li><p><strong>错误级别的中间件，必须注册在所有路由之后！</strong></p></li><li><p><strong>Express 内置的中间件</strong></p><ul><li><p><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</p></li><li><p><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）  <code>app.use(express.json())</code></p></li><li><p><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置</span><br><span class="hljs-comment">// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>())<br><span class="hljs-comment">// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据</span><br>  <span class="hljs-comment">// 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/book&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三方的中间件</strong></p></li><li><p>非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。</p></li><li><p>例如：在 <a href="mailto:&#101;&#x78;&#x70;&#114;&#101;&#115;&#x73;&#64;&#52;&#46;&#49;&#54;&#x2e;&#48;">&#101;&#x78;&#x70;&#114;&#101;&#115;&#x73;&#64;&#52;&#46;&#49;&#54;&#x2e;&#48;</a> 之前的版本中，经常使用 <code>body-parser </code>这个第三方中间件，来解析请求体数据。使用步骤如下：</p><ul><li>运行 <code>npm install body-parser</code> 安装中间件</li><li>使用 require 导入中间件</li><li>调用 <code>app.use() </code>注册并使用中间件</li></ul></li><li><p>注意：Express 内置的 <code>express.urlencoded</code> 中间件，就是基于 <code>body-parser</code> 这个第三方中间件进一步封装出来的。</p></li></ul></li><li><p><strong>自定义中间件</strong></p><p>自定义解析表单数据的中间件</p><ul><li><p>监听req的data事件：  <code>req.on(&#39;data&#39;, () =&gt; &#123;...&#125;</code></p><p>在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。</p><p>如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。</p></li><li><p>监听req的end事件  <code>req.on(&#39;end&#39;, () =&gt; &#123;...&#125;</code></p><p>当请求体数据接收完毕之后，会自动触发 req 的 end 事件。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><span class="hljs-comment">// 导入 Node.js 内置的 querystring 模块</span><br><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-comment">// 这是解析表单数据的中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 定义中间件具体的业务逻辑</span><br>  <span class="hljs-comment">// 1. 定义一个 str 字符串，专门用来存储客户端发送过来的请求体数据</span><br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-comment">// 2. 监听 req 的 data 事件</span><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    str += chunk<br>  &#125;)<br>  <span class="hljs-comment">// 3. 监听 req 的 end 事件</span><br>  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在 str 中存放的是完整的请求体数据</span><br>    <span class="hljs-comment">// console.log(str)</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 把字符串格式的请求体数据，解析成对象格式</span><br>    <span class="hljs-keyword">const</span> body = qs.<span class="hljs-title function_">parse</span>(str)<br>    req.<span class="hljs-property">body</span> = body<br>    <span class="hljs-title function_">next</span>()<br>  &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">body</span>)<br>&#125;)<br><br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-5-Express的post跟get接口实例"><a href="#3-5-Express的post跟get接口实例" class="headerlink" title="3.5 Express的post跟get接口实例"></a>3.5 Express的post跟get接口实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//-------------路由模块文件  apiRouter.js</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br><br><span class="hljs-comment">// 在这里挂载对应的路由</span><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过 req.query 获取客户端通过查询字符串，发送到服务器的数据</span><br>  <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span><br>  <span class="hljs-comment">// 调用 res.send() 方法，向客户端响应处理的结果</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 0 表示处理成功，1 表示处理失败</span><br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;GET 请求成功！&#x27;</span>, <span class="hljs-comment">// 状态的描述</span><br>    <span class="hljs-attr">data</span>: query, <span class="hljs-comment">// 需要响应给客户端的数据</span><br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 定义 POST 接口</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/post&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过 req.body 获取请求体中包含的 url-encoded 格式的数据</span><br>  <span class="hljs-keyword">const</span> body = req.<span class="hljs-property">body</span><br>  <span class="hljs-comment">// 调用 res.send() 方法，向客户端响应结果</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;POST 请求成功！&#x27;</span>,<br>    <span class="hljs-attr">data</span>: body,<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 定义 DELETE 接口</span><br>router.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/delete&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;DELETE请求成功&#x27;</span>,<br>  &#125;)<br>&#125;)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">//---------服务器实例</span><br><span class="hljs-comment">// 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 配置解析表单数据的中间件</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br><br><span class="hljs-comment">// 必须在配置 cors 中间件之前，配置 JSONP 的接口</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 定义 JSONP 接口具体的实现过程</span><br>  <span class="hljs-comment">// 1. 得到函数的名称</span><br>  <span class="hljs-keyword">const</span> funcName = req.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span><br>  <span class="hljs-comment">// 2. 定义要发送到客户端的数据对象</span><br>  <span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> &#125;<br>  <span class="hljs-comment">// 3. 拼接出一个函数的调用</span><br>  <span class="hljs-keyword">const</span> scriptStr = <span class="hljs-string">`<span class="hljs-subst">$&#123;funcName&#125;</span>(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>)`</span><br>  <span class="hljs-comment">// 4. 把拼接的字符串，响应给客户端</span><br>  res.<span class="hljs-title function_">send</span>(scriptStr)<br>&#125;)<br><br><span class="hljs-comment">// 一定要在路由之前，配置 cors 这个中间件，从而解决接口跨域的问题</span><br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br><br><span class="hljs-comment">// 导入路由模块</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./16.apiRouter&#x27;</span>)<br><span class="hljs-comment">// 把路由模块，注册到 app 上</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<br><br><span class="hljs-comment">// 启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="3-6-CORS-跨域资源共享"><a href="#3-6-CORS-跨域资源共享" class="headerlink" title="3.6 CORS 跨域资源共享"></a>3.6 <strong>CORS</strong> <strong>跨域资源共享</strong></h3><ul><li><p><strong>基本使用</strong></p><p>cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。</p><p>使用步骤分为如下 3 步：</p><p>①运行 <code>npm install cors </code>安装中间件</p><p>②使用  <code>const cors = require(&#39;cors&#39;)  </code>导入中间件</p><p>③在路由之前调用  <code>app.use(cors())  </code>配置中间件</p></li><li><p><strong>CORS</strong> <strong>响应头部</strong>  </p><ul><li><p><strong>Access-Control-Allow-Origin</strong></p><p>响应头部中可以携带一个 <strong>Access-Control-Allow-Origin</strong> 字段，其语法如下:</p><p><code>Access-Control-Allow-Origin:&lt;origin&gt;|*</code></p><p>其中，origin参数的值指定了允许访问该资源外域URL</p><p><code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;https:www.baidu.com&#39;)</code> &#x2F;&#x2F;只允许来自<code>https:www.baidu.com</code>的请求</p><p><code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;)</code> &#x2F;&#x2F;允许来自任何域的请求</p></li><li><p><strong>Access-Control-Allow-Headers</strong></p><p>默认情况下，CORS <strong>仅</strong>支持客户端向服务器发送如下的 9 个请求头：</p><p>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded 三者之一）</p><p>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</p><p><code>res.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;Content-Type，X-cunstom-Header&#39;)</code> </p><p>&#x2F;&#x2F;允许客户端向服务器发送Content-Type，X-cunstom-Header’请求头，多个请求头之间用逗号分隔</p></li><li><p><strong>Access-Control-Allow-Methods</strong></p><p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。</p><p>如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。</p></li></ul></li><li><p><strong>简单请求</strong></p><p>同时满足以下两大条件的请求，就属于简单请求：</p><p>① 请求方式：GET、POST、HEAD 三者之一</p><p>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain）</p></li><li><p><strong>预检请求</strong></p><p>只要符合以下任何一个条件的请求，都需要进行预检请求：</p><p>① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型</p><p>② 请求头中包含自定义头部字段</p><p>③ 向服务器发送了 application&#x2F;json 格式的数据</p><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p></li><li><p>简单请求与预检请求的分别</p><p><strong>简单请求的特点</strong>：客户端与服务器之间只会发生一次请求。</p><p><strong>预检请求的特点</strong>：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p></li></ul><h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4 数据库"></a>4 数据库</h2><h3 id="4-1-数据库基本语法"><a href="#4-1-数据库基本语法" class="headerlink" title="4.1 数据库基本语法"></a>4.1 数据库基本语法</h3><ul><li><p><strong>SELECT 语句</strong>用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集）。<br><code>select column_name from tabel_name</code>；可以使用通配符</p></li><li><p><strong>INSERT INTO 语句</strong>用于向数据表中插入新的数据行 </p><p><code>insert into tabel_name(column1,column2...) values(value1,value2...)</code></p><p>column跟value之间要 一 一 对应</p></li><li><p><strong>Update 语句</strong>用于修改表中的数据。</p><p><code>update table_name set column1 =value1,column2 =value2 where __options</code></p></li><li><p><strong>delete语句</strong>用于删除表中的行</p><p><code>delete from table_name where __options</code></p></li><li><p><strong>where子句</strong>用于限定选择的标准。在 SELECT、UPDATE、DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。</p><p>where子句运算符</p><ul><li>&#x3D;         &gt;     &lt;    &gt;&#x3D;   &lt;&#x3D;</li><li>特殊1 &lt;&gt; 表示不等于 ，在某些版本中 可以写成！&#x3D;</li><li>特殊2 between 表示在某个范围内</li><li>特殊3 like表示搜索某种模式</li></ul></li><li><p><strong>AND</strong> 表示必须同时满足多个条件，相当于 JavaScript 中的 &amp;&amp; 运算符，例如 if (a !&#x3D;&#x3D; 10 &amp;&amp; a !&#x3D;&#x3D; 20)</p></li><li><p><strong>OR</strong> 表示只要满足任意一个条件即可，相当于 JavaScript 中的 || 运算符，例如 if(a !&#x3D;&#x3D; 10 || a !&#x3D;&#x3D; 20)</p></li><li><p><strong>ORDER BY 语句</strong>用于根据指定的列对结果集进行排序。ORDER BY 语句<strong>默认按照升序（ASC）</strong>对记录进行排序。<strong>降序</strong>可以使用 DESC 关键字。</p></li><li><p><strong>COUNT(*) 函数</strong>用于返回查询结果的总数据条数，语法格式如下：</p><p><code> count (*) from table_name where __options</code></p></li><li><p>如果希望给查询出来的列名称设置别名，可以使用 AS 关键字</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 通过 * 把 users 表中所有的数据查询出来<br>    select * from users<br><br>-- 从 users 表中把 username 和 password 对应的数据查询出来<br>    select username, password from users<br><br>-- 向 users 表中，插入新数据，username 的值为 tony stark  password 的值为 098123<br>    insert into users (username, password) values (&#x27;tony stark&#x27;, &#x27;098123&#x27;)<br><br>-- 将 id 为 4 的用户密码，更新成 888888<br>    update users set password=&#x27;888888&#x27; where id=4<br><br>-- 更新 id 为 2 的用户，把用户密码更新为 admin123  同时，把用户的状态更新为 1<br>    update users set password=&#x27;admin123&#x27;, status=1 where id=2<br><br>-- 删除 users 表中， id 为 4 的用户<br>    delete from users where id=4<br><br>-- 演示 where 子句的使用<br>    select * from users where status=1<br>    select * from users where id&gt;=2<br>    select * from users where username&lt;&gt;&#x27;ls&#x27;<br>    select * from users where username!=&#x27;ls&#x27;<br><br>-- 使用 AND 来显示所有状态为0且id小于3的用户<br>select * from users where status=0 and id&lt;3<br><br>-- 使用 or 来显示所有状态为1 或 username 为 zs 的用户<br>select * from users where status=1 or username=&#x27;zs&#x27;<br><br>-- 对users表中的数据，按照 status 字段进行升序排序<br>select * from users order by status<br><br>-- 按照 id 对结果进行降序的排序  desc 表示降序排序   asc 表示升序排序（默认情况下，就是升序排序的）<br>select * from users order by id desc<br><br>-- 对 users 表中的数据，先按照 status 进行降序排序，再按照 username 字母的顺序，进行升序的排序<br>select * from users order by status desc, username asc<br><br>-- 使用 count(*) 来统计 users 表中，状态为 0 用户的总数量<br>select count(*) from users where status=0<br><br>-- 使用 AS 关键字给列起别名<br>select count(*) as total from users where status=0<br>select username as uname, password as upwd from users<br></code></pre></td></tr></table></figure><h3 id="4-2-mysql模块"><a href="#4-2-mysql模块" class="headerlink" title="4.2 mysql模块"></a>4.2 mysql模块</h3><ul><li><p>安装与配置</p><p>安装mysql模块   <code>npm install mysql</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 mysql 模块</span><br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><span class="hljs-comment">// 2. 建立与 MySQL 数据库的连接关系</span><br><span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-comment">// 数据库的 IP 地址</span><br>  <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-comment">// 登录数据库的账号</span><br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin123&#x27;</span>, <span class="hljs-comment">// 登录数据库的密码</span><br>  <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;my_db_01&#x27;</span>, <span class="hljs-comment">// 指定要操作哪个数据库</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>Connection Options</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">host：主机地址 （默认：localhost）<br>  　　user：用户名<br>  　　password：密码<br>  　　port：端口号 （默认：<span class="hljs-number">3306</span>）<br>  　　database：数据库名<br>  　　charset：连接字符集（默认：<span class="hljs-string">&#x27;UTF8_GENERAL_CI&#x27;</span>，注意字符集的字母都要大写）<br>  　　localAddress：此<span class="hljs-variable constant_">IP</span>用于<span class="hljs-variable constant_">TCP</span>连接（可选）<br>  　　socketPath：连接到unix域路径，当使用 host 和 port 时会被忽略<br>  　　timezone：时区（默认：<span class="hljs-string">&#x27;local&#x27;</span>）<br>  　　connectTimeout：连接超时（默认：不限制；单位：毫秒）<br>  　　stringifyObjects：是否序列化对象（默认：<span class="hljs-string">&#x27;false&#x27;</span> ；与安全相关<span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/felixge/node-mysql/issues/501）</span><br>  　　typeCast：是否将列值转化为本地<span class="hljs-title class_">JavaScript</span>类型值 （默认：<span class="hljs-literal">true</span>）<br>  　　queryFormat：自定义query语句格式化方法 <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/felixge/node-mysql#custom-format</span><br>  　　supportBigNumbers：数据库支持bigint或decimal类型列时，需要设此option为<span class="hljs-literal">true</span> （默认：<span class="hljs-literal">false</span>）<br>  　　bigNumberStrings：supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以<span class="hljs-title class_">JavaScript</span>字符串类型返回（默认：<span class="hljs-literal">false</span>）<br>  　　dateStrings：强制timestamp,datetime,data类型以字符串类型返回，而不是<span class="hljs-title class_">JavaScript</span> <span class="hljs-title class_">Date</span>类型（默认：<span class="hljs-literal">false</span>）<br>  　　debug：开启调试（默认：<span class="hljs-literal">false</span>）<br>  　　multipleStatements：是否许一个query中有多个<span class="hljs-title class_">MySQL</span>语句 （默认：<span class="hljs-literal">false</span>）<br>  　　flags：用于修改连接标志，更多详情：<span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/felixge/node-mysql#connection-flags</span><br>  　　ssl：使用ssl参数（与crypto.<span class="hljs-property">createCredenitals</span>参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑<span class="hljs-title class_">Amazon</span> <span class="hljs-variable constant_">RDS</span>的配置文件<br>  <br></code></pre></td></tr></table></figure></li><li><p>查询数据实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查询 users 表中所有的数据</span><br> <span class="hljs-keyword">const</span> sqlStr1 = <span class="hljs-string">&#x27;select * from users&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlStr1, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 查询数据失败</span><br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 查询数据成功</span><br>  <span class="hljs-comment">// 注意：如果执行的是 select 查询语句，则执行的结果是数组</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p>新增数据实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 向 users 表中，新增一条数据，其中 username 的值为 Spider-Man，password 的值为 pcc123</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;Spider-Man&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;pcc123&#x27;</span> &#125;<br><span class="hljs-comment">// 定义待执行的 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr2 = <span class="hljs-string">&#x27;insert into users (username, password) values (?, ?)&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr2, [user.<span class="hljs-property">username</span>, user.<span class="hljs-property">password</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行 SQL 语句失败了</span><br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 成功了</span><br>  <span class="hljs-comment">// 注意：如果执行的是 insert into 插入语句，则 results 是一个对象</span><br>  <span class="hljs-comment">// 可以通过 affectedRows 属性，来判断是否插入数据成功</span><br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入数据成功!&#x27;</span>)<br>  &#125;<br>&#125;) <br><br><br><span class="hljs-comment">// 演示插入数据的便捷方式</span><br><span class="hljs-keyword">const</span> user2 = &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;Spider-Man2&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;pcc4321&#x27;</span> &#125;<br><span class="hljs-comment">// 定义待执行的 SQL 语句  set?会把后续对象中的配置对逐个展开</span><br><span class="hljs-keyword">const</span> sqlStr3 = <span class="hljs-string">&#x27;insert into users set ?&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr3, user2, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入数据成功&#x27;</span>)<br>  &#125;<br>&#125;) <br><br></code></pre></td></tr></table></figure></li><li><p>更新数据实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 演示如何更新用户的信息</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;000&#x27;</span> &#125;<br><span class="hljs-comment">// 定义 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr4 = <span class="hljs-string">&#x27;update users set username=?, password=? where id=?&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr4, [user.<span class="hljs-property">username</span>, user.<span class="hljs-property">password</span>, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 注意：执行了 update 语句之后，执行的结果，也是一个对象，可以通过 affectedRows 判断是否更新成功</span><br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新成功&#x27;</span>)<br>  &#125;<br>&#125;) <br><br><span class="hljs-comment">// 演示更新数据的便捷方式</span><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;aaaa&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;0000&#x27;</span> &#125;<br><span class="hljs-comment">// 定义 SQL 语句</span><br><span class="hljs-keyword">const</span> sqlStr5 = <span class="hljs-string">&#x27;update users set ? where id=?&#x27;</span><br><span class="hljs-comment">// 执行 SQL 语句</span><br>db.<span class="hljs-title function_">query</span>(sqlStr5, [user, user.<span class="hljs-property">id</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;更新数据成功&#x27;</span>)<br>  &#125;<br>&#125;) <br><br></code></pre></td></tr></table></figure></li><li><p>删除数据实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 删除 id 为 5 的用户</span><br> <span class="hljs-keyword">const</span> sqlStr6 = <span class="hljs-string">&#x27;delete from users where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlStr6, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-comment">// 注意：执行 delete 语句之后，结果也是一个对象，也会包含 affectedRows 属性</span><br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除数据成功&#x27;</span>)<br>  &#125;<br>&#125;) <br><br></code></pre></td></tr></table></figure></li><li><h4 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h4><p>使用 DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，<strong>推荐使用</strong>标记删除的形式，来<strong>模拟删除的动作</strong>。</p><p>所谓的标记删除，就是在表中设置类似于 <strong>status</strong> 这样的<strong>状态字段</strong>，来<strong>标记</strong>当前这条数据是否被删除。</p><p>当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应的 status 字段标记为删除即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 标记删除</span><br><span class="hljs-keyword">const</span> sqlStr7 = <span class="hljs-string">&#x27;update users set status=? where id=?&#x27;</span><br>db.<span class="hljs-title function_">query</span>(sqlStr7, [<span class="hljs-number">1</span>, <span class="hljs-number">6</span>], <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>  <span class="hljs-keyword">if</span> (results.<span class="hljs-property">affectedRows</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;标记删除成功&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>结束数据库连接两种方法和区别</p><p>end()<br> 　end()方法在queries都结束后执行，end()方法接收一个回调函数，queries执行出错，仍然后结束连接，错误会返回给回调函数err参数，可以在回调函数中处理！<br> 　destory()<br> 　比较暴力，没有回调函数，即刻执行，不管queries是否完成！</p></li></ul><h2 id="5-前后端身份认证"><a href="#5-前后端身份认证" class="headerlink" title="5 前后端身份认证"></a>5 前后端身份认证</h2><h3 id="5-1-WEB开发模式"><a href="#5-1-WEB开发模式" class="headerlink" title="5.1 WEB开发模式"></a>5.1 WEB开发模式</h3><ul><li><p><strong>主流模式</strong></p><p>目前主流的 Web 开发模式有两种，分别是：</p><ul><li><p><strong>基于服务端渲染</strong>的传统 Web 开发模式</p><p>服务端渲染的概念：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据。</p></li><li><p><strong>基于前后端分离</strong>的新型 Web 开发模式</p><p>前后端分离的概念：前后端分离的开发模式，<strong>依赖于</strong> <strong>Ajax</strong> <strong>技术的广泛应用</strong>。简而言之，前后端分离的 Web 开发模式，就是<strong>后端只负责提供</strong> <strong>API</strong> <strong>接口，前端使用</strong> <strong>Ajax</strong> <strong>调用接口</strong>的开发模式。</p></li></ul></li><li><p><strong>优缺点</strong></p><ul><li><p><strong>服务端渲染</strong></p><ul><li><p>优点：<br> 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。<br> 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。</p></li><li><p>缺点：<br> 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。<br> 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。</p></li></ul></li><li><p><strong>前后端分离</strong></p><ul><li><p>优点：</p><p>① <strong>开发体验好。</strong>前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。</p><p>② <strong>用户体验好。</strong>Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。</p><p>③ <strong>减轻了服务器端的渲染压力。</strong>因为页面最终是在每个用户的浏览器中生成的。</p></li><li><p>缺点：</p><p>① <strong>不利于</strong> <strong>SEO</strong>。**因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、React 等前端框架的 <strong>SSR</strong> （server side render）技术能够很好的解决 SEO 问题！）</p></li></ul></li></ul></li><li><p><strong>总结</strong></p><p>比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染；</p><p>而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式。</p><p>另外，具体使用何种开发模式并不是绝对的，为了<strong>同时兼顾</strong>了<strong>首页的渲染速度</strong>和<strong>前后端分离的开发效率</strong>，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式。</p></li></ul><h3 id="5-2-身份认证概念与分类"><a href="#5-2-身份认证概念与分类" class="headerlink" title="5.2 身份认证概念与分类"></a>5.2 身份认证概念与分类</h3><p>​身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：</p><ul><li>服务端渲染推荐使用 <strong>Session</strong> <strong>认证机制</strong></li></ul><ul><li>前后端分离推荐使用 <strong>JWT</strong> <strong>认证机制</strong></li></ul><h3 id="5-3Session-认证"><a href="#5-3Session-认证" class="headerlink" title="5.3Session 认证"></a>5.3<strong>Session</strong> 认证</h3><ul><li><p><strong>HTTP 协议</strong></p><p>HTTP 协议的无状态性，指的是客户端<strong>的每次</strong> <strong>HTTP</strong> <strong>请求都是独立的</strong>，连续多个请求之间没有直接的关系，<strong>服务器不会主动保留每次</strong> <strong>HTTP</strong> <strong>请求的状态</strong>。针对HTTP协议的无状态下，web开发中需要使用cookie。</p></li><li><p><strong>Cookie</strong></p><p>Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。<br>不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。</p><p>Cookie 具有：自动发送、域名独立、过期实现、4kb限制的特性</p></li><li><p><strong>Cookie</strong> <strong>在身份认证中的作用</strong></p><p>客户端第一次请求服务器的时候，服务器<strong>通过响应头的形式</strong>，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。</p><p>随后，当客户端浏览器每次请求服务器的时候，浏览器会<strong>自动</strong>将身份认证相关的 Cookie，<strong>通过请求头的形式</strong>发送给服务器，服务器即可验明客户端的身份。</p></li><li><p><strong>Cookie的不安全性</strong></p><p>由于 Cookie 是存储在浏览器中的，而且<strong>浏览器也提供了读写</strong> <strong>Cookie</strong> <strong>的</strong> <strong>API</strong>，因此 <strong>Cookie</strong> <strong>很容易被伪造</strong>，不具有安全性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。</p></li><li><p><strong>Session的工作原理</strong></p><ul><li>浏览器客户端在登录时提交账户与密码到服务器</li><li>服务器验证账号与密码，验证通过后<strong>，将登录成功的用户信息存储在服务器的内存中，同时生成与之相对应的Cookie字符串，</strong>之后服务器将生成的cookie响应给客户端</li><li>浏览器接收cookie文件 并自动把该cookie存储在当前域名下</li><li>浏览器客户端重新发起请求时，会通过请求头自动将本域名下所有可用的cookie发送给服务器</li><li>服务器接收请求头，根据其携带的cookie从内存中查找对应的信息</li><li>信息匹配成功后，服务器会依据当前的用户生成特定的响应内容</li><li>服务器响应：把当前用户对应的页面内容响应给浏览器</li></ul></li><li><p><strong>Express</strong> <strong>中使用</strong> <strong>Session</strong> <strong>认证</strong></p><ul><li><p>安装express-session 中间件<code>npm install express-session</code></p></li><li><p>配置express-session中间件，需要使用<code>app.use(...)</code>来注册session中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express 模块</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 创建 express 的服务器实例</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br><span class="hljs-comment">// 配置 Session 中间件</span><br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-title function_">session</span>(&#123;<br>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;password&#x27;</span>,   <span class="hljs-comment">//secret属性的值可以为任意字符串 也就是个加密密钥</span><br>    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,      <span class="hljs-comment">//固定写法</span><br>    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">//固定写法</span><br>  &#125;)<br>)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>向session中存储数据</p><p>当 express-session 中间件配置成功后，即可通过 <strong>req.session</strong> 来访问和使用 session 对象，从而存储用户的关键信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 登录的 API 接口</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 判断用户提交的登录信息是否正确</span><br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">body</span>.<span class="hljs-property">username</span> !== <span class="hljs-string">&#x27;admin&#x27;</span> || req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span> !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录失败&#x27;</span> &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 将登录成功后的用户信息，保存到 Session 中</span><br>  <span class="hljs-comment">// 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span> = req.<span class="hljs-property">body</span> <span class="hljs-comment">// 用户的信息</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 用户的登录状态</span><br>  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>向session中读取数据</p><p>直接通过<strong>req.session</strong>对象上获取之前存储的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取用户姓名的接口</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 从 Session 中获取用户的名称，响应给客户端</span><br>  <span class="hljs-keyword">if</span> (!req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;fail&#x27;</span> &#125;)<br>  &#125;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;success&#x27;</span>,<br>    <span class="hljs-attr">username</span>: req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">username</span>,<br>  &#125;)<br></code></pre></td></tr></table></figure></li><li><p>清空session</p><p>调用<code>req.session.destroy()</code>函数，即可清空服务器保存的 session 信息。仅清空当前响应用户的session信息</p></li></ul></li><li><p>session的局限性</p><p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，<strong>需要做很多额外的配置</strong>，才能实现跨域 Session 认证。</p></li></ul><h3 id="5-4-JWT认证"><a href="#5-4-JWT认证" class="headerlink" title="5.4 JWT认证"></a>5.4 JWT认证</h3><ul><li><p><strong>JWT的工作原理</strong></p><ul><li>浏览器客服端在登录时提交账号与密码给服务器</li><li>服务器接收账号密码后进行验证，验证通过后将用户的信息对象，经过加密后生成Token字符串</li><li>服务器响应：将生成的Token字符串发送给浏览器客户端</li><li>浏览器客户端接收Token后并自动将其存在LocalStorage或者SessionStorage中</li><li>浏览器客户端重新发起请求时，通过请求头中的Authorization字段，将Token发送给服务器</li><li>服务器接收Token并将其还原成对应的用户信息，之后进行用户信息验证</li><li>用户身份认证成功后，服务器针对当前用户生成特定的相应内容</li><li>服务器响应:把当前用户对应的页面内容响应给浏览器</li></ul><p><strong>总结：</strong>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p></li><li><p><strong>JWT的组成部分</strong></p><p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。</p><p>三者之间使用英文的“.”分隔，如<code>Header.Payload.Signature</code>  JWT字符串都是加密后的</p><ul><li><strong>Payload</strong> 部分<strong>才是真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串。</li><li>Header 和 Signature 是<strong>安全性相关</strong>的部分，只是为了保证 Token 的安全性。</li></ul></li><li><p><strong>JWT的使用方法</strong></p><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是<strong>把</strong> <strong>JWT</strong> <strong>放在</strong> <strong>HTTP</strong> <strong>请求头的</strong> <strong>Authorization</strong> <strong>字段中</strong>，格式如下：</p><p><code>Authorization:Bearer &lt;token&gt;</code></p></li><li><p><strong>在Express中使用JWT</strong></p><ul><li><p>安装相关的包</p><p><code>npm install jsonwebtoken express-jwt</code></p><p>jsonwebtoken用于生成 JWT 字符串<br>express-jwt用于将 JWT 字符串解析还原成 JSON 对象</p></li></ul><ul><li><p>定义secret密钥</p><p>为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于<strong>加密</strong>和<strong>解密</strong>的 secret 密钥：</p><p>①当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串</p><p>②当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密</p><p>本质就是个字符串<code>const secretKey=&#39;passWord&#39;</code></p></li><li><p>生成 JWT 字符串</p><p>调用 <strong>jsonwebtoken</strong> 包提供的 <strong>sign()</strong> 方法，将用户的信息加密成 JWT 字符串，响应给客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端</span><br><span class="hljs-comment">// 参数1：用户的信息对象</span><br><span class="hljs-comment">// 参数2：加密的秘钥</span><br><span class="hljs-comment">// 参数3：配置对象，可以配置当前 token 的有效期</span><br><span class="hljs-comment">// 记住：千万不要把密码加密到 token 字符中</span><br>  <span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br>  <span class="hljs-keyword">const</span> expressJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br>  <br>  <span class="hljs-keyword">const</span> tokenStr = jwt.<span class="hljs-title function_">sign</span>(&#123; <span class="hljs-attr">username</span>: userinfo.<span class="hljs-property">username</span> &#125;, secretKey, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;30s&#x27;</span> &#125;)<br>res.<span class="hljs-title function_">send</span>(&#123;<br>  <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录成功！&#x27;</span>,<br>  <span class="hljs-attr">token</span>: tokenStr, <span class="hljs-comment">// 要发送给客户端的 token 字符串</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>将 JWT 字符串还原为JSON对象</p><p>客户端每次在访问那些有权限接口的时候，都需要主动通过<strong>请求头中的</strong> <strong>Authorization</strong> <strong>字段</strong>，将 Token 字符串发送到服务器进行身份认证。</p><p>此时，服务器可以通过<code>express-jwt</code>这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注册将 JWT 字符串解析还原成 JSON 对象的中间件</span><br><span class="hljs-comment">// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上</span><br><span class="hljs-comment">//expressJWT(&#123; secret: secretKey &#125;)用于解析Token</span><br><span class="hljs-comment">//unless(&#123; path: [/^\/api\//] &#125;)  用来指定不需要访问权限的接口</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;))<br></code></pre></td></tr></table></figure></li><li><p><strong>使用</strong> <strong>req.user</strong> <strong>获取用户信息</strong></p><p>当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 <strong>req.user</strong> 对象，来访问从 JWT 字符串中解析出来的用户信息了，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是一个有权限的 API 接口</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/admin/getinfo&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>  <span class="hljs-comment">// TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">user</span>)<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;获取用户信息成功！&#x27;</span>,<br>    <span class="hljs-attr">data</span>: req.<span class="hljs-property">user</span>, <span class="hljs-comment">// 要发送给客户端的用户信息</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>捕获解析</strong> <strong>JWT</strong> <strong>失败后产生的错误</strong></p><p>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串<strong>过期</strong>或<strong>不合法</strong>，会产生一个<strong>解析失败</strong>的错误，影响项目的正常运行。我们可以通过 <strong>Express</strong> <strong>的错误中间件</strong>，捕获这个错误并进行相关的处理，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 这次错误是由 token 解析失败导致的</span><br>  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>: <span class="hljs-number">401</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;无效的token&#x27;</span>,<br>    &#125;)<br>  &#125;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;未知的错误&#x27;</span>,<br>  &#125;)<br>&#125;) <br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Postman-禁用自动更新❗❗❗"><a href="#Postman-禁用自动更新❗❗❗" class="headerlink" title="Postman 禁用自动更新❗❗❗"></a>Postman 禁用自动更新❗❗❗</h2><blockquote><p>这是一项危险操作，将会使你的电脑无法与Postman下载服务器连接，当然这就可以使你的Postman应用程序不再更新<br>如果想更新请将此解析注释或移除<br>Windows 删除安装目录的update.exe即可</p></blockquote><p>将此解析加入你电脑的主机文件hosts</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.0.0.0</span>         dl.pstmn.io<br></code></pre></td></tr></table></figure><p><strong>hosts文件在</strong></p><blockquote><p><strong>Windows</strong>：<code>C:/Windows/System32/drivers/etc/hosts</code><br><strong>Linux &amp; Mac</strong>：<code>/etc/hosts</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node内置模块</tag>
      
      <tag>npm</tag>
      
      <tag>Express</tag>
      
      <tag>mySQL</tag>
      
      <tag>JWT</tag>
      
      <tag>Session</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/09/03/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/03/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="1-Git基础使用"><a href="#1-Git基础使用" class="headerlink" title="1 Git基础使用"></a>1 Git基础使用</h2><h3 id="Git-使用前配置"><a href="#Git-使用前配置" class="headerlink" title="Git 使用前配置"></a>Git 使用前配置</h3><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名：<code>git config --global user.name 提交人姓名</code></li><li>配置提交人姓名：<code>git config --global user.email 提交人邮箱</code></li><li>查看git配置信息：<code>git config --list</code></li></ol><p><strong>注意</strong></p><ol><li>如果要对配置信息进行修改，重复上述命令即可。</li><li>配置只需要执行一次。</li></ol><h3 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h3><ol><li><code>git init</code> 初始化git仓库</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件</li><li><code>git commit -m 提交信息</code> 向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code></li><li>将文件从暂存区中删除： <code>git rm --cached 文件</code></li><li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：<code>git rest --hard commitID</code></li></ul><h2 id="2-Git深入理解"><a href="#2-Git深入理解" class="headerlink" title="2 Git深入理解"></a>2 Git深入理解</h2><h3 id="分支概念"><a href="#分支概念" class="headerlink" title="分支概念"></a>分支概念</h3><p><strong>主分支（main）</strong>：第一次向 git 仓库中提交更新记录时自动产生的一个分支。</p><p><strong>开发分支（develop）</strong>：作为开发的分支，基于 master 分支创建。</p><p><strong>功能分支（feature）</strong>：作为开发具体功能的分支，基于开发分支创建</p><h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支 (切换分支之前需要提交)</li><li><code>git merge 来源分支</code> 合并分支（如果存在两个分支，dev和master，如果想要将dev分支的内容合并到master分支上，此时首先要回到master分支，然后再使用命令 git merge dev，而且dev分支依旧存在） PS：之后还需要 <code>git push</code> 将代码推送到云端。</li><li><code>git push -u origin 分支名称</code> 首先要在本地切换到分支，然后执行该命令，在远程新建分支并推送分支的代码。</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><h2 id="暂时保存更改"><a href="#暂时保存更改" class="headerlink" title="暂时保存更改"></a>暂时保存更改</h2><p>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。</p><p>使用场景：分支临时切换</p><ul><li><p>存储临时改动：<code>git stash</code></p><p>使用git add后将文件添加到暂存区后，还没有commit提交。此时使用git stash，将当前分支所有改动剪切到git的剪切板中，文件会回到之前的状态。如果使用git status，会发现显示的是noting to commit，因此便可以切换分支。</p></li></ul><ul><li>恢复改动：<code>git stash pop</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>git branch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3基础学习</title>
    <link href="/2022/09/03/Vue3%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/03/Vue3%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3基础学习"><a href="#Vue3基础学习" class="headerlink" title="Vue3基础学习"></a>Vue3基础学习</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue --version<br><span class="hljs-comment">## 安装或者升级你的@vue/cli</span><br>npm install -g @vue/cli<br><span class="hljs-comment">## 创建</span><br>vue create vue_test<br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="D:\Git\Hexo\yubincoder\source_posts\Vue3基础学习.assets\k8sx4w.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建工程</span><br>npm init vite-app &lt;project-name&gt;<br><span class="hljs-comment">## 进入工程目录</span><br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br><span class="hljs-comment">## 安装依赖</span><br>npm install<br><span class="hljs-comment">## 运行</span><br>npm run dev<br></code></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。  </li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code>    <code>xxx.value.a   //xxx是对象</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code>  <code>&lt;div&gt;&#123;&#123;xxx.a&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是 靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li><li>数组类型对象可以通过数组索引进行修改们可以响应式（Vue中必须用数组方法）</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    get () &#123;&#125;, <br>    set () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br><span class="hljs-comment">// 拦截读取属性值</span><br>    get (target, prop) &#123;   <span class="hljs-comment">//target是代理的对象，prop是具体操作的属性</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取了<span class="hljs-subst">$&#123;prop&#125;</span>属性`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置属性值或添加新属性</span><br>    set (target, prop, value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, prop, value)<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除属性</span><br>    deleteProperty (target, prop) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, prop)<br>    &#125;<br>&#125;)<br><br>proxy.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tom&#x27;</span>   <br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    ...<br><span class="hljs-comment">//计算属性——简写</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>    &#125;)<br>    <span class="hljs-comment">//计算属性——完整</span><br>    <span class="hljs-keyword">let</span> fullName = <span class="hljs-title function_">computed</span>(&#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> person.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + person.<span class="hljs-property">lastName</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-keyword">const</span> nameArr = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br>            person.<span class="hljs-property">firstName</span> = nameArr[<span class="hljs-number">0</span>]<br>            person.<span class="hljs-property">lastName</span> = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致，vue2.x中watch是配置项,vue3z中watch是个函数，可以多次调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue2.x</span><br><span class="hljs-attr">watch</span>:&#123;<br><span class="hljs-attr">a</span>:&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>,<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;....&#125;<br>       &#125;,<br>    <span class="hljs-title function_">b</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;....&#125;,<br>&#125;<br><span class="hljs-comment">//vue3.x</span><br>watch（a,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;...&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;）<br>watch（b,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;...&#125;）<br></code></pre></td></tr></table></figure></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性（obj）时：deep配置有效。如果该属性是简单数据类型，那就没有所谓deep配置的必要了</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//情况一：监视ref定义的响应式数据--单个ref</span><br><span class="hljs-title function_">watch</span>(sum,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>&#125;)<br><br><span class="hljs-comment">//情况二：监视多个ref定义的响应式数据</span><br><span class="hljs-title function_">watch</span>([sum,msg],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>    <span class="hljs-comment">//newValue、oldValue是个数组，数组元素是监视的ref对应的数据，</span><br>   <span class="hljs-comment">//[newValue(sum),newValue(msg)],[oldValue(sum),oldValue(msg)],</span><br>&#125;) <br><br><span class="hljs-comment">/* 情况三：监视reactive定义的响应式数据</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span><br><span class="hljs-comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视，deep配置不再奏效</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">watch</span>(person,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">false</span>&#125;) <span class="hljs-comment">//此处的deep配置不再奏效</span><br><br><span class="hljs-comment">//情况四：监视reactive定义的响应式数据中的某个属性（基本数据类型）</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">age</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//person.age是个基本数据类型（Number）</span><br>    <span class="hljs-comment">//无法直接监视person.age（只能监视ref、reactive、数组）  需要写成函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的age变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <br><br><span class="hljs-comment">//情况五：监视reactive定义的响应式数据中的某些属性（多个基本数据类型）</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">job</span>,<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">name</span>],<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//person.job和person.name都是基本数据对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)<br>        <span class="hljs-comment">//newValue、oldValue是个数组，数组元素是监视的ref对应的数据，</span><br>       <span class="hljs-comment">//[newValue(job),newValue(name)],[oldValue(job),oldValue(name)],</span><br>&#125;,&#123;<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;)<br><br><br><span class="hljs-comment">//特殊情况（对象或数组）</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>person.<span class="hljs-property">jobObj</span>,<span class="hljs-function">(<span class="hljs-params">newValue,oldValue</span>)=&gt;</span>&#123;    <span class="hljs-comment">//jobObj是个对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;person的jobObj变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;<span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span>&#125;) <span class="hljs-comment">//此处由于监视的是reactive是定义的对象中的某个属性（obj对象），所以deep配置有效</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>注意事项</strong></p><ul><li><p>ref一般用于创建基本数据类型，也可以创建对象类型；ref生成的实例对象为RefImpl（简称ref对象），const  a &#x3D;ref（….）</p><ul><li><p><strong>简单数据中</strong><code>RefImpl&#123;value：xxx，....&#125;</code>value的值与自身相等，因此操作该数值的时候才需要a.value进行操作，</p></li><li><p>watch的时候需要监测的是数据结构，因此监视的应该是a，而不是a.value，a.value是一个引用的值，watch监测的配置项（或者说是一个对象）</p><hr></hr></li><li><p><strong>对象类型数据</strong><code>RefImpl&#123;value：Proxy，....&#125;</code>   内部是调用了reactive函数来生成的value值</p></li><li><p><strong>此时如果watch监视a</strong>，则RefImpl{，….}中需要对象变化才能监测到；<strong>但是！value：Proxy</strong>中Proxy是调用reactive生成的一个的对象，默认情况下<code>deep:false</code>如果是修改这个对象下层的子对象，则无法监测到（Proxy对象引用没有变化），除非整个Proxy对象进行替换修改才能监测到。如果此时开启深度监视<code>deep:true</code> 则可以正常监视</p></li><li><p><strong>此时如果watch监视a.value</strong>，本质等同于监测reactive创建的Proxy对象，因此自动 深度监视，且deep配置会失效</p><hr></hr><hr></hr></li></ul></li><li><p>reactive用于创建对象类型</p><ul><li>&#96;&#96;&#96;js<br>const info &#x3D; reactive({    &#x2F;&#x2F;watch监视info，相当于监视整个Proxy对象，强制开启深度监视<br>n：666，<br>name：’reactive’<br>&#x2F;&#x2F;watch监视info.n，相当于监视一个基本数据，没有二级子对象，没必要配置deep<br>infoObj：{<br>    x：1，<br>    y:2<br>}<br>  &#x2F;&#x2F;watch监视info.infoObj，相当于监视一个Obj数据，有二级子对象，可以选择性配置deep<br>})<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-code">      </span><br><span class="hljs-code"></span><br><span class="hljs-section">### 3.watchEffect函数</span><br><br><span class="hljs-bullet">-</span> watch的套路是：既要指明监视的属性，也要指明监视的回调。<br><br><span class="hljs-bullet">-</span> watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。触发监视后重新执行一次回调函数<br><br><span class="hljs-bullet">-</span> watchEffect有点像computed：<br><br><span class="hljs-bullet">  -</span> 但computed注重的计算出来的值（回调函数的返回值），触发监视后重新执行一次回调函数， 所以必须要写返回值。<br><span class="hljs-bullet">  -</span> 而watchEffect更注重的是过程（回调函数的函数体），触发监视后重新执行一次回调函数，所以不用写返回值。<br><br>  <span class="hljs-code">```js</span><br><span class="hljs-code">  //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><br><span class="hljs-code">  watchEffect(()=&gt;&#123;</span><br><span class="hljs-code">      const x1 = sum.value</span><br><span class="hljs-code">      const x2 = person.age</span><br><span class="hljs-code">      console.log(&#x27;watchEffect配置的回调执行了&#x27;)</span><br><span class="hljs-code">  &#125;)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:300px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://v2.cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:400px;float:left"><strong>vue3.0的生命周期</strong><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><hr style="clear:both"><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li>作为api形式的使用时，需要先引入<code>import &#123;onBeforeMount,onMounted......&#125;from &#39;vue&#39;</code></li><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount(  ()=&gt;&#123;...&#125;  )</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted(  ()=&gt;&#123;...&#125;  )</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code>(  ()&#x3D;&gt;{…}  )</li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code>(  ()&#x3D;&gt;{…}  )</li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount(  ()=&gt;&#123;...&#125;  )</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted(  ()=&gt;&#123;...&#125;  )</code></li><li><strong>注意：</strong>通过配置项使用生命周期钩子（vue2.x）且同时使用api形式的生命周期钩子（vue3.x）时，先后顺序</li><li>setup→beforeCreate→created→onBeforeMount→beforeMount→onMounted→mounted</li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>文件 <code>src/hooks/xxx.js</code> 在该文件中可以调用全部的Composition API，然后暴露出去 export defalut  （需要带return） 在其它组件可以import使用</p></li><li><p>类似于vue2.x中的mixin。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 功能：可以把多个组件共用的配置提取成一个混入对象<br><br><span class="hljs-number">2.</span> 使用方式：<br><br>   第一步定义混合：<br><br></code></pre></td></tr></table></figure><p>   {<br>   data(){….},<br>   methods:{….}<br>   ….<br>   }</p>   <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">第二步使用混入：<br>  <br>​全局混入：```Vue.<span class="hljs-keyword">mixin</span>(xxx)```<br>​局部混入：```mixins:[<span class="hljs-string">&#x27;xxx&#x27;</span>]```<br></code></pre></td></tr></table></figure></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。toRef(Obj,key)</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code>    <code>const job = toRef(person.info.msg,&#39;job&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用且不丢失响应式时（比如用于插值模板）</p></li><li><p>&#96;&#96;&#96;js<br>&#x2F;&#x2F;vue3中使用<br>setup(){<br>let person &#x3D; reactive({<br>    name:’张三’,<br>    age:18,<br>    job:{<br>        j1:{<br>            salary:20<br>        }<br>    }<br>});<br><br>return{<br><br>    &#x2F;&#x2F;toRef<br>    name:toRef(person,’name’),<br>    age:toRef(person,’age’),<br>    salary:toRef(person.job.j1,’age’),<br><br>    &#x2F;&#x2F;toRefs<br>    …toRefs(person)<br>    &#x2F;&#x2F;toRefs(person)执行后是一个对象合集 需要展开<br>    &#x2F;&#x2F;只执行一级结构，相当于运行了以下代码<br>    &#x2F;&#x2F;name:toRef(person,’name’),<br>    &#x2F;&#x2F;age:toRef(person,’age’),<br>     &#x2F;&#x2F;job:toRef(person,’job’),<br>};<br>}</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"></span><br><span class="language-xml">- 扩展：```toRefs``` 与```toRef```功能一致，但可以批量创建多个 ref 对象，语法：```toRefs(person)```</span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">- 注意：toRefs只会在setup运行的时候进行多个ref对象的创建，如果初始未定义ref对象，后期通过方法新增ref对象，则无法自动创建（可以在初始创建一个空值的）</span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"># 三、其它 Composition API</span><br><span class="language-xml"></span><br><span class="language-xml">## 1.shallowReactive 与 shallowRef</span><br><span class="language-xml"></span><br><span class="language-xml">- **shallowReactive**：只处理对象最外层属性的响应式（浅响应式）。 </span><br><span class="language-xml">- **shallowRef**：只处理基本数据类型的响应式, 不进行对象的响应式处理（对象类型不借助reactive）</span><br><span class="language-xml"></span><br><span class="language-xml">- 什么时候使用?</span><br><span class="language-xml">  -  如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</span><br><span class="language-xml">  -  如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换（替换可以实现响应式） ===&gt; shallowRef。</span><br><span class="language-xml"></span><br><span class="language-xml">## 2.readonly 与 shallowReadonly</span><br><span class="language-xml"></span><br><span class="language-xml">- **readonly**: 让一个响应式数据变为只读的（深只读，全部数据都不能修改）。</span><br><span class="language-xml">- **shallowReadonly**：让一个响应式数据变为只读的（浅只读，一级数据可以保持只读，深层结构可以修改）。</span><br><span class="language-xml">- 应用场景: 不希望数据被修改时（比如数据是引入的） </span><br><span class="language-xml"></span><br><span class="language-xml">## 3.toRaw 与 markRaw</span><br><span class="language-xml"></span><br><span class="language-xml">- **toRaw**：</span><br><span class="language-xml">  - 作用：将一个由```reactive```生成的<span class="hljs-tag">&lt;<span class="hljs-name">strong</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:orange&quot;</span>&gt;</span>响应式对象（Proxy）<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>转为<span class="hljs-tag">&lt;<span class="hljs-name">strong</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:orange&quot;</span>&gt;</span>普通对象(Object)<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>。</span><br><span class="language-xml">  - 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作(数据可以修改，不引起响应式对象的更新)，不会引起页面更新。</span><br><span class="language-xml">- **markRaw**：</span><br><span class="language-xml">  - 作用：标记一个对象，使其永远不会再成为响应式对象。</span><br><span class="language-xml">  - 应用场景:</span><br><span class="language-xml">    1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。</span><br><span class="language-xml">    2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</span><br><span class="language-xml"></span><br><span class="language-xml">## 4.customRef</span><br><span class="language-xml"></span><br><span class="language-xml">- 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</span><br><span class="language-xml"></span><br><span class="language-xml">- 实现防抖效果：</span><br><span class="language-xml"></span><br><span class="language-xml">  ```vue</span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">keyword</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123;ref,customRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Demo&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//自定义一个myRef</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">myRef</span>(<span class="hljs-params">value,delay</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> timer</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//通过customRef去实现自定义</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span> <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track,trigger</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;       <span class="hljs-comment">//数据被读取时调用</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">track</span>() </span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//告诉Vue这个value值是需要被“追踪”的，如果不设置这个，则只有在首次读取时调用get()</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span> value</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>)&#123;  <span class="hljs-comment">//数据被修改时调用</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-built_in">clearTimeout</span>(timer)</span></span><br><span class="language-javascript"><span class="language-xml">  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  value = newValue</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">trigger</span>() <span class="hljs-comment">//告诉Vue去更新界面</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,delay)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//初始化：解析模板→发现</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">keyword</span>&#125;&#125;</span><span class="language-xml"><span class="language-javascript">→识别到cunstomRef→初始化  调用<span class="hljs-title function_">get</span>()--value             </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">//修改数据：cunstomRef识别到修改→  调用set() --执行value=newValue→trigger()通知vue重新解析→track（）接收到 重新读取并返回新值（如果不设置track，则vue解析时会跳过get，因为是不是初始化了）</span></span></span><br><span class="language-javascript"><span class="language-xml">  </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> keyword = <span class="hljs-title function_">myRef</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">500</span>) <span class="hljs-comment">//使用程序员自定义的ref</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  keyword</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://files.catbox.moe/3cfvgx.jpg" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>......<br>    <span class="hljs-keyword">let</span> car = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;奔驰&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props,context</span>)&#123;<br>......<br>    <span class="hljs-keyword">const</span> car = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-keyword">return</span> &#123;car&#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left;clear:both" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;float:left;clear:both" /> </div><div style='clear:both'>   </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。(hook函数)</p><div style="width:500px;height:340px;overflow:hidden;float:left;">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left;">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style='clear:both'>   </div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件<code>template</code>必须有一个根标签 </li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;teleport to=&quot;移动位置&quot;&gt;   <br> &lt;!--比如to=&quot;body&quot; 那么会在body下创建一个mask的class   body  .mask--&gt;<br>&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;<br>&lt;div class=&quot;dialog&quot;&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p></li><li><p>组件（比如本例的Child）内部可以使用异步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;   &lt;!--Suspense内置了两个插槽，name为default，fallback--&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//注册全局组件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">//注册全局指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">focus</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.v-leave</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.v-enter-from</span>,<br><span class="hljs-selector-class">.v-leave-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.v-leave-from</span>,<br><span class="hljs-selector-class">.v-enter-to</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-component<br>  v-on:close=&quot;handleComponentEvent&quot;  //自定义事件<br>  v-on:click=&quot;handleNativeClickEvent&quot;  //原生事件<br>/&gt;<br></code></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    emits: [&#x27;close&#x27;]   //指定自定义事件，没有声明的属于原生事件<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS Code 指南</title>
    <link href="/2022/09/03/VS%20Code%20%E6%8C%87%E5%8D%97/"/>
    <url>/2022/09/03/VS%20Code%20%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="VS-Code-插件"><a href="#VS-Code-插件" class="headerlink" title="VS Code 插件"></a>VS Code 插件</h3><p>在 vscode 左边栏插件市场中搜索下列英文名点击安装即可。</p><ul><li>Chinese ：中文界面</li><li>Prettier ：代码美化</li><li>Wisen-Translate ：翻译插件(云环境下没有)</li><li>Live server ：实时预览html(视频中的Live Preview有很多bug，弃用)</li><li>Search&#x2F;Translate Hero ：搜索跳转和翻译(云环境下没有)</li><li>vscode-icons ：美化图标</li><li>Git History Diff ：后面git教程中出现的插件</li><li>HTMLHint ：检查html文件出错的地方</li></ul><h3 id="VS-Code-配置"><a href="#VS-Code-配置" class="headerlink" title="VS Code 配置"></a>VS Code 配置</h3><p>Auto Save :自动保存，选择afterDelay</p><p>Format On Save :勾选，保存后自动格式化</p><p>Format On Paste :勾选，粘贴时自动格式化</p><p>Default Formatter :选择prettier，默认格式化插件</p><p>Linked Editing :勾选，同时重命名html标签名</p><p>Accept Suggestion On Commit Character :取消勾选，不再自动补全一些乱七八糟的东西</p><p>Accept Suggestion On Enter :选择off关闭，回车就是应该换行而不是自动补全乱七八糟的代码</p><p>Tab Completion :选择on开启，如需自动补全，使用tab键</p><h3 id="hexo博客框架"><a href="#hexo博客框架" class="headerlink" title="hexo博客框架"></a>hexo博客框架</h3><p>npm install -g hexo-cli</p><p>&#x2F;&#x2F; 全局安装hexo-cli</p><p>ssh-keygen -t rsa -C “<a href="mailto:&#121;&#x75;&#x62;&#105;&#x6e;&#95;&#67;&#x6f;&#x64;&#x65;&#114;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#121;&#x75;&#x62;&#105;&#x6e;&#95;&#67;&#x6f;&#x64;&#x65;&#114;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a>“</p><p>&#x2F;&#x2F;生成本地ssh    文件是这个 id_rsa.pub</p><p>ssh -T <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a></p><p>&#x2F;&#x2F;测试ssh是否绑定成功</p><p>hexo init  </p><p>&#x2F;&#x2F;本地创建hexo框架   init后面可以接新建文件夹 hexo初始化</p><p>hexo s</p><p>&#x2F;&#x2F;开启本地服务端口</p><p>hexo intsall hexo-deployer-git</p><p>&#x2F;&#x2F; 安装hexo-deployer-git</p><p>&#x2F;&#x2F;Deployer not found: git报错检查这个</p><p>_config.yml</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">_config.<span class="hljs-property">yml</span><br><br><span class="hljs-attr">deploy</span>:<br>  <span class="hljs-attr">type</span>: git<br>  <span class="hljs-attr">repository</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/yubinCoder/yubinCoder.github.io.git    </span><br>  <span class="hljs-comment">//git仓库</span><br>  <span class="hljs-attr">branch</span>: main<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">git config --<span class="hljs-variable language_">global</span> user.<span class="hljs-property">email</span> <span class="hljs-string">&quot;yubin_Coder@163.com&quot;</span><br>git config --<span class="hljs-variable language_">global</span> user.<span class="hljs-property">name</span> <span class="hljs-string">&quot;yubinCoder&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vscode插件</tag>
      
      <tag>Vscode配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue深入学习</title>
    <link href="/2022/09/03/Vue%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/03/Vue%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue深入学习笔记"><a href="#Vue深入学习笔记" class="headerlink" title="Vue深入学习笔记"></a>Vue深入学习笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code class="hljs">├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol><li>vue.js与vue.runtime.xxx.js的区别：<ol><li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ol></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li></ol><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>:&#123;<br><span class="hljs-attr">name</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">//类型</span><br><span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//必要性</span><br><span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;老王&#x27;</span> <span class="hljs-comment">//默认值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote></li></ol><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p>第一步定义混合：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">&#123;<br>    data()<span class="hljs-meta">&#123;....&#125;</span>,<br>    methods:<span class="hljs-meta">&#123;....&#125;</span><br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步使用混入：</p><p>​全局混入：<code>Vue.mixin(xxx)</code><br>​局部混入：<code>mixins:[&#39;xxx&#39;]</code></p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">对象.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) &#123;<br>    <span class="hljs-comment">// 1. 添加全局过滤器</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(....)<br><br>    <span class="hljs-comment">// 2. 添加全局指令</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(....)<br><br>    <span class="hljs-comment">// 3. 配置全局混入(合)</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(....)<br><br>    <span class="hljs-comment">// 4. 添加实例方法</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;...&#125;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myProperty</span> = xxxx<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol><li>作用：让样式在局部生效，防止冲突。  </li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol><li><p>组件化编码流程：</p><p>​(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p>​(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p>​1).一个组件在用：放在组件自身即可。</p><p>​2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p>​(3).实现交互：从绑定事件开始。</p></li><li><p>props适用于：</p><p>​(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p><p>​(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p></li><li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></li><li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p></li></ol><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol><li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p>​该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p>​该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code> xxxxxStorage.clear()</code></p><p>​该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">Demo</span> ref=<span class="hljs-string">&quot;demo&quot;</span>/&gt;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">xxx</span>.$on(<span class="hljs-string">&#x27;atguigu&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>......<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线，$bus就是当前应用的vm</span><br>&#125;,<br>    ......<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;......&#125;<br>&#125;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;xxxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;......&#125;<br>&#125;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pid</span> = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>) <span class="hljs-comment">//订阅消息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://files.catbox.moe/xay61j.jpg" style="width:60%" /></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;transition name=&quot;hello&quot;&gt;<br>&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;<br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过渡，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;transition-group name=<span class="hljs-string">&quot;todoItem&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todoObj in TodoListARR&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;todoObj.id&quot;</span>  </span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:todoObj</span>=<span class="hljs-string">&quot;todoObj&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">TodoItem</span>&gt;</span></span>       <br>&lt;/transition-group&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>&lt;transition&gt; </code>或者<code>&lt;transition-group&gt;</code> 在Vue解析后都不会呈现在页面上</p></li></ol></li></ol><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>​解决开发环境中Ajax跨域的问题</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>:&#123;<br>  <span class="hljs-attr">proxy</span>:<span class="hljs-string">&quot;http://localhost:5000&quot;</span>   <span class="hljs-comment">//由vue-cli配置的代理服务器 将请求转发给5000端口</span><br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ol><li><p>优点：配置简单，请求资源时直接发给前端（8080）即可。</p></li><li><p>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</p></li><li><p>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</p></li><li><p>axios请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>,<br>   <br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:5000/xxx&#x27;</span>).<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>,response.<span class="hljs-property">data</span>)&#125;,  <span class="hljs-comment">//请求成功 输出数据</span><br><span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>,error.<span class="hljs-property">message</span>)&#125;    <span class="hljs-comment">//请求失败 输出错误</span><br>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">devServer</span>: &#123;<br>      <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api1&#x27;</span>: &#123;<span class="hljs-comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径  是用来区分不同代理服务器的</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<span class="hljs-comment">// 代理目标的基础路径</span><br>        ws：<span class="hljs-literal">true</span>, <span class="hljs-comment">//用于支持websocket</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//请求转发时 代理服务器→代理目标时  改变代理服务的端口号与代理目标一致</span><br>        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;  <span class="hljs-comment">//重写请求路径，key：value，用value值替换key，key用正则语法</span><br>          <span class="hljs-comment">/*如果不写这部分  则本地路径http://localhost:8080/api1/xxx直接转发给代理目标时为</span><br><span class="hljs-comment">          http://localhost:8080/api1/xxx    changeOrigin：false时</span><br><span class="hljs-comment">          http://localhost:5000/api1/xxx   changeOrigin：true时</span><br><span class="hljs-comment">          代理目标只有http://localhost:5000/xxx 会导致获取失败</span><br><span class="hljs-comment">          */</span><br>          <br>      <span class="hljs-string">&#x27;/api2&#x27;</span>: &#123;<span class="hljs-comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span><br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<span class="hljs-comment">// 代理目标的基础路径</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<span class="hljs-string">&#x27;^/api2&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span><br><span class="hljs-comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span><br><span class="hljs-comment">   changeOrigin默认值为true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：</p><ol><li><p>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</p></li><li><p>缺点：配置略微繁琐，请求资源时必须加前缀，比如&#x2F;api1。</p></li><li><p>axios请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>,<br>axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:5000/api1/xxx&#x27;</span>).<span class="hljs-title function_">then</span>(     <span class="hljs-comment">//  api1是代理服务器中配置的/pi1</span><br><span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>,response.<span class="hljs-property">data</span>)&#125;,  <span class="hljs-comment">//请求成功 输出数据</span><br><span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>,error.<span class="hljs-property">message</span>)&#125;    <span class="hljs-comment">//请求失败 输出错误</span><br>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p></li><li><p>css样式在父组件和子组件中的<code>&lt;style&gt;</code>写都可以</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽（适用于单个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category&gt;<br>           &lt;div&gt;html结构1&lt;/div&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>            &lt;div&gt;<br>               &lt;!-- 定义插槽 --&gt;<br>               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;<br>            &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>具名插槽（适用于多个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category&gt;<br>            &lt;template slot=&quot;center&quot;&gt;<br>              &lt;div&gt;html结构1&lt;/div&gt;<br>            &lt;/template&gt;<br><br>            &lt;template v-slot:footer&gt;     &lt;!--vue2.6新写法  但是只能写在template中--&gt;<br>               &lt;div&gt;html结构2&lt;/div&gt;<br>            &lt;/template&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>            &lt;div&gt;<br>               &lt;!-- 定义插槽 --&gt;<br>               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;<br>               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;<br>            &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>作用域插槽（必须写在template中）</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>&lt;Category&gt;<br>&lt;template scope=&quot;scopeData&quot;&gt;  &lt;!--必须写在&lt;template&gt;中  <br>如果是单个插槽可以不写name 相当于默认插槽--&gt;<br><br>&lt;!-- 生成的是ul列表 --&gt;<br>&lt;ul&gt;<br>&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;`&#123;&#123;g&#125;&#125;`&lt;/li&gt;<br>                    &lt;!-- scopeData.games  games是子组件传入的多个数据 之一--&gt;<br>&lt;/ul&gt;<br>&lt;/template&gt;<br>&lt;/Category&gt;<br><br>&lt;Category&gt;<br>&lt;template slot-scope=&quot;&#123;games&#125;&quot;&gt;  &lt;!-- 结构赋值写法--&gt;  <br>&lt;!--这里由子组件传入的就是&#123;games，otherMsg&#125;  <br>只调用games可以只写这个--&gt;  <br><br>&lt;!-- 生成的是h4标题 --&gt;<br>&lt;h4 v-for=&quot;g in games&quot; :key=&quot;g&quot;&gt;`&#123;&#123;g&#125;&#125;`&lt;/h4&gt;<br>&lt;/template&gt;<br>&lt;/Category&gt;<br><br>子组件中：<br>        &lt;template&gt;<br>            &lt;div&gt;<br>                &lt;slot :games=&quot;games&quot;  otherMsg=&quot;666&quot;&gt;&lt;/slot&gt;  <br>                &lt;!-- 往使用插槽的对象也就是父组件传入名为games和otherMsg的数据<br>且games动态绑定了data中同名数据 --&gt;<br>            &lt;/div&gt;<br>        &lt;/template&gt;<br><br>        &lt;script&gt;<br>            export default &#123;<br>                name:&#x27;Category&#x27;,<br>                props:[&#x27;title&#x27;],<br>                //数据在子组件自身<br>                data() &#123;<br>                    return &#123;<br>                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]<br>                    &#125;<br>                &#125;,<br>            &#125;<br>        &lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2.  原理图"></a>2.  原理图</h3><h3 id="3-何时使用？"><a href="#3-何时使用？" class="headerlink" title="3.  何时使用？"></a>3.  何时使用？</h3><p>多个组件需要共享数据时：</p><p>​①多个组件依赖于统一状态</p><p>​② 来自不同组件的行为需要变更统一状态</p><h3 id="4-搭建vuex环境"><a href="#4-搭建vuex环境" class="headerlink" title="4 .搭建vuex环境"></a>4 .搭建vuex环境</h3><ol><li><p>安装vuex  <code>npm install vuex</code>          <code>npm install vuex@3</code>  </p></li><li><p>&#x2F;&#x2F;默认安装最新的vuex版本也就是4，但是需要vue3支持</p><p>vue2只能用vuex3版本    vue3只能用vuex4版本</p></li><li><p>创建文件：<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue核心库</span><br><span class="hljs-comment">//vuex必须调用Vue.use（Vuex）才能创建实例 因此需要先引入vue核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入Vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-comment">//应用Vuex插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-comment">//准备actions对象——响应组件中用户的动作</span><br><span class="hljs-keyword">const</span> actions = &#123;&#125;<br><span class="hljs-comment">//准备mutations对象——修改state中的数据</span><br><span class="hljs-keyword">const</span> mutations = &#123;&#125;<br><span class="hljs-comment">//准备state对象——保存具体的数据</span><br><span class="hljs-keyword">const</span> state = &#123;&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>actions,<br>mutations,<br>state<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>在<code>main.js</code>中创建vm时传入<code>store</code><strong>配置项</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">......<br><span class="hljs-comment">//引入store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index.js&#x27;</span>   &lt;!--如果是index.<span class="hljs-property">js</span>可以简写<span class="hljs-string">&#x27;./store&#x27;</span>即可  --&gt;<br>......<br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>store<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-基本使用"><a href="#5-基本使用" class="headerlink" title="5.基本使用"></a>5.基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入Vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span> <br><span class="hljs-comment">//引用Vuex</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-comment">//响应组件中加的动作</span><br><span class="hljs-title function_">jia</span>(<span class="hljs-params">context,value</span>)&#123;<br><span class="hljs-comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span><br>context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;JIA&#x27;</span>,value)<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> mutations = &#123;<br>    <span class="hljs-comment">//执行加</span><br><span class="hljs-title function_">JIA</span>(<span class="hljs-params">state,value</span>)&#123;<br><span class="hljs-comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span><br>state.<span class="hljs-property">sum</span> += value<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//初始化数据</span><br><span class="hljs-keyword">const</span> state = &#123;<br>   <span class="hljs-attr">sum</span>:<span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>actions,<br>mutations,<br>state,<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="6-getters的使用"><a href="#6-getters的使用" class="headerlink" title="6.getters的使用"></a>6.getters的使用</h3><ol><li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">......<br><br><span class="hljs-keyword">const</span> getters = &#123;<br><span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br><span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>......<br>getters<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="7-通过computed精简插值语法的写法"><a href="#7-通过computed精简插值语法的写法" class="headerlink" title="7.通过computed精简插值语法的写法"></a>7.通过computed精简插值语法的写法</h3><p>​1.作用：是map方法跟模块化命名的基础，可以精简模板中插值语法。本质是通过computed的计算属性，返回一个前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--常规写法--&gt;<br>`&#123;&#123;this.$store.state.mathObj.resVal&#125;&#125;`<br>&lt;!--使用comoued写法--&gt;<br>computed：&#123;<br>        mathObj()&#123;return  this.$store.state.mathObj &#125;,<br>        isOdd()&#123; return this.$store.getters.isOdd&#125;,<br>        Msg()&#123;return  this.$store.state.Msg&#125;<br>&#125;<br>&lt;!--在模板中调用`&#123;&#123;mathObj.resVal&#125;&#125;`即可,注意重命名后只能在本组件中使用--》<br><br></code></pre></td></tr></table></figure><h3 id="8-四个map方法的使用"><a href="#8-四个map方法的使用" class="headerlink" title="8.四个map方法的使用"></a>8.四个map方法的使用</h3><ol><li><p>先引入方法  <code>import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#39;vuex&#39;</code></p></li><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（对象写法）--可以不同名</span><br>     ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">SUM</span>:<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-attr">subject</span>:<span class="hljs-string">&#x27;subject&#x27;</span>&#125;),<br>         <span class="hljs-comment">//相当于执行SUM()&#123;return this.$store.state.sum&#125; 其他两个同理</span><br>         <span class="hljs-comment">//mapState 返回一个对象&#123;SUM()，school（），subject（）&#125; 最后用展开运算符进行展开</span><br>   <br>         <br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（数组写法）--同名</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br>          <span class="hljs-comment">//相当于执行sum()&#123;return this.$store.state.sum&#125; 其他两个同理</span><br>&#125;,<br></code></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>(&#123;<span class="hljs-attr">bigSum</span>:<span class="hljs-string">&#x27;bigSum&#x27;</span>&#125;),<br>        <span class="hljs-comment">//相当于执行bigSum()&#123;return this.$store.getters.bigSum&#125; 其他两个同理</span><br><br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br>&#125;,<br></code></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>(&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br>    <span class="hljs-comment">//相当于执行incrementOdd()&#123;return this.$store.dispatch.incrementOdd&#125; 其他两个同理</span><br><br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-string">&#x27;jiaWait&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：increment、decrement（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br>        <span class="hljs-comment">//相当于执行increment()&#123;return this.$store.commit.JIA&#125; 其他两个同理</span><br>    <br>    <span class="hljs-comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-string">&#x27;JIAN&#x27;</span>]),<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong style='color:red'>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</strong></p></blockquote><h3 id="9-模块化-命名空间"><a href="#9-模块化-命名空间" class="headerlink" title="9.模块化+命名空间"></a>9.模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> countAbout = &#123;<br>  <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>  <span class="hljs-attr">state</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>&#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>)&#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;<br>  &#125;<br>&#125;  <br><br><span class="hljs-keyword">const</span> personAbout = &#123;<br>  <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>  <span class="hljs-attr">state</span>:&#123; ... &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">modules</span>: &#123;<br>    countAbout,<br>    personAbout<br>  &#125; <br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取  this.$store.state是一个对象集合，其中包含personAbout对象，</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">personAbout</span>.<span class="hljs-property">list</span><br><span class="hljs-comment">//方式二：借助mapState读取：</span><br>...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取   </span><br><span class="hljs-comment">//getter是个对象，key值就是personAbout/firstPersonName，value值就是return值，(key值包含&#x27;/&#x27; 不能用常规读取;)  </span><br><span class="hljs-comment">//读取对象方法:1. 直接读取  Object.name     2.Object[&#x27;name&#x27;]</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;personAbout/firstPersonName&#x27;</span>]<br><br><span class="hljs-comment">//方式二：借助mapGetters读取：</span><br>...<span class="hljs-title function_">mapGetters</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接dispatch</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;personAbout/addPersonWang&#x27;</span>,person)<br><span class="hljs-comment">//方式二：借助mapActions：</span><br>...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接commit</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)<br><span class="hljs-comment">//方式二：借助mapMutations：</span><br>...<span class="hljs-title function_">mapMutations</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br></code></pre></td></tr></table></figure><p>7.四个map的写法就是<code>...mapxxx(&#39;模块名称&#39;，map映射规则（对象写法或者数组写法)</code></p></li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key是路径，value是组件。</li></ol><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code>  注意版本问题</p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code>  (main.js)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">import Vue from &#x27;vue&#x27;<br><br>import App from &#x27;./App.vue&#x27;<br><br>//引入store插件 vuex使用 <br>import store from &#x27;./store/index&#x27;<br><br>//引入VueRouter插件 路由使用 <br>import VueRouter from &#x27;vue-router&#x27;<br>Vue.use(VueRouter);<br><br>//引入router<br>import router from &#x27;./pages/index&#x27;<br><br>Vue.config.productionTip = false<br><br>new Vue(&#123;<br>  render: h =&gt; h(App),<br>  //使用store插件<br>  store,<br>  router<br>&#125;).$mount(&#x27;#app&#x27;)<br></code></pre></td></tr></table></figure></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入VueRouter</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">//引入路由子组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><br><span class="hljs-comment">//创建router实例对象，去管理一组一组的路由规则</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;<br>]<br>&#125;)<br><br><span class="hljs-comment">//暴露router</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-view&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol><li><p>配置路由规则，使用children配置项：<code>children:[&#123;path:&#39;xxx&#39;,component:...&#125;,&#123;...&#125;,&#123;...&#125;]</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span>,<br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br><span class="hljs-attr">children</span>:[ <span class="hljs-comment">//通过children配置子级路由</span><br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>, <span class="hljs-comment">//此处一定不要写：/news</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-comment">//此处一定不要写：/message</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Message</span><br>&#125;<br>]<br>&#125;<br>]<br></code></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><p>​router配置项（index.js）不需要声明参数名称及数据，由父组件给下级的路由子组件传递名称及数据</p><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带query参数，to的字符串写法  注意这里to没有v-bind value值当成字符串读取<br>字符串结构为： path+data&amp;data  其中？是分隔符  注意data数据是写死的  --&gt;<br>&lt;router-link to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;<br>&lt;!-- 跳转并携带query参数，to的模板字符串写法 注意这里to有v-bind value值当成js语句（字符串模板）解析<br>好处是可以引用变量 读取变量后转为常规的字符串解析--&gt;<br>&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;<br>&lt;router-link <br>:to=&quot;&#123;<br>path:&#x27;/home/message/detail&#x27;,<br>query:&#123;<br>   id:666,<br>            title:&#x27;你好&#x27;<br>&#125;<br>&#125;&quot;<br>&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/demo&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Demo</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;test&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Test</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br>                      <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">//给路由命名</span><br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;welcome&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Hello</span>,<br>&#125;<br>]<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--简化前，需要写完整的路径 --&gt;<br>&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!--简化后，直接通过名字跳转 --&gt;<br>&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!--简化写法配合传递参数 --&gt;<br>&lt;router-link <br>:to=&quot;&#123;<br>name:&#x27;hello&#x27;,<br>query:&#123;<br>   id:m.id,<br>            title:m.id.title,<br>&#125;<br>&#125;&quot;<br>&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol><li><p>配置路由(index.js)，声明接收params参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Message</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符声明接收params参数</span><br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span><br>&#125;<br>]<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;<br>&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;<br>&lt;!-- 跳转并携带params参数，to的模板字符串写法 --&gt;<br>&lt;router-link :to=&quot;/home/message/detail/$&#123;m.id&#125;/$&#123;m.value&#125;&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;<br>&lt;router-link <br>:to=&quot;&#123;<br>name:&#x27;xiangqing&#x27;,   &lt;!--此处不可以写path，必须用name--&gt;<br>params:&#123;<br>   id:666,<br>            title:&#x27;你好&#x27;<br>&#125;<br>&#125;&quot;<br>&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">params</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在router配置项（index.js）中写props参数，在路由父组件中写数据，在路由子组件中声明接收prop参数</span><br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><br><span class="hljs-comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span><br><span class="hljs-comment">// props:&#123;a:900&#125;</span><br><br><span class="hljs-comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span><br><span class="hljs-comment">// props:true</span><br><br><span class="hljs-comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span><br>        <br><span class="hljs-title function_">props</span>(<span class="hljs-params">$route</span>)&#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">id</span>:$route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>,<br><span class="hljs-attr">title</span>:$route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br>&#125;，<br>      <span class="hljs-comment">//结构赋值写法一</span><br>        <span class="hljs-title function_">props</span>(<span class="hljs-params">&#123;query&#125;</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">id</span>:query.<span class="hljs-property">id</span>,<span class="hljs-attr">title</span>:query.<span class="hljs-property">title</span>&#125;            <br>        &#125;,<br>       <span class="hljs-comment">//结构赋值写法二</span><br>        <span class="hljs-title function_">props</span>(<span class="hljs-params">&#123;query：&#123;id，title&#125;&#125;<span class="hljs-string">`)&#123;</span></span><br><span class="hljs-string"><span class="hljs-params">            return &#123;id,title&#125;            </span></span><br><span class="hljs-string"><span class="hljs-params">        &#125;</span></span><br><span class="hljs-string"><span class="hljs-params">&#125;</span></span><br><span class="hljs-string"><span class="hljs-params">&#125;</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params">//路由组件中接收参数</span></span><br><span class="hljs-string"><span class="hljs-params">props：[&#x27;id&#x27;,&#x27;title&#x27;],</span></span><br></code></pre></td></tr></table></figure><h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol><li><p>作用：在路由配置完成后，不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//$router的两个API</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,   <span class="hljs-comment">//这里的name来自于路由配置index.js</span><br><span class="hljs-attr">params</span>:&#123;<br><span class="hljs-attr">id</span>:xxx,<br><span class="hljs-attr">title</span>:xxx<br>&#125;<br>&#125;)<br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br><span class="hljs-attr">params</span>:&#123;<br><span class="hljs-attr">id</span>:xxx,<br><span class="hljs-attr">title</span>:xxx<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">forward</span>() <span class="hljs-comment">//前进</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">back</span>() <span class="hljs-comment">//后退</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>() <span class="hljs-comment">//可前进也可后退</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive ：include=&quot;[&#x27;News&#x27;,&#x27;About&#x27;]&quot;&gt;    //News、About是组件名，不是路由名称<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>&lt;/keep-alive&gt; <br>&lt;!--&lt;keep-alive&gt;&lt;/keep-alive&gt;不会解析到页面--&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li><li>注：失活不等于组件被销毁（destory），如果被缓存了（keep-alive），则失活时不会被销毁，如果没有缓存则先失活再销毁</li></ol></li></ol><h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：</p><ul><li>全局守卫<ul><li>全局前置：初始化时执行、每次路由切换前执行<ul><li>router.beforeEach(  （to,from,next)&#x3D;&gt;{…} ）</li><li>&#x2F;&#x2F;写在路由配置文件index.js中，routes:{..}之后</li></ul></li><li>后置前置：初始化时执行、每次路由切换后执行<ul><li>router.afterEach(   (to,from)&#x3D;&gt;{…}     ）</li><li>&#x2F;&#x2F;写在路由配置文件index.js中，routes:{..}之后</li></ul></li></ul></li></ul><ul><li>独享守卫    <ul><li>router.beforeEnter(   (to,from)&#x3D;&gt;{…}     ）</li><li>&#x2F;&#x2F;写在路由配置文件index.js中，routes:{..}对应的路由对象</li></ul></li><li>组件内守卫<ul><li>&#x2F;&#x2F;进入守卫：通过路由规则，进入该组件时被调用<br>beforeRouteEnter (to, from, next) {…}  </li><li>&#x2F;&#x2F;离开守卫：通过路由规则，离开该组件时被调用<br>beforeRouteLeave (to, from, next) {…} </li><li>通过路由规则 调用from的beforeRouteLeave 以及to的beforeRouteEnter </li><li>非路由规则进入（比如import引用 则不会触发）</li></ul></li></ul></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//to是即将指向前往的路由节点，from是上一个状态的路由节点</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeEach&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制   meta数据是开发者在路由配置项中自定义的数据</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;atguigu&#x27;</span>)&#123; <span class="hljs-comment">//权限控制的具体规则</span><br><span class="hljs-title function_">next</span>() <span class="hljs-comment">//放行</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;暂无权限查看&#x27;</span>)<br><span class="hljs-comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">next</span>() <span class="hljs-comment">//放行</span><br>&#125;<br>&#125;)<br><br><span class="hljs-comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;afterEach&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>)&#123; <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span> <span class="hljs-comment">//修改网页的title</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;vue_test&#x27;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeEnter</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeEnter&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;atguigu&#x27;</span>)&#123;<br><span class="hljs-title function_">next</span>()<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;暂无权限查看&#x27;</span>)<br><span class="hljs-comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">next</span>()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>组件内守卫（写在路由子组件）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//进入守卫：通过路由规则，进入该组件时被调用</span><br>beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>&#125;,<br><span class="hljs-comment">//离开守卫：通过路由规则，离开该组件时被调用</span><br>beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol><li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li><li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li><li>hash模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history模式：<ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol><h2 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element UI"></a>Element UI</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install element-ui<br> <span class="hljs-comment">//main.js文件中</span><br><span class="hljs-comment">//引入完整的elementUI组件库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-comment">//引入elementUI全部样式</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-按需引入"><a href="#2-按需引入" class="headerlink" title="2. 按需引入"></a>2. 按需引入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//首先，安装 babel-plugin-component：</span><br><br>npm install babel-plugin-component -D<br><br><span class="hljs-comment">//然后，将 babel.config.js 修改为：</span><br><br>&#123;<br>  <span class="hljs-attr">presets</span>: [<br>      [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123; <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span> &#125;]  <span class="hljs-comment">//这个可能已经有配置 注意合并即可</span><br>  ],<br>  <span class="hljs-attr">plugins</span>: [ <br>    [<br>      <span class="hljs-string">&quot;component&quot;</span>,<br>      &#123;  <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>      &#125;<br>    ] <br>  ]<br>&#125;<br><br><span class="hljs-comment">//在main.js  按需引入</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Button</span>，<span class="hljs-title class_">DatePicker</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">Button</span>.<span class="hljs-property">name</span>,<span class="hljs-title class_">Button</span>);   <span class="hljs-comment">//Button.name默认值就是el-button  支持重命名</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">DatePicker</span>.<span class="hljs-property">name</span>,<span class="hljs-title class_">DatePicker</span>);  <br><br><br></code></pre></td></tr></table></figure><p>2. </p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>Vue-cli</tag>
      
      <tag>Vuex</tag>
      
      <tag>Vue路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础入门</title>
    <link href="/2022/09/03/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/09/03/Vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础入门"><a href="#Vue基础入门" class="headerlink" title="Vue基础入门"></a>Vue基础入门</h1><h2 id="Vue模板语法"><a href="#Vue模板语法" class="headerlink" title="Vue模板语法"></a>Vue模板语法</h2><h3 id="1-插值语法："><a href="#1-插值语法：" class="headerlink" title="1.插值语法："></a>1.插值语法：</h3><p>​              功能：用于解析标签体内容。</p><p>​              写法：**<code>&#123;&#123;xxx&#125;&#125;</code>**，xxx是js表达式，且可以直接读取到data中的所有属性。</p><h3 id="2-指令语法："><a href="#2-指令语法：" class="headerlink" title="2.指令语法："></a>2.指令语法：</h3><p>​              功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</p><p>​              举例：<strong>v-bind:href&#x3D;”xxx”</strong> 或  简写为 :href&#x3D;”xxx”，xxx同样要写js表达式，相当于去掉引号当成js语句且可以直接读取到data中的所有属性。</p><p>​              备注：Vue中有很多的指令，且形式都是：v-????</p><h2 id="Vue中有2种数据绑定的方式："><a href="#Vue中有2种数据绑定的方式：" class="headerlink" title="Vue中有2种数据绑定的方式："></a>Vue中有2种数据绑定的方式：</h2><p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p><p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p><p>​            备注：</p><p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p><p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p><h2 id="data与el的2种写法"><a href="#data与el的2种写法" class="headerlink" title="data与el的2种写法"></a>data与el的2种写法</h2><p>​          1.el有2种写法</p><p>​                  (1).new Vue时候配置el属性。</p><p>​                  (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p><p>​          2.data有2种写法</p><p>​                  (1).对象式</p><p>​                  (2).函数式</p><p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p><p>​          3.一个重要的原则：</p><p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p><h2 id="mvvm模型"><a href="#mvvm模型" class="headerlink" title="mvvm模型"></a>mvvm模型</h2><p>​      MVVM模型</p><p>​            1. M：模型(Model) ：data中的数据</p><p>​            2. V：视图(View) ：模板代码</p><p>​            3. VM：视图模型(ViewModel)：Vue实例</p><p>​      观察发现：</p><p>​            1.data中所有的属性，最后都出现在了vm身上。</p><p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>Obejct.defineProperty(obj, prop, descriptor</strong>)</p><ul><li><p><strong>obj</strong>是我们要添加、修改属性的对象</p></li><li><p><strong>prop</strong>是我们要操作的属性名</p></li><li><p><strong>descriptor</strong>是我们操作属性的具体描述</p><ul><li><p><strong>configurable</strong>:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认值为false</p></li><li><p><strong>enumerable</strong>：表示能否通过for in循环访问属性，默认值为false</p></li><li><p><strong>writable</strong>：表示能否修改属性的值。默认值为false</p></li><li><p><strong>value</strong>：包含这个属性的数据值。默认值为undefined。</p></li><li><p><strong>get:function</strong>(){  retunrn xxx} 当有人读取prop属性时，get函数（getter）就会被调用并返回一个值   可以简写为get(){return}</p></li><li><p><strong>set:function</strong>(value){ retunrn xxx}  当有人修改prop属性时，set函数（setter）就会被调用并接收修改的具体值，简写set（value）{…}</p></li></ul></li></ul><h3 id="Vue中的数据代理："><a href="#Vue中的数据代理：" class="headerlink" title="Vue中的数据代理："></a>Vue中的数据代理：</h3><p>​         <strong>定义：</strong>通过vm对象来代理data对象中属性的操作（读&#x2F;写）</p><p>​         <strong>用处</strong>：  更加方便的操作data中的数据</p><p>​        <strong>基本原理：</strong></p><p>​              通过Object.defineProperty(…)把data对象中所有属性添加到vm上。</p><p>​              为每一个添加到vm上的属性，都指定一个getter&#x2F;setter。</p><p>​              在getter&#x2F;setter内部去操作（读&#x2F;写）data中对应的属性。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="事件的基本使用："><a href="#事件的基本使用：" class="headerlink" title="事件的基本使用："></a>事件的基本使用：</h3><p>​              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p><p>​              2.事件的回调需要配置在methods对象中，最终会在vm上；</p><p>​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p><p>​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p><p>​              5.@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参；</p><h3 id="Vue中的事件修饰符："><a href="#Vue中的事件修饰符：" class="headerlink" title="Vue中的事件修饰符："></a>Vue中的事件修饰符：</h3><p>​            1.prevent：阻止默认事件（常用）；</p><p>​            2.stop：阻止事件冒泡（常用）；</p><p>​            3.once：事件只触发一次（常用）；</p><p>​            4.capture：使用事件的捕获模式；</p><p>​            5.self：只有event.target是当前操作的元素时才触发事件；</p><p>​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>​        1.Vue中常用的按键别名：</p><p>​              回车 &#x3D;&gt; enter</p><p>​              删除 &#x3D;&gt; delete (捕获“删除”和“退格”键)</p><p>​              退出 &#x3D;&gt; esc</p><p>​              空格 &#x3D;&gt; space</p><p>​              换行 &#x3D;&gt; tab (特殊，必须配合keydown去使用 否则可能会触发失去焦点focus)</p><p>​              上 &#x3D;&gt; up</p><p>​              下 &#x3D;&gt; down</p><p>​              左 &#x3D;&gt; left</p><p>​              右 &#x3D;&gt; right</p><p>​        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p><p>​        3系统修饰键（用法特殊）：ctrl、alt、shift、meta</p><p>​              (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p><p>​              (2).配合keydown使用：正常触发事件。</p><p>​        4.也可以使用keyCode去指定具体的按键（不推荐）</p><p>​        5.Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名</p><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><h3 id="计算属性："><a href="#计算属性：" class="headerlink" title="计算属性："></a>计算属性：</h3><p>​          1.定义：要用的属性不存在，要通过已有属性计算得来。</p><p>​          2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p><p>​          3.get函数什么时候执行？</p><p>​                (1).初次读取时会执行一次。</p><p>​                (2).当依赖的数据发生改变时会被再次调用。</p><p>​          4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p><p>​          5.备注：</p><p>​              1.计算属性最终会出现在vm上，直接读取使用即可。</p><p>​              2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>:&#123;<br><span class="hljs-comment">//完整写法</span><br><span class="hljs-comment">/* fullName:&#123;</span><br><span class="hljs-comment">get()&#123;</span><br><span class="hljs-comment">console.log(&#x27;get被调用了&#x27;)</span><br><span class="hljs-comment">return this.firstName + &#x27;-&#x27; + this.lastName</span><br><span class="hljs-comment">&#125;,</span><br><span class="hljs-comment">set(value)&#123;</span><br><span class="hljs-comment">console.log(&#x27;set&#x27;,value)</span><br><span class="hljs-comment">const arr = value.split(&#x27;-&#x27;)</span><br><span class="hljs-comment">this.firstName = arr[0]</span><br><span class="hljs-comment">this.lastName = arr[1]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-comment">//简写</span><br><span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get被调用了&#x27;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//  备注：不考虑setter的时候可以写成回调函数</span><br></code></pre></td></tr></table></figure><h2 id="监视属性watch："><a href="#监视属性watch：" class="headerlink" title="监视属性watch："></a>监视属性watch：</h2><h3 id="监视属性watch：-1"><a href="#监视属性watch：-1" class="headerlink" title="监视属性watch："></a>监视属性watch：</h3><p>​          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p><p>​          2.监视的属性必须存在，才能进行监视！！</p><p>​          3.监视的两种写法：</p><p>​              (1).new Vue时传入watch配置</p><p>​              (2).通过vm.$watch监视</p><h3 id="深度监视："><a href="#深度监视：" class="headerlink" title="深度监视："></a>深度监视：</h3><p><strong>作用</strong>：</p><ul><li><p>监视多级结构中的某个属性的变化 ‘number.a’:{…}</p></li><li><p>监视多级结构中所有属性的变化  deep：true </p><ul><li><p>默认不开启 </p></li><li><p>number：{a:1;b&#x3D;2},如果只监视number且deep：false；则a，b变化也不会触发监视，因为监视的是number这个key，key对应的value值没有改变（引用空间还是那个配置对{…}）  除非给number赋值一个新的配置对如{xxx}才能监视成功</p></li></ul></li></ul><p><strong>总结</strong></p><p>​            (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p><p>​            (2).配置deep:true可以监测对象内部值改变（多层）。</p><p>​         备注：</p><p>​            (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</p><p>​            (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>:&#123;<br><span class="hljs-comment">//正常写法</span><br><span class="hljs-comment">/* isHot:&#123;</span><br><span class="hljs-comment">// immediate:true, //初始化时让handler调用一下</span><br><span class="hljs-comment">// deep:true,//深度监视</span><br><span class="hljs-comment">handler(newValue,oldValue)&#123;</span><br><span class="hljs-comment">console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;, */</span><br><span class="hljs-comment">//简写</span><br><span class="hljs-title function_">isHot</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue,<span class="hljs-variable language_">this</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//  备注：不考虑深度监视的时候可以简写为回调函数</span><br></code></pre></td></tr></table></figure><h2 id="computed和watch之间的区别："><a href="#computed和watch之间的区别：" class="headerlink" title="computed和watch之间的区别："></a>computed和watch之间的区别：</h2><ul><li>computed能实现的功能 watch也可以</li><li>watch能完成的功能 computed未必能实现 例如watch可以实现异步操作   computed本质是返回值 无法异步</li><li>所有被vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象</li><li>所有不被vue所管理的函数（定时器的回调函数，ajax的回调函数，promise的回调函数）最好写成箭头函数</li></ul><h2 id="绑定样式："><a href="#绑定样式：" class="headerlink" title="绑定样式："></a>绑定样式：</h2><h3 id="1-class样式"><a href="#1-class样式" class="headerlink" title="1. class样式"></a>1. class样式</h3><ul><li>字符串写法  v-bind:class&#x3D;’className’   <ul><li>注: className可存在data中，适用于样式类名不确定，个数是一个，需要动态指定</li></ul></li><li>数组写法 :class&#x3D;’classArr’    classArr&#x3D;[‘a’  ,  ‘b’ ,  ‘c’]<ul><li>注：classArr可存在data中，适用于要绑定的个数不确定，且名字也不确定，（数组元素可个数可以增减）数组元素是class类名的字符串写法，结合数组索引使用以及数组方法</li></ul></li><li>对象写法  :class&#x3D;’classObject’     classObject&#x3D;{a:true,b:false,c:true}<ul><li>适用于要绑定class的总个数及名字确定，但具体是否使用需要动态决定</li></ul></li></ul><h3 id="2-style样式"><a href="#2-style样式" class="headerlink" title="2. style样式"></a>2. style样式</h3><ul><li>v-bind:style&#x3D;’styleObject’     styleObject:{key:value}</li><li>主流写法，注意key值要准确写，两个单词以上的写法与css不同，不可以写-，比如background-color写成backgroundColor</li><li>也可以写成数组styleArr:[styleObject1,styleObject2]数组元素就是对象</li></ul><h2 id="条件渲染："><a href="#条件渲染：" class="headerlink" title="条件渲染："></a>条件渲染：</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>写法： (1).v-if&#x3D;”表达式” (2).v-else-if&#x3D;”表达式”(3).v-else&#x3D;”表达式”</p><p>特点：不展示的DOM元素直接被移除。重复切换会重复加载dom树）因此比较适合切换频率低的场景</p><p>适用于：切换频率较低的场景。</p><p>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>写法：v-show&#x3D;”表达式”，转换为布尔值的表达式即可，</p><p>本质：动态加载dom，不展示的dom被隐藏起来，（重复切换不会重复加载dom树）</p><p>适用于：切换频率较高的场景。</p><p>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p><h3 id="区别联系"><a href="#区别联系" class="headerlink" title="区别联系"></a>区别联系</h3><ul><li>高频切换用v-show，低频切换用v-if</li><li>v-if可以配合<code>&lt;template  v-if=&#39;xxxx&#39;&gt;....&lt;/template&gt;</code><ul><li>template意思是把包裹的代码形成一个代码块，类似于创建了一个透明的div，该div不会被解析到</li></ul></li><li>v-show 无法使用template</li><li>使用v-if元素可能无法获取（dom元素被移除了） 但使用v-show一定可以获取到</li></ul><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令:"></a>v-for指令:</h3><p>​    1.用于展示列表数据</p><p>​    2.语法：v-for&#x3D;”(item, index) in xxx” :key&#x3D;”yyy”</p><p>​    3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p><h2 id="key值的内部原理"><a href="#key值的内部原理" class="headerlink" title="key值的内部原理"></a>key值的内部原理</h2><h3 id="虚拟DOM中key的作用："><a href="#虚拟DOM中key的作用：" class="headerlink" title="虚拟DOM中key的作用："></a>虚拟DOM中key的作用：</h3><ul><li><p>key的内部原理</p><ul><li><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据新数据生成新的虚拟DOM，随后vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较</p></li><li><p>index作为key值的遍历过程中的diff算法</p></li></ul><p><img src="https://files.catbox.moe/g3wbbi.jpg"></p><ul><li><p>差异对比原则为：</p><ul><li><p>旧虚拟DOM中找到了与新虚拟DOM相同的key值</p><ul><li><p>若虚拟DOM内容没有变化，则直接使用原有的真实dom</p></li><li><p>若虚拟DOM内容改变，则改变部分重新生成新的DOM，虽随后替换原页面真实DOM</p></li></ul></li><li><p>旧虚拟DOM中未找到与新虚拟DOM相同的key值</p><ul><li>创建新的真实DOM，随后渲染到页面</li></ul></li></ul></li><li><p>用index作为key值可能引发的问题</p><ul><li><p>若对数据进行逆序添加、删除等破坏原有顺序操作，则会产生没有必要的真实dom更新，界面效果没问题，但是效率低（原因是index重新生成 与原有index对应的元素变化了）；若顺序添加或删除则部分真实dom无需更新</p></li><li><p>如果结构中还包含有输入类的dom则会产生错误的dom更新，</p></li></ul></li><li><p>key值选择</p><ul><li><p>最好使用每条数据的唯一标识作为key，如id、手机、身份证等</p></li><li><p>如果不存在对数据的逆序添加、删除等破坏顺序操作，仅用于渲染列表用于展示，则可以使用index</p></li></ul></li></ul></li></ul><h2 id="Vue监视数据的原理"><a href="#Vue监视数据的原理" class="headerlink" title="Vue监视数据的原理"></a>Vue监视数据的原理</h2><ol><li><p><strong>vue会监视data中所有层次的数据。</strong></p></li><li><p><strong>如何监测对象中的数据？</strong></p></li></ol><p>​通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><p>​(1).对象中后追加的属性，Vue默认不做响应式处理</p><p>​(2).如需给后添加的属性做响应式，请使用如下API：</p><p>​Vue.set(target，propertyName&#x2F;index，value) 或 </p><p>​vm.$set(target，propertyName&#x2F;index，value)</p><ol start="3"><li><strong>如何监测数组中的数据？</strong></li></ol><p>​通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>​(1).调用原生对应的方法对数组进行更新。</p><p>​(2).重新解析模板，进而更新页面。</p><p><strong>4.在Vue修改数组中的某个元素一定要用如下方法：</strong></p><p>​1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>​2.Vue.set() 或 vm.$set()</p><p>​特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p>  若：<code>&lt;input type=&quot;text&quot;/&gt;</code>，则v-model收集的是value值，用户输入的就是value值。</p><p>  若：<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则v-model收集的是value值，且要给标签配置value值。</p><p>  若：<code>&lt;input type=&quot;checkbox&quot;/&gt;</code></p><p>​      1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​      2.配置input的value属性:</p><p>​          (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​          (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p><p>  备注：v-model的三个修饰符：</p><p>​          lazy：失去焦点再收集数据</p><p>​          number：输入字符串转为有效的数字</p><p>​          trim：输入首尾空格过滤</p><h2 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h2><p>  定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p>  语法：</p><p>​      1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}&#96;</p><p>​      2.使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code>  或  v-bind:属性 &#x3D; “xxx | 过滤器名”</p><p>  备注：</p><p>​      1.过滤器也可以接收额外参数、多个过滤器也可以串联</p><p>​      2.并没有改变原本的数据, 是产生新的对应的数据</p><h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><h3 id="我们学过的指令："><a href="#我们学过的指令：" class="headerlink" title="我们学过的指令："></a>我们学过的指令：</h3><p>​    v-bind  : 单向绑定解析表达式, 可简写为 :xxx</p><p>​    v-model : 双向数据绑定</p><p>​    v-for  : 遍历数组&#x2F;对象&#x2F;字符串</p><p>​    v-on   : 绑定事件监听, 可简写为@</p><p>​    v-if     : 条件渲染（动态控制节点是否存存在）</p><p>​    v-else  : 条件渲染（动态控制节点是否存存在）</p><p>​    v-show  : 条件渲染 (动态控制节点是否展示)</p><h3 id="v-text指令："><a href="#v-text指令：" class="headerlink" title="v-text指令："></a>v-text指令：</h3><p>​    1.作用：向其所在的节点中渲染文本内容。</p><p>​    2.与插值语法的区别：v-text会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。</p><h3 id="v-html指令："><a href="#v-html指令：" class="headerlink" title="v-html指令："></a>v-html指令：</h3><p>​    1.作用：向指定节点中渲染包含html结构的内容。</p><p>​    2.与插值语法的区别：</p><p>​          (1).v-html会替换掉节点中所有的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。</p><p>​          (2).v-html可以识别html结构。</p><p>​    3.严重注意：v-html有安全性问题！！！！</p><p>​          (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p><p>​          (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p><h3 id="v-cloak指令（没有值）："><a href="#v-cloak指令（没有值）：" class="headerlink" title="v-cloak指令（没有值）："></a>v-cloak指令（没有值）：</h3><p>​    1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p><p>​    2.使用css配合v-cloak可以解决网速慢时页面展示出<code>&#123;&#123;xxx&#125;&#125;</code>的问题。</p><p>​css选择器写法 [v-cloak]{…}</p><h3 id="v-once指令："><a href="#v-once指令：" class="headerlink" title="v-once指令："></a>v-once指令：</h3><p>​      1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p><p>​      2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p><p>​ 3.与@click.once&#x3D;’….’的区别：前者是事件触发，只试行一次，v-once的节点也可包含插值语法等</p><h3 id="v-pre指令："><a href="#v-pre指令：" class="headerlink" title="v-pre指令："></a>v-pre指令：</h3><p>​          1.跳过其所在节点的编译过程。</p><p>​          2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>​        指令语法中调用采用     v-自定义指令名称   与常规指令语法用法一致 </p><ul><li><p>注：自定义指令名称不用驼峰命名法v-changeNumber，官方推荐写法kebab-case写法 比如v-change-number&#x3D;’ ‘</p><ul><li>由于存在短横线，因此在声明的时候需要将key值写成字符串，’change-numbe’（key值本身就是字符串，只是平时简写了）</li></ul><p>(1).局部指令：</p></li></ul><p>​                new Vue({                                                           new Vue({</p><p>​                  directives:{指令名:配置对象}  或                                directives{指令名:回调函数}</p><p>​                })                                                                                             })</p><p>​          (2).全局指令：</p><p>​                  Vue.directive(指令名,配置对象) 或  Vue.directive(指令名,回调函数)</p><p>this指向</p><p>​this指向windows，因此才能操作真实dom</p><h3 id="函数式声明"><a href="#函数式声明" class="headerlink" title="函数式声明"></a>函数式声明</h3><ul><li><p>new Vue({ directives:{   自定义指令名称（element，binding）{callback}  })</p></li><li><p>声明时默认传参element为指令所在节点的真实dom，binding为绑定的元素，可以通过binding.value获取绑定的变量的值</p></li><li><p>调用时机</p><ul><li><p>指令与元素成功绑定时会自调用一次</p></li><li><p>自定义指令所在模板被重新解析时会自调用（内置指令只有在需要动态渲染的时候才会重新加载）</p></li></ul><h3 id="对象式声明"><a href="#对象式声明" class="headerlink" title="对象式声明"></a>对象式声明</h3></li><li><p>new Vue({ directives:{   自定义指令名称:配置对象  })  &#x2F;&#x2F;根据调用时机不同执行不同的函数</p><ul><li>自定义指令名称: {</li><li>bind（element，binding){…}  ，   &#x2F;&#x2F;指令与元素成功绑定（首次）</li><li>inserted（element，binding){…}，     &#x2F;&#x2F;指令所在元素节点被成功插入页面</li><li>update（element，binding){…}     &#x2F;&#x2F;指令所在模板被重新解析</li><li>}</li></ul></li></ul><p>​    二、配置对象中常用的3个回调：</p><p>​          (1).bind：指令与元素成功绑定时调用。</p><p>​          (2).inserted：指令所在元素被插入页面时调用。</p><p>​          (3).update：指令所在模板结构被重新解析时调用。</p><p>​    三、备注：</p><p>​          1.指令定义时不加v-，但使用时要加v-；</p><p>​          2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br> &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;<br>    &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; --&gt;<br>&lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;<br>&lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;<br> &lt;/div&gt;<br><br>&lt;/template&gt;<br><br><br><br>&lt;script&gt;    <br>//定义全局指令v-fbind<br>Vue.directive(&#x27;fbind&#x27;,&#123;<br>//指令与元素成功绑定时（一上来）<br>bind(element,binding)&#123;<br>element.value = binding.value<br>&#125;,<br>//指令所在元素被插入页面时<br>inserted(element,binding)&#123;<br>element.focus()<br>&#125;,<br>//指令所在的模板被重新解析时<br>update(element,binding)&#123;<br>element.value = binding.value<br>&#125;<br>&#125;)<br><br>//定义局部指令v-big-number<br>directives:&#123;<br>    //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。<br>    &#x27;big-number&#x27;(element,binding)&#123;<br>                        // console.log(&#x27;big&#x27;)<br>                        element.innerText = binding.value * 10<br>                    &#125;, <br>                        <br>    big(element,binding)&#123;<br>        console.log(&#x27;big&#x27;,this) //注意此处的this是window<br>        // console.log(&#x27;big&#x27;)<br>        element.innerText = binding.value * 10<br>    &#125;,<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="基本定义："><a href="#基本定义：" class="headerlink" title="基本定义："></a>基本定义：</h3><p>​    1.又名：生命周期回调函数、生命周期函数、生命周期钩子。</p><p>​    2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p><p>​    3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>​    4.生命周期函数中的this指向是vm 或 组件实例对象。</p><h3 id="常用的生命周期钩子："><a href="#常用的生命周期钩子：" class="headerlink" title="常用的生命周期钩子："></a>常用的生命周期钩子：</h3><p>​    1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p><p>​    2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p><h3 id="关于销毁Vue实例"><a href="#关于销毁Vue实例" class="headerlink" title="关于销毁Vue实例"></a>关于销毁Vue实例</h3><p>​    1.销毁后借助Vue开发者工具看不到任何信息。</p><p>​    2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p><p>​    3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><ul><li><p>使用组件三大步骤</p><ul><li>定义组件（创建组件）→注册组件→使用组件（使用组件标签）</li></ul></li><li><p>定义组件</p><ul><li><p>使用Vue.extend(options)创建，其中options的写法与new Vue(options)时传入的options大致相同，但是需要特别注意以下内容：</p></li><li><p>el不可以写——创建好的组件最终会被一个vm管理即调用，由vm中的el值来指定创建的组件的服务对象，而且提前写死el值也无法实现组件复用</p></li><li><p>data必须写成函数——避免组件复用是，数据存在引用关系</p></li></ul></li><li><p>注册组件</p><ul><li><p>局部注册  new Vue时传入components选项</p></li><li><p>全局注册 Vue.component(‘组件名‘，组件)</p></li></ul></li><li><p>使用组件  </p><ul><li>使用注册时使用的组件名作为标签名          <code>  &lt;school&gt;&lt;/school&gt;</code></li></ul></li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>​    1.关于组件名:</p><p>​          一个单词组成：</p><p>​                第一种写法(首字母小写)：school</p><p>​                第二种写法(首字母大写)：School</p><p>​          多个单词组成：</p><p>​                第一种写法(kebab-case命名)：my-school</p><p>​                第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</p><p>​          备注：</p><p>​              (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p><p>​              (2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p><p>​    2.关于组件标签:</p><p>​          第一种写法：<school></school></p><p>​          第二种写法：<school/></p><p>​          备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。</p><p>​    3.一个简写方式：</p><p>​          const school &#x3D; Vue.extend(options) 可简写为：const school &#x3D; options</p><h3 id="关于VueComponent："><a href="#关于VueComponent：" class="headerlink" title="关于VueComponent："></a>关于VueComponent：</h3><p>​            1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p><p>​            2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，</p><p>​              即Vue帮我们执行的：new VueComponent(options)。</p><p>​            3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</p><p>​            4.关于this指向：</p><p>​                (1).组件配置中：</p><p>​                      data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</p><p>​                (2).new Vue(options)配置中：</p><p>​                      data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p><p>​            5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。</p><p>​              Vue的实例对象，以后简称vm。</p><p>​        1.一个重要的内置关系：VueComponent.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Vue.prototype</p><p>​        2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.Properties</title>
    <link href="/2022/09/03/Object-Properties/"/>
    <url>/2022/09/03/Object-Properties/</url>
    
    <content type="html"><![CDATA[<h1 id="属性标识与属性描述符"><a href="#属性标识与属性描述符" class="headerlink" title="属性标识与属性描述符"></a>属性标识与属性描述符</h1><p>对象可以存储属性，对象的属性不仅仅只是简单的“键值”对。</p><h2 id="属性标识"><a href="#属性标识" class="headerlink" title="属性标识"></a>属性标识</h2><p>对象属性（properties），除 <strong><code>value</code></strong> 外，还有三个特殊的特性（attributes），也就是所谓的“标志”：</p><ul><li><strong><code>writable</code></strong> — 如果为 <code>true</code>，则值可以被修改，否则它是只可读的。</li><li><strong><code>enumerable</code></strong> — 如果为 <code>true</code>，则会被在循环中列出，否则不会被列出。</li><li><strong><code>configurable</code></strong> — 如果为 <code>true</code>，则此特性可以被删除，这些属性也可以被修改，否则不可以。</li></ul><p>当我们用“常用的方式”创建一个属性时，它们都为 <code>true</code>，但我们也可以随时更改它们。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a> 方法允许查询有关属性的 <strong>完整</strong> 信息。</p><blockquote><p>语法：</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> descriptor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptor(<span class="hljs-params">obj</span>, <span class="hljs-params">propertyName</span>)</span>;<br>Copy<br></code></pre></td></tr></table></figure><ul><li><p>obj</p><p>需要从中获取信息的对象</p></li><li><p>propertyName</p><p>属性的名称</p></li></ul><blockquote><p>举例</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let <span class="hljs-keyword">user</span>=&#123;<br>    <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;John&#x27;</span><br>&#125;<br>let descriptor=<span class="hljs-keyword">Object</span>.getOwnPropertyDescriptor(<span class="hljs-keyword">user</span>,<span class="hljs-string">&#x27;name&#x27;</span>);<br>console.log(descriptor);<br>// &#123; <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;John&#x27;</span>, writable: <span class="hljs-keyword">true</span>, enumerable: <span class="hljs-keyword">true</span>, configurable: <span class="hljs-keyword">true</span> &#125;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>为了修改标志，我们可以使用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>。</p><blockquote><p>语法</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">obj</span>, <span class="hljs-params">propertyName</span>, <span class="hljs-params">descriptor</span>)</span><br>Copy<br></code></pre></td></tr></table></figure><ul><li><p><code>obj</code>，<code>propertyName</code></p><p>要应用描述符的对象及其属性。</p></li><li><p><code>descriptor</code></p><p>要应用的属性描述符对象。</p></li></ul><p>如果<code>descriptor</code>属性存在，<code>defineProperty</code> 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 <code>false</code>。</p><p>例如，这里创建了一个属性 <code>name</code>，该属性的所有标志都为 <code>false</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> user = &#123;&#125;;<br><br>Object.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  value: <span class="hljs-string">&quot;John&quot;</span><br>&#125;);<br><br><span class="hljs-built_in">let</span> descriptor = Object.getOwnPropertyDescriptor(user, <span class="hljs-string">&#x27;name&#x27;</span>);<br><br>alert( JSON.stringify(descriptor, null, 2 ) );<br>/*<br>&#123;<br>  <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-string">&quot;writable&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;enumerable&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;configurable&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br> */<br>Copy<br></code></pre></td></tr></table></figure><p>将它与上面的“以常用方式创建的” <code>user.name</code> 进行比较：现在所有标志都为 <code>false</code>。如果这不是我们想要的，那么我们最好在 <code>descriptor</code> 中将它们设置为 <code>true</code>。</p><h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><p>通过更改 <code>writable</code> 标志来把 <code>user.name</code> 设置为只读（<code>user.name</code> 不能被重新赋值）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let <span class="hljs-keyword">user</span> = &#123;<br>  <span class="hljs-type">name</span>: &quot;John&quot;<br>&#125;;<br><br><span class="hljs-keyword">Object</span>.defineProperty(<span class="hljs-keyword">user</span>, &quot;name&quot;, &#123;<br>  writable: <span class="hljs-keyword">false</span><br>&#125;);<br><br><span class="hljs-keyword">user</span>.name = &quot;Pete&quot;; // Error: Cannot assign <span class="hljs-keyword">to</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">only</span> property <span class="hljs-string">&#x27;name&#x27;</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>只在严格模式下会出现 Errors</strong></p></blockquote><h2 id="不可枚举"><a href="#不可枚举" class="headerlink" title="不可枚举"></a>不可枚举</h2><p>如果在 <code>user</code>中 添加一个自定义的 <code>toString</code>。</p><p>通常，对象的内置 <code>toString</code> 是不可枚举的，它不会显示在 <code>for..in</code> 中。但是如果我们添加我们自己的 <code>toString</code>，那么默认情况下它将显示在 <code>for..in</code> 中，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 默认情况下，我们的两个属性都会被列出：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) <span class="hljs-title function_">alert</span>(key); <span class="hljs-comment">// name, toString</span><br><span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><p>如果我们不喜欢它，那么我们可以设置 <code>enumerable:false</code>。之后它就不会出现在 <code>for..in</code> 循环中了，就像内建的 <code>toString</code> 一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user, <span class="hljs-string">&quot;toString&quot;</span>, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-comment">// 现在我们的 toString 消失了：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) <span class="hljs-title function_">alert</span>(key); <span class="hljs-comment">// name</span><br><span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><h2 id="不可配置"><a href="#不可配置" class="headerlink" title="不可配置"></a>不可配置</h2><p>不可配置标志（<code>configurable:false</code>）有时会预设在内建对象和属性中。不可配置的属性不能被删除。</p><p>因此，开发人员无法修改 <code>Math.PI</code> 的值或覆盖它。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">Math.PI = <span class="hljs-number">3</span>; <span class="hljs-regexp">//</span> Error<br><br><span class="hljs-regexp">//</span> 删除 Math.PI 也不会起作用<br>Copy<br></code></pre></td></tr></table></figure><p>使属性变成不可配置是一条单行道。我们无法使用 <code>defineProperty</code> 把它改回去。</p><p>确切地说，不可配置性对 <code>defineProperty</code> 施加了一些限制：</p><ol><li>不能修改 <code>configurable</code> 标志。</li><li>不能修改 <code>enumerable</code> 标志。</li><li>不能将 <code>writable: false</code> 修改为 <code>true</code>（反过来则可以）。</li><li>不能修改访问者属性的 <code>get/set</code>（但是如果没有可以分配它们）。</li></ol><hr><p><strong>“configurable: false” 的用途是防止更改和删除属性标志，但是允许更改对象的值。</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let <span class="hljs-keyword">user</span> = &#123;<br>  <span class="hljs-type">name</span>: &quot;John&quot;<br>&#125;;<br><br><span class="hljs-keyword">Object</span>.defineProperty(<span class="hljs-keyword">user</span>, &quot;name&quot;, &#123;<br>  configurable: <span class="hljs-keyword">false</span><br>&#125;);<br><br><span class="hljs-keyword">user</span>.name = &quot;Pete&quot;; // 正常工作<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">user</span>.name; // Error<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>现在，我们将 <code>user.name</code> 设置为一个“永不可改”的常量：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let <span class="hljs-keyword">user</span> = &#123;<br>  <span class="hljs-type">name</span>: &quot;John&quot;<br>&#125;;<br><br><span class="hljs-keyword">Object</span>.defineProperty(<span class="hljs-keyword">user</span>, &quot;name&quot;, &#123;<br>  writable: <span class="hljs-keyword">false</span>,<br>  configurable: <span class="hljs-keyword">false</span><br>&#125;);<br><br>// 不能修改 <span class="hljs-keyword">user</span>.name 或它的标志<br>// 下面的所有操作都不起作用：<br><span class="hljs-keyword">user</span>.name = &quot;Pete&quot;;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">user</span>.name;<br><span class="hljs-keyword">Object</span>.defineProperty(<span class="hljs-keyword">user</span>, &quot;name&quot;, &#123; <span class="hljs-keyword">value</span>: &quot;Pete&quot; &#125;);<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h2 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a><a href="https://zh.javascript.info/property-descriptors#objectdefineproperties">Object.defineProperties</a></h2><p>有一个方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties(obj, descriptors)</a>，允许一次定义多个属性。</p><blockquote><p>语法</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">Object.defineProperties(obj, <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  prop1:</span> descriptor1,<br><span class="hljs-symbol">  prop2:</span> descriptor2<br>  <span class="hljs-comment">// ...</span><br><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">;</span><br>Copy<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">Object.<span class="hljs-title function_ invoke__">defineProperties</span>(user, &#123;<br>  <span class="hljs-attr">name</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> &#125;,<br>  <span class="hljs-attr">surname</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> &#125;,<br>  // ...<br>&#125;);<br>Copy<br></code></pre></td></tr></table></figure><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a><a href="https://zh.javascript.info/property-descriptors#objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors</a></h2><p>要一次获取所有属性描述符，我们可以使用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors(obj)</a> 方法。</p><p>它与 <code>Object.defineProperties</code> 一起可以用作克隆对象的“标志感知”方式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> clone = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Properties(&#123;&#125;, Object.<span class="hljs-params">getOwnPropertyDescriptors</span>(<span class="hljs-params">obj</span>)</span>);<br><br>Copy<br></code></pre></td></tr></table></figure><p>通常，当我们克隆一个对象时，我们使用赋值的方式来复制属性，像这样：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> user) &#123;<br>  clone[<span class="hljs-built_in">key</span>] = user[<span class="hljs-built_in">key</span>]<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>……但是，这并不能复制标志。所以如果我们想要一个“更好”的克隆，那么 <code>Object.defineProperties</code> 是首选。</p><p>另一个区别是 <code>for..in</code> 会忽略 symbol 类型的属性，但是 <code>Object.getOwnPropertyDescriptors</code> 返回包含 symbol 类型的属性在内的 <strong>所有</strong> 属性描述符。</p><h1 id="属性的getter和setter"><a href="#属性的getter和setter" class="headerlink" title="属性的getter和setter"></a>属性的getter和setter</h1><p>有两种类型的对象属性。</p><p>第一种是 <strong>数据属性</strong>。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。</p><p>第二种类型的属性是新东西。它是 <strong>访问器属性（accessor properties）</strong>。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p><h2 id="访问器属性-getter和setter"><a href="#访问器属性-getter和setter" class="headerlink" title="访问器属性(getter和setter)"></a>访问器属性(getter和setter)</h2><p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 <code>get</code> 和 <code>set</code> 表示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">propName</span>()</span> &#123;<br>    <span class="hljs-comment">// 当读取 obj.propName 时，getter 起作用</span><br>  &#125;,<br><br>  <span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">propName</span>(<span class="hljs-params"><span class="hljs-keyword">value</span></span>)</span> &#123;<br>    <span class="hljs-comment">// 当执行 obj.propName = value 操作时，setter 起作用</span><br>  &#125;<br>&#125;;<br>Copy<br></code></pre></td></tr></table></figure><p>当读取 <code>obj.propName</code> 时，getter 起作用，当 <code>obj.propName</code> 被赋值时，setter 起作用。</p><p>例如，我们有一个具有 <code>name</code> 和 <code>surname</code> 属性的对象 <code>user</code>：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">let <span class="hljs-keyword">user</span> <span class="hljs-title">= &#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  surname: <span class="hljs-string">&quot;Smith&quot;</span><br>&#125;;<br>Copy<br></code></pre></td></tr></table></figure><p>现在我们想添加一个 <code>fullName</code> 属性，该属性值应该为 <code>&quot;John Smith&quot;</code>。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>,<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.surname&#125;</span>`</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">fullName</span>); <span class="hljs-comment">// John Smith</span><br><span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 <strong>调用</strong> <code>user.fullName</code>，我们正常 <strong>读取</strong> 它：getter 在幕后运行。</p><p>截至目前，<code>fullName</code> 只有一个 getter。如果我们尝试赋值操作 <code>user.fullName=</code>，将会出现错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`...`</span>;<br>  &#125;<br>&#125;;<br><br>user.<span class="hljs-property">fullName</span> = <span class="hljs-string">&quot;Test&quot;</span>; <span class="hljs-comment">// Error（属性只有一个 getter）</span><br><span class="hljs-title class_">Copy</span><br><span class="hljs-keyword">let</span> user=&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">surname</span>:<span class="hljs-string">&#x27;Smith&#x27;</span>,<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullname</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.surname&#125;</span>`</span>;<br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullname</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-comment">// 将获取的值解构赋值给对象的name和surname属性</span><br>        [<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>]=value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;<br><br>user.<span class="hljs-property">fullname</span>=<span class="hljs-string">&#x27;alice cooper&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">fullname</span>);<br><span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><h2 id="访问器描述符"><a href="#访问器描述符" class="headerlink" title="访问器描述符"></a>访问器描述符</h2><p>访问器属性的描述符与数据属性的不同。</p><p>所以访问器描述符可能有：</p><ul><li><strong><code>get</code></strong> —— 一个没有参数的函数，在读取属性时工作，</li><li><strong><code>set</code></strong> —— 带有一个参数的函数，当属性被设置时调用，</li><li><strong><code>enumerable</code></strong> —— 与数据属性的相同，</li><li><strong><code>configurable</code></strong> —— 与数据属性的相同。</li></ul><p>例如，要使用 <code>defineProperty</code> 创建一个 <code>fullName</code> 访问器，我们可以使用 <code>get</code> 和 <code>set</code> 来传递描述符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user, <span class="hljs-string">&#x27;fullName&#x27;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.surname&#125;</span>`</span>;<br>  &#125;,<br><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;<br>    [<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>] = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">fullName</span>); <span class="hljs-comment">// John Smith</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) <span class="hljs-title function_">alert</span>(key); <span class="hljs-comment">// name, surname</span><br><span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><p><strong>请注意，一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是。</strong></p><p>如果我们试图在同一个描述符中同时提供 <code>get</code> 和 <code>value</code>，则会出现错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Error: Invalid property descriptor.</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(&#123;&#125;, <span class="hljs-string">&#x27;prop&#x27;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  &#125;,<br><br>  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span><br>&#125;);<br><span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><h2 id="更聪明的getter-x2F-setter"><a href="#更聪明的getter-x2F-setter" class="headerlink" title="更聪明的getter&#x2F;setter"></a>更聪明的getter&#x2F;setter</h2><p>Getter&#x2F;setter 可以用作“真实”属性值的包装器，以便对它们进行更多的控制。</p><p>例如，如果我们想禁止太短的 <code>user</code> 的 name，我们可以创建一个 setter <code>name</code>，并将值存储在一个单独的属性 <code>_name</code> 中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let <span class="hljs-keyword">user</span> = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-type">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> this._name;<br>  &#125;,<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-type">name</span>(<span class="hljs-keyword">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span>.length &lt; <span class="hljs-number">4</span>) &#123;<br>      alert(&quot;Name is too short, need at least 4 characters&quot;);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    this._name = <span class="hljs-keyword">value</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">user</span>.name = &quot;Pete&quot;;<br>alert(<span class="hljs-keyword">user</span>.name); // Pete<br><br><span class="hljs-keyword">user</span>.name = &quot;&quot;; // <span class="hljs-type">Name</span> 太短了……<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>所以，name 被存储在 <code>_name</code> 属性中，并通过 getter 和 setter 进行访问。</p><p>从技术上讲，外部代码可以使用 <code>user._name</code> 直接访问 name。但是，这儿有一个众所周知的约定，即以下划线 <code>&quot;_&quot;</code> 开头的属性是内部属性，不应该从对象外部进行访问。</p><p>本笔记基于 <a herf='https://jiaqicoder.com/2021/07/27/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7/'>修改</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object.Properties</tag>
      
      <tag>对象属性</tag>
      
      <tag>属性标识</tag>
      
      <tag>属性表描述符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记(ES6-ES10)</title>
    <link href="/2022/09/02/JavaScript%E7%AC%94%E8%AE%B0-ES6-ES10/"/>
    <url>/2022/09/02/JavaScript%E7%AC%94%E8%AE%B0-ES6-ES10/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript笔记（ES6-ES10"><a href="#JavaScript笔记（ES6-ES10" class="headerlink" title="JavaScript笔记（ES6-ES10)"></a>JavaScript笔记（ES6-ES10)</h1><h2 id="1-ES6-2015"><a href="#1-ES6-2015" class="headerlink" title="1.ES6(2015)"></a>1.ES6(2015)</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> 声明的全局变量不是不是全局对象的属性<br>不可以通过 <span class="hljs-variable language_">window</span>.变量名 的方式访问这些变量，而 <span class="hljs-keyword">var</span> 声明的全局变量是 <span class="hljs-variable language_">window</span> 的属性，是可以通过 <span class="hljs-variable language_">window</span>.变量名 的方式访的。<br><span class="hljs-keyword">let</span>声明的变量具有块级作用域<br><span class="hljs-keyword">let</span>变量不会进行变量提升，重定义<span class="hljs-keyword">let</span>变量会抛出错误<br></code></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JS">数组遍历方法：<br>+ <span class="hljs-keyword">for</span>循环<br>+ <span class="hljs-title class_">Arr</span>.<span class="hljs-title function_">forEach</span>(callback):不支持<span class="hljs-keyword">break</span> <span class="hljs-keyword">continue</span><br>+ <span class="hljs-title class_">Arr</span>.<span class="hljs-title function_">every</span>(callback): 循环是否进行取决于返回值，默认返回值为<span class="hljs-literal">false</span>，也就是执行一次，也不直接支持<span class="hljs-keyword">break</span>/<span class="hljs-keyword">continue</span>，可以通过<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>来在<span class="hljs-keyword">if</span>语句中跳过或停止<br>+ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> obj <span class="hljs-keyword">in</span> object) &#123;....&#125;  遍历对象中的全部元素  数组也是对象的一种 <br> <span class="hljs-comment">//arr=[1,2,3]  arr.a=8,for in 去遍历arr对象的话会得到1 2 3 8</span><br>+ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> <span class="hljs-title class_">Arr</span>) &#123;....&#125;    遍历纯数组的时候  index是个字符串 不是数字型，   对应的值要用<span class="hljs-title class_">Arr</span>[index]获取<br>  index= = = <span class="hljs-number">1</span> 会<span class="hljs-literal">false</span>；index= = <span class="hljs-number">1</span>则<span class="hljs-literal">true</span>；index*<span class="hljs-number">1</span> = = = <span class="hljs-number">5</span><br>+ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> <span class="hljs-title class_">Arr</span>) &#123;....&#125;    <br><br><span class="hljs-comment">//伪数组</span><br>具有索引及对应的值；具有length<br><br><span class="hljs-comment">//伪数组转换为数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike,mapFn,thisArg)<br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123;<span class="hljs-attr">length</span>:<span class="hljs-number">5</span>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;rerurn <span class="hljs-number">1</span>&#125;)   <span class="hljs-comment">//初始化并赋值数组[1,1,1,1,1]</span><br><br><span class="hljs-comment">//生成新数组</span><br><span class="hljs-keyword">let</span> arr1=<span class="hljs-title class_">Array</span>（<span class="hljs-number">5</span>）   <span class="hljs-keyword">let</span> arr2[]    <span class="hljs-keyword">let</span> arr3= <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>)<br><br>+ <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">fill</span>(value.<span class="hljs-property">start</span>,end)<br><span class="hljs-keyword">let</span> arr4=<span class="hljs-title class_">Array</span>（<span class="hljs-number">5</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">7</span>)    <span class="hljs-comment">//[7,7,7,7,7]</span><br><span class="hljs-keyword">let</span> arr5=arr4.<span class="hljs-title function_">fill</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)    <span class="hljs-comment">//[7,7,6,6,7]</span><br><span class="hljs-keyword">let</span> array6 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>)   <span class="hljs-comment">//[1,3,5,7,9]</span><br><br><span class="hljs-comment">//查找数组元素</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property">filter</span>（ callback ）   返回符合条件的数组元素的一个新数组 对原数组不修改  callback中<span class="hljs-keyword">return</span>为<span class="hljs-literal">true</span>即为符合条件<br><span class="hljs-title class_">Array</span>.<span class="hljs-property">find</span>（ callback ）   返回符合条件的第一个数组元素的值 对原数组不修改  <br><span class="hljs-title class_">Array</span>.<span class="hljs-property">findIndex</span>（ callback ）   返回符合条件的第一个数组元素的索引 对原数组不修改  <br><span class="hljs-title class_">Array</span>.<span class="hljs-property">sort</span>（ callback ）   对数组元素进行排序 对原数字进修修改<br><br></code></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">------<span class="hljs-keyword">for</span> <span class="hljs-keyword">in</span><br>    <br><span class="hljs-comment">//for in 循环数组</span><br>    <span class="hljs-keyword">var</span> obj = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">85</span>]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); &#125;<span class="hljs-comment">//key的值即为索引值</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[key]);<span class="hljs-comment">//obj[key]的值为索引对应的内部值</span><br><span class="hljs-comment">//for in   循环对象</span><br><br> <span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot; = &quot;</span> + obj[key]);<br>  &#125;<br><span class="hljs-comment">//输出为a=1;b=2;c=3</span><br><br><span class="hljs-comment">//foreach 循环数组</span><br> <span class="hljs-keyword">let</span> list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,index,arr</span>)=&gt;</span>&#123;    <br>    <span class="hljs-comment">//每次循环的每一个元素，当前元素索引，数组本身</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value,index,arr);<br>&#125;)<br><br><span class="hljs-comment">//for of循环</span><br><span class="hljs-keyword">var</span> obj = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">85</span>]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);&#125;<br> <span class="hljs-comment">//输出1,5,2,3,85 </span><br><span class="hljs-comment">//通过这种方式得到的value是值而不是索引值</span><br>注：其实<span class="hljs-keyword">for</span> <span class="hljs-keyword">of</span>它的本质是迭代器，不可以在没有symbol.<span class="hljs-property">iterator</span> 这个属性的对象上使用，比如对象<br></code></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//-----------------------------------ES5----------------------------------------</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = type<br>    &#125;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">walk</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am walking`</span>)<br>    &#125;<br>    <span class="hljs-keyword">let</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;dog&#x27;</span>)<br>    <span class="hljs-keyword">let</span> monkey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;monkey&#x27;</span>)<br><br><span class="hljs-comment">//类的方法继承--ES5</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Dog</span>  = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//初始化父类的构造函数</span><br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;dog&#x27;</span>)<span class="hljs-comment">//改变this的指针指向为dog的实例对象</span><br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><span class="hljs-comment">//引用类型  这样子可以访问到父类的方法</span><br><br><br><br><span class="hljs-comment">//-----------------------------------ES6----------------------------------------</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-title function_">constructor</span> (type) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = type<br>        &#125;<br>        walk () &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am walking`</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;dog&#x27;</span>)<br>    <span class="hljs-keyword">let</span> monkey = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;monkey&#x27;</span>)<br><br><br><span class="hljs-comment">//类的方法继承--ES6</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>      <span class="hljs-comment">// 显式 需要新增</span><br>      <span class="hljs-title function_">constructor</span> (type) &#123;<br>        <span class="hljs-variable language_">super</span>(type)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">2</span><br>      &#125;<br>    <span class="hljs-comment">//隐式即不需要新增</span><br>    <span class="hljs-comment">//默认执行  constructor (type) &#123; super(type)&#125;</span><br>     <br><br><br>属性<br><span class="hljs-comment">//类的实例对象可以访问到类的原型链上的方法</span><br><span class="hljs-comment">//类的静态方法只能通过属性调用</span><br><span class="hljs-comment">//getter  setter</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-keyword">class</span>类的继承<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br>            <span class="hljs-comment">//构造方法</span><br>            <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand, price</span>)&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;<br>            &#125;<br>            <span class="hljs-comment">//父类的成员属性</span><br>            <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我可以打电话!!&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Phone</span> &#123;<br>            <span class="hljs-comment">//构造方法</span><br>            <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brand, price, color, size</span>)&#123;<br>                <span class="hljs-variable language_">super</span>(brand, price);<span class="hljs-comment">// Phone.call(this, brand, price)</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = size;<br>            &#125;<br><br>            <span class="hljs-title function_">photo</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;拍照&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-title function_">playGame</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;玩游戏&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我可以进行视频通话&#x27;</span>);  <span class="hljs-comment">//子类对父类方法的重写</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> xiaomi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmartPhone</span>(<span class="hljs-string">&#x27;小米&#x27;</span>,<span class="hljs-number">799</span>,<span class="hljs-string">&#x27;黑色&#x27;</span>,<span class="hljs-string">&#x27;4.7inch&#x27;</span>);<br>        <span class="hljs-comment">// console.log(xiaomi);</span><br>        xiaomi.<span class="hljs-title function_">call</span>();   <span class="hljs-comment">//&#x27;我可以进行视频通话&#x27;</span><br>        xiaomi.<span class="hljs-title function_">photo</span>();<br>        xiaomi.<span class="hljs-title function_">playGame</span>();<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"> <br><br></code></pre></td></tr></table></figure><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JS">默认值<br><span class="hljs-comment">//---------------ES5--------------</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span> (x, y, z) &#123;<br>    <span class="hljs-keyword">if</span> (y === <span class="hljs-literal">undefined</span>)<br>    y = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">if</span> (z === <span class="hljs-literal">undefined</span>)<br>    z = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">return</span> x + y + z;<br>    &#125;;<br>    <span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>) === <span class="hljs-number">50</span>;<br><span class="hljs-comment">//---------------ES5</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span> (x, y = <span class="hljs-number">7</span>, z = <span class="hljs-number">42</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y + z<br>    &#125;<br>    <span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>) === <span class="hljs-number">50</span><br><span class="hljs-comment">//如果不想使用默认值，可以使用undefined</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span> (x, y = <span class="hljs-number">7</span>, z = <span class="hljs-number">42</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y + z<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">43</span>))<span class="hljs-comment">// 51</span><br><br><br>+ <span class="hljs-variable language_">arguments</span><br><span class="hljs-comment">//在函数体内，有时候需要判断函数有几个参数，一共有2个办法。在 ES5 中可以在函数体内使用 arguments 来判断。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> (a, b = <span class="hljs-number">1</span>, c) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>)<br>    &#125;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<span class="hljs-comment">//2</span><br><br><span class="hljs-comment">// 然而在 ES6 中不能再使用 arguments 来判断了，但可以借助 Function.length 来判断。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> (a, b = <span class="hljs-number">1</span>, c) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-property">length</span>)<br>    &#125;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<span class="hljs-comment">// 1</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property">length</span> 结果和 <span class="hljs-variable language_">arguments</span> 的结果不同！没错，<span class="hljs-title class_">Function</span>.<span class="hljs-property">length</span> 是统计第一个默认参数前面的变量数：<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">不确定参数的方法 <br><br>+ <span class="hljs-title class_">Rest</span> parameter<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (base, ...nums) &#123;    <span class="hljs-comment">//也可以只写...nums 视开发需求而定</span><br>      <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span><br>      nums.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>        num += item * <span class="hljs-number">1</span><br>      &#125;)<br>      <span class="hljs-keyword">return</span> base * <span class="hljs-number">2</span> + num<br>    &#125;<br><br>+spread<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>, z = <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">return</span> x + y + z<br>    &#125;<br>    <span class="hljs-keyword">let</span> data = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>]<br>    <span class="hljs-comment">// console.log(sum(data[0], data[1], data[2]))</span><br>    <span class="hljs-comment">// console.log(sum.apply(this, data))</span><br>    <span class="hljs-title function_">sum</span>(...data)<br></code></pre></td></tr></table></figure><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs JS">在 <span class="hljs-title class_">ES6</span> 之前 <span class="hljs-title class_">Object</span> 的 key 在定义时必须是字符串，<br>如果想增加“动态”的 key，必须是先计算出 key，<br>利用 object[key] = value 的方式来修改；<br>在 <span class="hljs-title class_">ES6</span> 之后可以直接用变量或者表达式来定义 key。<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    [<span class="hljs-string">&#x27;baz&#x27;</span>+ <span class="hljs-title function_">quux</span>()]: <span class="hljs-number">42</span>   <span class="hljs-comment">//obj[&#x27;baz&#x27; + quux()] = 42</span><br>    &#125;<br>    <br>从 <span class="hljs-title class_">ES6</span> 开始对象内的方法可以简写，包括常规函数和异步函数。<br><span class="hljs-comment">//ES5 时代 Object 的属性只支持常规函数，对于异步函数是不支持的</span><br><br>+ 属性<br>   <span class="hljs-title class_">Object</span>.<span class="hljs-property">length</span>值为<span class="hljs-number">1</span>。<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>可以为所有 <span class="hljs-title class_">Object</span> 类型的对象添加属性。<br>+ 方法<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, ...sources)<br><span class="hljs-comment">//通过复制一个或多个对象来创建一个新的对象。</span><br><span class="hljs-comment">//如果目标对象与源对象具有相同的 key，则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的属性。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto，<span class="hljs-title function_">propertiesObject</span>(可选))<br><span class="hljs-comment">//使用指定的原型对象和属性创建一个新对象。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, prop, descriptor)<br><span class="hljs-comment">//给对象添加一个属性并指定该属性的配置。</span><br><span class="hljs-comment">//descriptor 要定义或修改的属性描述符。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, props)<br><span class="hljs-comment">// 给对象添加多个属性并分别指定它们的配置。</span><br><span class="hljs-comment">//对象中存在的属性描述符主要有两种：数据描述符和访问器描述符</span><br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj, &#123;<br>          <span class="hljs-string">&#x27;property1&#x27;</span>: &#123;<br>            <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span><br>          &#125;,<br>          <span class="hljs-string">&#x27;property2&#x27;</span>: &#123;<br>            <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>            <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span><br>          &#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)<br><span class="hljs-comment">//返回给定对象自身可枚举属性的[key, value]数组。//一级属性</span><br><span class="hljs-comment">//new Map() 构造函数接受一个可迭代的entries。</span><br><span class="hljs-comment">//借助Object.entries方法你可以很容易的将Object转换为Map:</span><br>    <span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br>    <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj));<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map); <span class="hljs-comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(iterable)<br><span class="hljs-comment">// 把键值对列表转换为一个对象。</span><br><span class="hljs-comment">//iterable  类似 Array 、 Map 或者其它实现了可迭代协议的可迭代对象。</span><br>    <span class="hljs-comment">//Map 转化为 Object</span><br>        <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([ [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>], [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">42</span>] ]);<br>        <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br>    <span class="hljs-comment">//Array 转化为 Object</span><br>        <span class="hljs-keyword">const</span> arr = [ [<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>] ];<br>        <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(arr);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125; </span><br><br><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj)<br><span class="hljs-comment">//冻结对象：其他代码不能删除或更改任何属性。</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, prop)<br><span class="hljs-comment">//返回对象指定的属性配置。如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</span><br><span class="hljs-comment">//属性配置  value/writeable/get/set/configurable</span><br><span class="hljs-comment">//Object.getOwnPropertyDescriptors(obj) 方法用来获取一个对象的所有自身属性的描述符。</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj)<br><span class="hljs-comment">//返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj)<br><span class="hljs-comment">//返回一个数组，它包含了指定对象自身所有的符号属性。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(object)<br><span class="hljs-comment">//返回指定对象的原型对象。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>()比较两个值是否相同。所有 <span class="hljs-title class_">NaN</span> 值都相等（这与==和===不同）。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>()判断对象是否可扩展。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>()判断对象是否已经冻结。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isSealed</span>()判断对象是否已经密封。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>()返回一个包含所有给定对象自身可枚举属性名称的数组。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>()防止对象的任何扩展。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>()防止其他代码删除对象的属性。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>()设置对象的原型（即内部[[<span class="hljs-title class_">Prototype</span>]]属性）。<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>()返回给定对象自身可枚举值的数组。<br><br><br>+descriptor<br><span class="hljs-attr">configurable</span>:<span class="hljs-literal">false</span><br><span class="hljs-comment">//true 只有该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 默认为 false</span><br><span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span><br><span class="hljs-comment">//true 只有在枚举相应对象上的属性时该属性显现。 默认为 false</span><br><span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span><br><span class="hljs-comment">//与属性关联的值。可以是任何有效的 JavaScript 值（数字，对象，函数等）。 默认为 undefined.</span><br><span class="hljs-attr">writable</span>:<span class="hljs-literal">false</span><br><span class="hljs-comment">//true只有与该属性相关联的值被assignment operator (en-US)改变时。 默认为 false</span><br><span class="hljs-attr">get</span>:<span class="hljs-literal">undefined</span><br><span class="hljs-comment">//作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。 默认为 undefined</span><br><span class="hljs-attr">set</span>:<span class="hljs-literal">undefined</span><br><span class="hljs-comment">//作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。 默认为 undefined</span><br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JS">在 <span class="hljs-title class_">JavaScript</span> 里通常使用 <span class="hljs-title class_">Array</span> 或 <span class="hljs-title class_">Object</span> 来存储数据。<br>但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。<br>比如如何保证 <span class="hljs-title class_">Array</span> 是去重的，如何统计 <span class="hljs-title class_">Object</span> 的数据总数等，必须自己去手动实现类似的需求，不是很方便。<br>在 <span class="hljs-title class_">ES6</span> 中为了解决上述痛点，新增了数据结构 <span class="hljs-title class_">Set</span> 和 <span class="hljs-title class_">Map</span>，它们分别对应传统数据结构的“集合”和“字典”。<br><br><span class="hljs-title class_">Set</span> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br><span class="hljs-title class_">Set</span>对象是值的集合，你可以按照插入的顺序迭代它的元素。<span class="hljs-title class_">Set</span> 中的元素只会出现一次，即 <span class="hljs-title class_">Set</span> 中的元素是唯一的。<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>（）    <span class="hljs-comment">//set对象属于可遍历对象  有索引跟值就可以  数组跟对象属于常规的可遍历对象</span><br> s.<span class="hljs-property">size</span>     <span class="hljs-comment">//set内部数据的 长度</span><br> s.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>   <span class="hljs-comment">//属性表示Set构造函数的原型对象。包含 Writable/Enumerabl/Configurable</span><br> s.<span class="hljs-property">add</span>（<span class="hljs-string">&quot;qwe&quot;</span>）.<span class="hljs-property">add</span>（<span class="hljs-string">&quot;sda&quot;</span>）.<span class="hljs-property">add</span>（<span class="hljs-string">&quot;qwe&quot;</span>）   <span class="hljs-comment">//set会默认过滤掉重复数据</span><br> s.<span class="hljs-property">delete</span>（<span class="hljs-string">&quot;qwe&quot;</span>）  <span class="hljs-comment">//查找并删除</span><br> s.<span class="hljs-property">clear</span>（）  <span class="hljs-comment">//清空set</span><br> s.<span class="hljs-property">has</span>（<span class="hljs-string">&quot;sda&quot;</span>）  <span class="hljs-comment">//查找是否存在该属性 返回布尔值</span><br> s.<span class="hljs-property">keys</span>（）<br> s.<span class="hljs-property">values</span>（）<br> s.<span class="hljs-property">entries</span>（）  <span class="hljs-comment">//返回一个新的Iterator对象，包含[value, value]给定的每个元素的数组Set，按照插入顺序。</span><br><br>+创建set<br><span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    mySet.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Set [ 1 ]</span><br>    mySet.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Set [ 1, 5 ]</span><br>    mySet.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Set [ 1, 5 ]</span><br>    mySet.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;some text&quot;</span>); <span class="hljs-comment">// Set [ 1, 5, &quot;some text&quot; ]</span><br>+迭代set<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> mySet.<span class="hljs-title function_">entries</span>()) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> mySet.<span class="hljs-title function_">keys</span>()) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>+<span class="hljs-title class_">Array</span> 相关<br>    <span class="hljs-keyword">let</span> myArray = [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>];<br>    <span class="hljs-comment">// 用 Set 构造器将 Array 转换为 Set</span><br>    <span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(myArray);<br>    mySet.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;value1&quot;</span>); <span class="hljs-comment">// returns true</span><br>    <span class="hljs-comment">// 用...(展开操作符) 操作符将 Set 转换为 Array</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...mySet]); <span class="hljs-comment">// 与 myArray 完全一致</span><br>+数组去重<br>    <span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">32</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(numbers)])<br>    <span class="hljs-comment">// [2, 3, 4, 5, 6, 7, 32]</span><br>+<span class="hljs-title class_">String</span> 相关<br>    <span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;India&#x27;</span>;<br>    <span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(text);  <span class="hljs-comment">// Set &#123;&#x27;I&#x27;, &#x27;n&#x27;, &#x27;d&#x27;, &#x27;i&#x27;, &#x27;a&#x27;&#125;</span><br>    mySet.<span class="hljs-property">size</span>;  <span class="hljs-comment">// 5</span><br>    <span class="hljs-comment">// 大小写敏感 &amp; duplicate ommision</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-string">&quot;Firefox&quot;</span>)  <span class="hljs-comment">// Set(7) [ &quot;F&quot;, &quot;i&quot;, &quot;r&quot;, &quot;e&quot;, &quot;f&quot;, &quot;o&quot;, &quot;x&quot; ]</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-string">&quot;firefox&quot;</span>)  <span class="hljs-comment">// Set(6) [ &quot;f&quot;, &quot;i&quot;, &quot;r&quot;, &quot;e&quot;, &quot;o&quot;, &quot;x&quot; ]</span><br> <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br><span class="hljs-comment">//1. 数组去重</span><br><span class="hljs-comment">// let result = [...new Set(arr)];</span><br><span class="hljs-comment">// console.log(result);</span><br><span class="hljs-comment">//2. 交集</span><br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-comment">// let result = [...new Set(arr)].filter(item =&gt; &#123;</span><br><span class="hljs-comment">//     let s2 = new Set(arr2);// 4 5 6</span><br><span class="hljs-comment">//     if(s2.has(item))&#123;</span><br><span class="hljs-comment">//         return true;</span><br><span class="hljs-comment">//     &#125;else&#123;</span><br><span class="hljs-comment">//         return false;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><span class="hljs-comment">// let result = [...new Set(arr)].filter(item =&gt; new Set(arr2).has(item));</span><br><span class="hljs-comment">// console.log(result);</span><br><br><span class="hljs-comment">//3. 并集</span><br><span class="hljs-comment">// let union = [...new Set([...arr, ...arr2])];</span><br><span class="hljs-comment">// console.log(union);</span><br><br><span class="hljs-comment">//4. 差集</span><br><span class="hljs-keyword">let</span> diff = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr2).<span class="hljs-title function_">has</span>(item)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(diff);<br><br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JS">对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([iterable])<br><span class="hljs-title class_">Iterable</span> 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 <span class="hljs-title class_">Map</span>。<span class="hljs-literal">null</span>会被当做 <span class="hljs-literal">undefined</span>。<br>一个<span class="hljs-title class_">Map</span>对象以插入顺序迭代其元素 — 一个  <br><span class="hljs-keyword">for</span>...<span class="hljs-keyword">of</span> 循环为每次迭代返回一个[key，value]数组。<br>应该注意的是,<span class="hljs-title class_">Map</span>是一个对象的映射，将只映射到对象的插入顺序 - 这是随机的，而不是依照次序的。<br><br>map.<span class="hljs-property">size</span>    <span class="hljs-comment">//size 可访问属性返回 Map对象的元素数量.</span><br>map.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>   <span class="hljs-comment">//属性表示Map构造函数的原型对象。包含 Writable/Enumerabl/Configurable</span><br><br>map.<span class="hljs-title function_">clear</span>()  <span class="hljs-comment">//clear()方法会移除Map对象中的所有元素。</span><br>map.<span class="hljs-title function_">delete</span>()  <span class="hljs-comment">//delete()方法用于移除Map对象中指定的元素。</span><br><br><br>map.<span class="hljs-title function_">set</span>()  <span class="hljs-comment">//set() 方法为Map对象添加一个指定键（key）和值（value）的新元素。</span><br>map.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">//get() 方法用来获取一个 Map?对象中指定的元素。</span><br>map.<span class="hljs-title function_">delete</span>() <span class="hljs-comment">//has() 返回一个bool值，用来表明map 中是否存在指定元素.</span><br><br>map.<span class="hljs-title function_">keys</span>()  <span class="hljs-comment">//keys()返回一个新的 Iterator对象。它包含按照顺序插入Map对象中每个元素的key值。</span><br>map.<span class="hljs-property">values</span>  <span class="hljs-comment">//values() 方法返回一个新的Iterator对象。它包含按顺序插入Map对象中每个元素的value值。</span><br>map.<span class="hljs-title function_">entries</span>()  <span class="hljs-comment">//entries()方法返回一个新的包含 [key, value]的 Iterator对象，返回的迭代器的迭代顺序与 Map对象的插入顺序相同。</span><br><br>map.<span class="hljs-title function_">forEach</span>(callback[,thisArg])  <span class="hljs-comment">//forEach 方法将对Map中真实存在的每一个元素执行一次?参数中提供的回调函数，它不会对任何已经被删除的元素执行调用。然而，它还会对键存在而值为 undefined 的元素执行调用。</span><br><br><br><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;value-4&#x27;</span>)<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;value-3&#x27;</span>)<br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value, key)<br>&#125;)  <span class="hljs-comment">//输入 2  10； value-4 3；value-3 1</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>&#125;  <span class="hljs-comment">//输出  10 2 ；3 value-4；1 value-3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">使用 <span class="hljs-keyword">for</span>..<span class="hljs-property">of</span> 方法迭代 <span class="hljs-title class_">Map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&#x27; = &#x27;</span> + value)<br>    &#125;<br>使用 <span class="hljs-title function_">forEach</span>() 方法迭代 <span class="hljs-title class_">Map</span><br>myMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&#x27; = &#x27;</span> + value)<br>&#125;)<br><span class="hljs-title class_">Map</span>与数组的关系<br>    <span class="hljs-keyword">const</span> kvArray = [[<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>], [<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]];<br>    <span class="hljs-comment">// 使用常规的 Map 构造函数可以将一个二维键值对数组转换成一个 Map 对象</span><br>    <span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(kvArray);<br>    myMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;key1&quot;</span>); <span class="hljs-comment">// 返回值为 &quot;value1&quot;</span><br>    <span class="hljs-comment">// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myMap)); <span class="hljs-comment">// 输出和 kvArray 相同的数组</span><br>    <span class="hljs-comment">// 更简洁的方法来做如上同样的事情，使用展开运算符</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...myMap]);<br>    <span class="hljs-comment">// 或者在键或者值的迭代器上使用 Array.from，进而得到只含有键或者值的数组</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myMap.<span class="hljs-title function_">keys</span>())); <span class="hljs-comment">// 输出 [&quot;key1&quot;, &quot;key2&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="Template-literals"><a href="#Template-literals" class="headerlink" title="Template literals"></a>Template literals</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JS">模板字面量/<span class="hljs-title class_">Template</span> literals 是允许嵌入表达式的字符串字面量。<br>模板字符串使用反引号 (<span class="hljs-string">` `</span>) 来代替普通字符串中的用双引号和单引号。<br>模板字符串可以包含特定语法($&#123;expression&#125;)的占位符。<br>占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。<br>模板字面量支持多行<br><span class="hljs-comment">//在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。</span><br><span class="hljs-string">`\``</span> === <span class="hljs-string">&#x27;`&#x27;</span>   <span class="hljs-comment">// --&gt; true</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Fifteen is <span class="hljs-subst">$&#123;a + b&#125;</span> and</span><br><span class="hljs-string">    not <span class="hljs-subst">$&#123;<span class="hljs-number">2</span> * a + b&#125;</span>.`</span>);<br>    <span class="hljs-comment">// &quot;Fifteen is 15 and</span><br>    <span class="hljs-comment">// not 20.&quot;</span><br><br>原始字符串<br>raw标记模板文字的第一个函数参数上的特殊属性允许您在输入时访问原始字符串，而不处理转义序列。<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strings.<span class="hljs-property">raw</span>[<span class="hljs-number">0</span>]);<br>&#125;<br><br>tag<span class="hljs-string">`string text line 1 \n string text line 2`</span>;<br><span class="hljs-comment">// logs &quot;string text line 1 \n string text line 2&quot; ,</span><br><span class="hljs-comment">// including the two characters &#x27;\&#x27; and &#x27;n&#x27;</span><br><br>此外，该<span class="hljs-title class_">String</span>.<span class="hljs-title function_">raw</span>()方法存在创建原始字符串就像默认的模板函数和字符串连接会创建。<br><span class="hljs-keyword">var</span> str = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`Hi\n<span class="hljs-subst">$&#123;<span class="hljs-number">2</span>+<span class="hljs-number">3</span>&#125;</span>!`</span>;<br><span class="hljs-comment">// &quot;Hi\n5!&quot;</span><br><br>str.<span class="hljs-property">length</span>;<br><span class="hljs-comment">// 6</span><br><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br><span class="hljs-comment">// &quot;H,i,\,n,5,!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Desctructuring"><a href="#Desctructuring" class="headerlink" title="Desctructuring"></a>Desctructuring</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">ES6</span> 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。<br>可以从数组中提取值，按照对应位置，对变量赋值。<br>本质上属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br><br>+对象解构<br>es6 解构对象是 变量名必须和属性名相同 但是顺序没有要求。<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">names</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>        age : <span class="hljs-number">18</span>,<br>        sex : <span class="hljs-string">&#x27;女&#x27;</span>,<br>        data :[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<br>        say : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你好我是张三&#x27;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// es5 : </span><br>    <span class="hljs-comment">// var name = obj.name;</span><br>    <span class="hljs-comment">// var age = obj.age;</span><br><br>    <span class="hljs-comment">// 1. 解构对象中的变量</span><br>    <span class="hljs-keyword">let</span> &#123;names,age,say&#125; = obj;   <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(names,age);<br>    <span class="hljs-comment">// 2. 解构对象中的方法   </span><br>    <span class="hljs-title function_">say</span>();    <br>    <span class="hljs-comment">// 3.结构对象中的数组</span><br>   <span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">data</span>:[a,b,c,d]&#125; = obj;   <br><br>解构字符串时 会将字符串当做一个数组 来取解构<br><br>通过字面量合并对象<br><span class="hljs-attr">obj1</span>:&#123;<span class="hljs-attr">key1</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">key2</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">key3</span>:<span class="hljs-number">3</span>&#125;,<br><span class="hljs-attr">obj2</span>:&#123;<span class="hljs-attr">key2</span>:<span class="hljs-number">22</span>,<span class="hljs-attr">key4</span>:<span class="hljs-number">44</span> &#125;,      <br>obj3=&#123;...obj1,...obj2&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj3)<span class="hljs-comment">//输出 &#123;key1:1, key2:22,key3:3,key4:44 &#125;, </span><br><br></code></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JS">+ 概述<br>是异步编程的一种解决方案。从语法上说，<span class="hljs-title class_">Promise</span> 是一个对象，从它可以获取异步操作的消息。<br><br>+<span class="hljs-title class_">Promise</span> 状态<br><span class="hljs-title class_">Promise</span> 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。<br><span class="hljs-title class_">Promise</span> 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）<br><br><br>+创建<span class="hljs-title class_">Promise</span>对象<br><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// 异步处理</span><br>    <span class="hljs-comment">// 处理结束后、调用resolve 或 reject</span><br>    <span class="hljs-comment">//resolve是必须的，reject可以省略</span><br>&#125;);<br><br><br><span class="hljs-keyword">var</span> myFirstPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br>    <span class="hljs-comment">//当异步代码执行成功时，才会调用resolve(...), 当异步代码失败时就会调用reject(...)</span><br>    <span class="hljs-comment">//在本例中，使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功!&quot;</span>); <span class="hljs-comment">//代码正常执行！</span><br>    &#125;, <span class="hljs-number">250</span>);<br>&#125;);<br> <br>myFirstPromise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">successMessage</span>)&#123;<br>    <span class="hljs-comment">//successMessage的值是上面调用resolve(...)方法传入的值.</span><br>    <span class="hljs-comment">//successMessage参数不一定非要是字符串类型，这里只是举个例子</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;Yay! &quot;</span> + successMessage);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span>  方法<br>+<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span>  方法<br>then 方法接收两个函数作为参数，第一个参数是 <span class="hljs-title class_">Promise</span> 执行成功时的回调，第二个参数是 <span class="hljs-title class_">Promise</span> 执行失败时的回调，两个函数只会有一个被调用。通过 .<span class="hljs-property">then</span> 形式添加的回调函数，不论什么时候，都会被调用。<br>    promise.<span class="hljs-title function_">then</span>(onFulfilled, onRejected)<br><span class="hljs-comment">//promise简化了对error的处理，上面的代码我们也可以这样写：</span><br>    promise.<span class="hljs-title function_">then</span>(onFulfilled).<span class="hljs-title function_">catch</span>(onRejected)<br><br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;);<br><br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first&#x27;</span>);<br>    <span class="hljs-comment">// first</span><br>    <span class="hljs-comment">// success</span><br><br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 第一个then // 1</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>      <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 第二个then // 2</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);    <span class="hljs-comment">//第二个then  返回值是undefined</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 第三个then // undefined</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>); <span class="hljs-comment">// 第三个then返回值是resolve</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 第四个then // resolve</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;reject&#x27;</span>); <br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 第五个then //reject:reject</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve:&#x27;</span> + value);<br>    &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject:&#x27;</span> + err);<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error));<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span> (src) &#123;<br>  <span class="hljs-comment">// pending,undefined</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>    script.<span class="hljs-property">src</span> = src<br>    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(src)<span class="hljs-comment">// fulfilled,result</span><br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err)<span class="hljs-comment">// rejected,error</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">append</span>(script)<br>  &#125;)<br>&#125;<br><br>+正常写法<span class="hljs-comment">//1.js和3.js均可以正常加载 4.js加载失败</span><br>    <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./1.js&#x27;</span>)   <br>    <span class="hljs-comment">//正常执行 resolve(./1.js) 状态为 fulfilled</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./4.js&#x27;</span>)<br>        <span class="hljs-comment">//上一状态为 fulfilled  resolve的value为(./1.js)  </span><br>        <span class="hljs-comment">//return返回一个新的promise实例  </span><br>        <span class="hljs-comment">// loadScript(&#x27;./4.js&#x27;)无法执行  promise实例状态为rejected</span><br>      &#125;)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./3.js&#x27;</span>)<br>        <span class="hljs-comment">//状态为rejected 无法修改 不执行这个then</span><br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;)<br>      <span class="hljs-comment">// throw new Error</span><br>+对比分析<br>    <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./1.js&#x27;</span>)<br>    <span class="hljs-comment">//正常执行 resolve(./1.js) 状态为 fulfilled</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>         <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./4.js&#x27;</span>)<br>        <span class="hljs-comment">//上一状态为 fulfilled  resolve的value为(./1.js)  </span><br>        <span class="hljs-comment">//无返回 默认返回一个空的promise  此时状态为fulfilled</span><br>        <span class="hljs-comment">//loadScript(&#x27;./4.js&#x27;)是否能执行均不会影响此时的状态</span><br>      &#125;)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>         <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;./3.js&#x27;</span>)<br>       <span class="hljs-comment">//上一状态为为fulfilled 继续执行这个then</span><br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;)<br>      <span class="hljs-comment">// throw new Error</span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> 方法，<span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> 方法<br><br><br><span class="hljs-comment">//有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</span><br><span class="hljs-keyword">var</span> jsPromise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>($.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/whatever.json&#x27;</span>));<br><span class="hljs-comment">//上面代码将 jQuery 生成 deferred 对象，转为一个新的 ES6 的 Promise 对象。</span><br><br><span class="hljs-comment">//如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</span><br><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br> <br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<br>&#125;);<br><span class="hljs-comment">// Hello</span><br><span class="hljs-comment">//上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</span><br><br><span class="hljs-comment">//如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</span><br><span class="hljs-comment">//Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</span><br><br><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br> <br>p.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<br>&#125;);<br><span class="hljs-comment">// 出错了</span><br><span class="hljs-comment">//上面代码生成一个Promise对象的实例，状态为rejected，回调函数会立即执行。</span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> (bool) &#123;<br>  <span class="hljs-keyword">if</span> (bool) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-number">30</span>)<br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;ss&#x27;</span>))<br>  &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span>方法<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> 方法用于将多个 <span class="hljs-title class_">Promise</span> 实例，包装成一个新的 <span class="hljs-title class_">Promise</span> 实例。<br>        <span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2,p3]);<br>    上面代码中，<span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> 方法接受一个数组作为参数，p1、p2、p3 都是 <span class="hljs-title class_">Promise</span> 对象的实例。<br>    （<span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> 方法的参数不一定是数组，但是必须具有 iterator 接口，<br>    且返回的每个成员都是 <span class="hljs-title class_">Promise</span> 实例。）<br><br>    p 的状态由 p1、p2、p3 决定，分成两种情况。<br>    （<span class="hljs-number">1</span>）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，<br>    此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>    （<span class="hljs-number">2</span>）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，<br>    此时第一个被reject的实例的返回值，会传递给p的回调函数。<br><br>+<span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span>方法<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> 方法同样是将多个 <span class="hljs-title class_">Promise</span> 实例，包装成一个新的 <span class="hljs-title class_">Promise</span> 实例。<br><br>    <span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1,p2,p3]);<br>    上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。<br>    那个率先改变的<span class="hljs-title class_">Promise</span>实例的返回值，就传递给p的返回值。<br><br>    如果<span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span>方法和<span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span>方法的参数，不是<span class="hljs-title class_">Promise</span>实例，<br>就会先调用下面讲到的<span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span>方法，将参数转为<span class="hljs-title class_">Promise</span>实例，再进一步处理。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">+ <span class="hljs-title class_">Promise</span> 封装ajax     <br>      <span class="hljs-comment">// 接口地址: https://api.apiopen.top/getJoke</span><br>        <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//1. 创建对象</span><br>            <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br>            <span class="hljs-comment">//2. 初始化</span><br>            xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://api.apiopen.top/getJ&quot;</span>);<br><br>            <span class="hljs-comment">//3. 发送</span><br>            xhr.<span class="hljs-title function_">send</span>();<br><br>            <span class="hljs-comment">//4. 绑定事件, 处理响应结果</span><br>            xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">//判断</span><br>                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                    <span class="hljs-comment">//判断响应状态码 200-299</span><br>                    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>                        <span class="hljs-comment">//表示成功</span><br>                        <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//如果失败</span><br>                        <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">status</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>        <br>        <span class="hljs-comment">//指定回调</span><br>        p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>        &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>        &#125;);<br></code></pre></td></tr></table></figure><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">Reflect</span>是一个内置的对象，它提供拦截 <span class="hljs-title class_">JavaScript</span> 操作的方法。这些方法与处理器对象的方法相同。<span class="hljs-title class_">Reflect</span>不是一个函数对象，因此它是不可构造的。与大多数全局对象不同，<span class="hljs-title class_">Reflect</span>没有构造函数。你不能将其与一个<span class="hljs-keyword">new</span>运算符一起使用，或者将<span class="hljs-title class_">Reflect</span>对象作为一个函数来调用。<span class="hljs-title class_">Reflect</span>的所有属性和方法都是静态的（就像<span class="hljs-title class_">Math</span>对象）。<br><br><span class="hljs-title class_">Reflect</span>在调用的方法存在不确定性的情况下表现更好<br>在方法确定的情况下用和常规方法没有较大差别<br><br><span class="hljs-title class_">Reflect</span>对象提供以下静态函数，它们具有与处理器对象方法相同的名称。这些方法中的一些与<span class="hljs-title class_">Object</span>上的对应方法相同。<br><br>+<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArgument, argumentsList)<br>        <span class="hljs-comment">//对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和Function.prototype.apply()功能类似。</span><br>        <span class="hljs-comment">//target目标函数。thisArgumenttarget函数调用时绑定的this对象。argumentsListtarget函数调用时传入的实参列表，该参数应该是一个类数组的对象。</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">floor</span>, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]); <span class="hljs-comment">// 1;   </span><br>    <span class="hljs-comment">//ES5写法   Math.floor.apply（null，[1.75]）</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">fromCharCode</span>, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>]);<span class="hljs-comment">// &quot;hello&quot;   </span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">exec</span>, <span class="hljs-regexp">/ab/</span>, [<span class="hljs-string">&#x27;confabulation&#x27;</span>]).<span class="hljs-property">index</span>;<span class="hljs-comment">// 4</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-property">charAt</span>, <span class="hljs-string">&#x27;ponies&#x27;</span>, [<span class="hljs-number">3</span>]);<span class="hljs-comment">// &quot;i&quot;</span><br><br>+ <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, argumentsList[, newTarget])<br>    <span class="hljs-comment">//target被运行的目标函数argumentsList调用构造函数的数组或者伪数组newTarget可选该参数为构造函数， 参考new.target操作符，如果没有newTarget参数， 默认和target一样</span><br>    <span class="hljs-comment">//对构造函数进行new操作，相当于执行new target(...args)。</span><br>    <span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Date</span>, [<span class="hljs-number">1776</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]);<br><br>+ <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, attributes)<br>    <span class="hljs-comment">//和Object.defineProperty()类似。唯一不同是返回 Boolean值。</span><br>    <span class="hljs-comment">//target目标对象。propertyKey要定义或修改的属性的名称。attributes要定义或修改的属性的描述。</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">7</span>&#125;); <span class="hljs-comment">// true</span><br><br>+<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, propertyKey)<br>    <span class="hljs-comment">//Reflect.deleteProperty()作为函数的delete操作符，相当于执行delete target[name]。唯一不同是返回 Boolean值。</span><br><br>+ <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">enumerate</span>()<br>    <span class="hljs-comment">//该方法会返回一个包含有目标对象身上所有可枚举的自身字符串属性以及继承字符串属性的迭代器，for...in操作遍历到的正是这些属性。</span><br><br>+ <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, propertyKey[, receiver])<br>    <span class="hljs-comment">//获取对象身上某个属性的值，。就像从对象 (target[propertyKey]) 中获取属性，但它是作为一个函数执行的。</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>([<span class="hljs-string">&#x27;zero&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>], <span class="hljs-number">1</span>); <span class="hljs-comment">// &quot;one&quot;</span><br>    <span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 1</span><br>+ <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, propertyKey, value[, receiver])<br>    <span class="hljs-comment">//Reflect.set 方法允许你在对象上设置属性。它的作用是给属性赋值并且就像 property accessor语法一样，但是它是以函数的方式。</span><br>    <span class="hljs-comment">//target设置属性的目标对象。propertyKey设置的属性的名称。value设置的值。receiver如果遇到 setter，this 将提供给目标调用。返回一个boolean值</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(target, propertyKey)<br><span class="hljs-comment">//类似于Object.getOwnPropertyDescriptor()。</span><br><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(target)<br><span class="hljs-comment">//类似于Object.getPrototypeOf()。</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(&#123;&#125;); <span class="hljs-comment">// Object.prototype</span><br><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, propertyKey)<br><span class="hljs-comment">//判断一个对象是否存在某个属性，和in运算符的功能完全相同。</span><br><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(target)<br><span class="hljs-comment">//类似于Object.isExtensible().</span><br><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>()<br><span class="hljs-comment">//返回一个包含所有自身属性（不包含继承属性）的数组。</span><br><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">preventExtensions</span>()<br><span class="hljs-comment">//类似于Object.preventExtensions()。返回一个Boolean。Reflect.set()将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</span><br><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>()<br><span class="hljs-comment">//类似于Object.setPrototypeOf()。</span><br></code></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br><br>处理器对象用来自定义代理对象的各种可代理操作。<br>一共有 <span class="hljs-number">13</span> 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式列举如下。注意，如果没有定义某种操作，那么这种操作会被转发到目标对象身上。<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>  <span class="hljs-attr">apply</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;...&#125;;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, property, receiver</span>) &#123;...&#125;;<br>  <br>&#125;);<br>                                                    <br>                                                   <br><span class="hljs-number">13</span>种拦截方法如下（以下引用摘自阮一峰<span class="hljs-title class_">ES6</span>入门）：<br><br>    <span class="hljs-number">1</span>、<span class="hljs-title function_">get</span>(target, propKey, receiver)：<br>    拦截对象属性的读取，比如proxy.<span class="hljs-property">foo</span>和proxy[‘foo’]。<br><br>    <span class="hljs-number">2</span>、<span class="hljs-title function_">set</span>(target, propKey, value, receiver)： 拦截对象属性的设置，比如proxy.<span class="hljs-property">foo</span> =<br>    v或proxy[‘foo’] = v，返回一个布尔值。<br><br>    <span class="hljs-number">3</span>、<span class="hljs-title function_">has</span>(target, propKey)：<br>    拦截propKey <span class="hljs-keyword">in</span> proxy的操作，返回一个布尔值。<br><br>    <span class="hljs-number">4</span>、<span class="hljs-title function_">deleteProperty</span>(target, propKey)：<br>    拦截<span class="hljs-keyword">delete</span> proxy[propKey]的操作，返回一个布尔值。<br><br>    <span class="hljs-number">5</span>、<span class="hljs-title function_">ownKeys</span>(target)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(proxy)、<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(proxy)、<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(proxy)、<span class="hljs-keyword">for</span>…<span class="hljs-keyword">in</span>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，<br>    而<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>()的返回结果仅包括目标对象自身的可遍历属性。<br><br>    <span class="hljs-number">6</span>、<span class="hljs-title function_">getOwnPropertyDescriptor</span>(target, propKey)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(proxy, propKey)，返回属性的描述对象。<br><br>    <span class="hljs-number">7</span>、<span class="hljs-title function_">defineProperty</span>(target, propKey, propDesc)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(proxy, propKey,<br>    propDesc）、<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(proxy, propDescs)，返回一个布尔值。<br><br>    <span class="hljs-number">8</span>、<span class="hljs-title function_">preventExtensions</span>(target)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(proxy)，返回一个布尔值。<br><br>    <span class="hljs-number">9</span>、<span class="hljs-title function_">getPrototypeOf</span>(target)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proxy)，返回一个对象。<br><br>    <span class="hljs-number">10</span>、<span class="hljs-title function_">isExtensible</span>(target)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(proxy)，返回一个布尔值。<br><br>    <span class="hljs-number">11</span>、<span class="hljs-title function_">setPrototypeOf</span>(target, proto)：<br>    拦截<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(proxy,<br>    proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。<br><br>    <span class="hljs-number">12</span>、<span class="hljs-title function_">apply</span>(target, object, args)：<br>    拦截<span class="hljs-title class_">Proxy</span> 实例作为函数调用的操作，比如<span class="hljs-title function_">proxy</span>(…args)、proxy.<span class="hljs-title function_">call</span>(object,<br>    …args)、proxy.<span class="hljs-title function_">apply</span>(…)。<br><br>    <span class="hljs-number">13</span>、<span class="hljs-title function_">construct</span>(target, args)：<br>    拦截 <span class="hljs-title class_">Proxy</span> 实例作为构造函数调用的操作，比如<span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(…args)。<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, handler);  方法可以用来创建一个可撤销的代理对象。     <br><br><span class="hljs-keyword">var</span> revocable = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(&#123;&#125;, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, name</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[[&quot;</span> + name + <span class="hljs-string">&quot;]]&quot;</span>;<br>  &#125;<br>&#125;);<br><span class="hljs-keyword">var</span> proxy = revocable.<span class="hljs-property">proxy</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &quot;[[foo]]&quot;</span><br><br>revocable.<span class="hljs-title function_">revoke</span>();    <span class="hljs-comment">//撤销代理</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>); <span class="hljs-comment">// TypeError is thrown</span><br>proxy.<span class="hljs-property">foo</span> = <span class="hljs-number">1</span>           <span class="hljs-comment">// TypeError again</span><br><span class="hljs-keyword">delete</span> proxy.<span class="hljs-property">foo</span>;       <span class="hljs-comment">// still TypeError</span><br><span class="hljs-keyword">typeof</span> proxy            <span class="hljs-comment">// &quot;object&quot;, typeof doesn&#x27;t trigger any trap</span><br></code></pre></td></tr></table></figure><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">Generator</span>对象由一个生成器函数获得，它符合iterable协议和iterator协议。<br><br><span class="hljs-title class_">Generator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">next</span>()返回一个由<span class="hljs-keyword">yield</span>表达式生成的值。<br><span class="hljs-title class_">Generator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-keyword">return</span>()返回给定的值并结束生成器。<br><span class="hljs-title class_">Generator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-keyword">throw</span>()向生成器抛出一个错误。<br><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;one&quot;</span>);<br> <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;two&quot;</span>);<br> <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;2&#x27;</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;three&quot;</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;3&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-title function_">next</span>());<span class="hljs-comment">//  先执行f.next()，输出one</span><br><span class="hljs-comment">// 此时f.next()返回的是&#123;value: &quot;1&quot;, done: false&#125; 通过控制台输出</span><br> <br>f.<span class="hljs-title function_">next</span>();<span class="hljs-comment">// two</span><br><span class="hljs-comment">// 此时f.next()返回的是&#123;value: &quot;2&quot;, done: false&#125;</span><br> <br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">//three</span><br><span class="hljs-comment">// 此时f.next()返回的是&#123;value: &quot;3&quot;, done: true&#125;</span><br> <br>f.<span class="hljs-title function_">next</span>();  <span class="hljs-comment">//无输出</span><br><span class="hljs-comment">// 此时f.next()返回的是 &#123;value: undefined, done: true&#125;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js">+ next 方法<br>    一般情况下，next 方法不传入参数的时候，<span class="hljs-keyword">yield</span> 表达式的返回值是 <span class="hljs-literal">undefined</span> 。<br>    <span class="hljs-keyword">yield</span>后面跟的表达式会将该表达式的值传给next（）.<span class="hljs-property">value</span>，<br>    比如 <span class="hljs-keyword">const</span> a =<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;1&#x27;</span> 是拿不到值的 只会输出<span class="hljs-literal">undefined</span><br>    当 next 传入参数的时候，该参数会作为上一步<span class="hljs-keyword">yield</span>的返回值。<br>    <br>    除了使用 next ，还可以使用 <span class="hljs-keyword">for</span>... <span class="hljs-keyword">of</span> 循环遍历 <span class="hljs-title class_">Generator</span> 函数生产的 <span class="hljs-title class_">Iterator</span> 对象。<br>    <br>    <span class="hljs-keyword">function</span>* <span class="hljs-title function_">sendParameter</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>);<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;2&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;one:&quot;</span> + x);<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;3&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;two:&quot;</span> + y);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;total:&quot;</span> + (x + y));<br>&#125;<br><br>   next不传参<br>        <span class="hljs-keyword">var</span> sendp1 = <span class="hljs-title function_">sendParameter</span>();<br>        sendp1.<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">// start</span><br>        <span class="hljs-comment">// &#123;value: &quot;2&quot;, done: false&#125;</span><br>        sendp1.<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">// one:undefined</span><br>        <span class="hljs-comment">// &#123;value: &quot;3&quot;, done: false&#125;</span><br>        sendp1.<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">// two:undefined</span><br>        <span class="hljs-comment">// total:NaN</span><br>        <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br>    next传参<br>        <span class="hljs-keyword">var</span> sendp2 = <span class="hljs-title function_">sendParameter</span>();<br>        sendp2.<span class="hljs-title function_">next</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// start</span><br>        <span class="hljs-comment">// &#123;value: &quot;2&quot;, done: false&#125;</span><br>        sendp2.<span class="hljs-title function_">next</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">// one:20</span><br>        <span class="hljs-comment">// &#123;value: &quot;3&quot;, done: false&#125;</span><br>        sendp2.<span class="hljs-title function_">next</span>(<span class="hljs-number">30</span>);<br>        <span class="hljs-comment">// two:30</span><br>        <span class="hljs-comment">// total:50</span><br>        <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">+ <span class="hljs-keyword">return</span> 方法<br><br>    <span class="hljs-keyword">return</span> 方法返回给定值，并结束遍历 <span class="hljs-title class_">Generator</span> 函数。<br>    <span class="hljs-keyword">return</span> 方法提供参数时，返回该参数；不提供参数时，返回 <span class="hljs-literal">undefined</span> 。<br><br>        <span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">var</span> f = <span class="hljs-title function_">foo</span>();<br>        f.<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>        f.<span class="hljs-keyword">return</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>        <span class="hljs-comment">// &#123;value: &quot;foo&quot;, done: true&#125;</span><br>        f.<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br>+ <span class="hljs-keyword">throw</span> 方法<br>    <span class="hljs-keyword">throw</span> 方法可以再 <span class="hljs-title class_">Generator</span> 函数体外面抛出异常，再函数体内部捕获。<br>        <span class="hljs-keyword">var</span> g = <span class="hljs-keyword">function</span>* () &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">yield</span>;<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catch inner&#x27;</span>, e);<br>          &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">var</span> i = <span class="hljs-title function_">g</span>();<br>        i.<span class="hljs-title function_">next</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>          i.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>          i.<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;catch outside&#x27;</span>, e);<br>        &#125;<br>        <span class="hljs-comment">// catch inner a</span><br>        <span class="hljs-comment">// catch outside b</span><br><span class="hljs-comment">//遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，</span><br><span class="hljs-comment">//第二个因为函数体内部的catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。</span><br>+<span class="hljs-keyword">yield</span>* 表达式<br><br><span class="hljs-keyword">yield</span>* 表达式表示 <span class="hljs-keyword">yield</span> 返回一个遍历器对象，用于在 <span class="hljs-title class_">Generator</span> 函数内部，调用另一个 <span class="hljs-title class_">Generator</span> 函数。<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js">####################<span class="hljs-variable constant_">MDN</span>官方文档#################<br><br>+ 生成器对象是由一个 generator <span class="hljs-keyword">function</span> 返回的，并且它符合可迭代协议和迭代器协议。<br>+方法<br>    <span class="hljs-title class_">Generator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">next</span>()<br>    <span class="hljs-comment">//返回一个由 yield表达式生成的值。</span><br>    <span class="hljs-title class_">Generator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-keyword">return</span>()<br>    <span class="hljs-comment">//返回给定的值并结束生成器。</span><br>    <span class="hljs-title class_">Generator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-keyword">throw</span>()<br>    <span class="hljs-comment">//向生成器抛出一个错误。</span><br>+<span class="hljs-keyword">function</span>*<br>        会定义一个生成器函数 (generator <span class="hljs-keyword">function</span>)，它返回一个 <span class="hljs-title class_">Generator</span> 对象。生成器函数不能当构造器使用，也就是不可以用<span class="hljs-keyword">new</span>生成<br>    <span class="hljs-comment">//调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （ iterator ）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</span><br><span class="hljs-comment">//next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回。</span><br><span class="hljs-comment">//调用 next()方法时，如果传入了参数，那么这个参数会传给上一条执行的 yield 语句左边的变量</span><br>    <span class="hljs-comment">//当在生成器函数中显式 return 时，会导致生成器立即变为完成状态，即调用 next() 方法返回的对象的 done 为 true。如果 return 后面跟了一个值，那么这个值会作为当前调用 next() 方法返回的 value 值。</span><br>    <span class="hljs-keyword">function</span> *<span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// 4 + 2</span><br>                                  <span class="hljs-comment">// first =4 是 next(4) 将参数赋给上一条的</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>;             <span class="hljs-comment">// 5 + 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R&quot;</span>;<span class="hljs-comment">//显式返回处，可以观察到 done 也立即变为了 true</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;unreachable&quot;</span>;<span class="hljs-comment">// 不会被执行了</span><br>&#125;<br><br>    <span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());    <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>));   <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">5</span>));   <span class="hljs-comment">// &quot;&#123; value: 8, done: false &#125;&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());    <span class="hljs-comment">// &quot;&#123; value: &quot;R&quot;, done: true &#125;&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());    <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br><br>+ <span class="hljs-keyword">yield</span>* 的示例<br>    <span class="hljs-keyword">function</span>* <span class="hljs-title function_">anotherGenerator</span>(<span class="hljs-params">i</span>) &#123;<br>      <span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">yield</span> i + <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">yield</span> i + <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span>* <span class="hljs-title function_">generator</span>(<span class="hljs-params">i</span>)&#123;<br>      <span class="hljs-keyword">yield</span> i;<br>      <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">anotherGenerator</span>(i);<span class="hljs-comment">// 移交执行权</span><br>      <span class="hljs-keyword">yield</span> i + <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">generator</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 11</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 12</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 13</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 20</span><br><br>+使用迭代器遍历二维数组并转换成一维数组：<br>    <span class="hljs-keyword">function</span>* <span class="hljs-title function_">iterArr</span>(<span class="hljs-params">arr</span>) &#123;            <span class="hljs-comment">//迭代器返回一个迭代器对象</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;         <span class="hljs-comment">// 内节点</span><br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>              <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">iterArr</span>(arr[i]);   <span class="hljs-comment">// (*) 递归</span><br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;                          <span class="hljs-comment">// 离开</span><br>          <span class="hljs-keyword">yield</span> arr;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 使用 for-of 遍历：</span><br>    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">iterArr</span>(arr)) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);               <span class="hljs-comment">// a  b  c  d  e</span><br>    &#125;<br>    <span class="hljs-comment">// 或者直接将迭代器展开：</span><br>    <span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>,[ <span class="hljs-string">&#x27;c&#x27;</span>, [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]]]];<br>    <span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">iterArr</span>(arr);<br>    arr = [...gen];                        <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="Itetator"><a href="#Itetator" class="headerlink" title="Itetator"></a>Itetator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs JS">+可迭代协议<br>可迭代协议允许 <span class="hljs-title class_">JavaScript</span> 对象定义或定制它们的迭代行为，例如，在一个 <span class="hljs-keyword">for</span>..<span class="hljs-property">of</span> 结构中，哪些值可以被遍历到。一些内置类型同时是内置可迭代对象，并且有默认的迭代行为，比如 <span class="hljs-title class_">Array</span> 或者 <span class="hljs-title class_">Map</span>，而其他内置类型则不是（比如 <span class="hljs-title class_">Object</span>)）。要成为可迭代对象， 一个对象必须实现 @@iterator 方法。这意味着对象（或者它原型链上的某个对象）必须有一个键为 @@iterator 的属性，可通过常量 <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span> 访问该属性：当一个对象需要被迭代的时候（比如被置入一个 <span class="hljs-keyword">for</span>...<span class="hljs-keyword">of</span> 循环时），首先，会不带参数调用它的 @@iterator 方法，然后使用此方法返回的迭代器获得要迭代的值。<br>    <br>+迭代器协议<br>迭代器协议定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。<br>    只有实现了一个拥有以下语义（semantic）的 <span class="hljs-title function_">next</span>() 方法，一个对象才能成为迭代器：<br>    <span class="hljs-title function_">next</span>() 方法必须返回一个对象，该对象应当有两个属性： done（boolean） 和 value，如果返回了一个非对象值（比如 <span class="hljs-literal">false</span> 或 <span class="hljs-literal">undefined</span>），则会抛出一个 <span class="hljs-title class_">TypeError</span> 异常（<span class="hljs-string">&quot;iterator.next() returned a non-object value&quot;</span>）。<br>    <br>    <br>    目前所有的内置可迭代对象如下：<span class="hljs-title class_">String</span>、<span class="hljs-title class_">Array</span>、<span class="hljs-title class_">TypedArray</span>、<span class="hljs-title class_">Map</span> 和 <span class="hljs-title class_">Set</span>，它们的原型对象都实现了 @@<span class="hljs-string">``</span>iterator 方法。<br>    一些语句和表达式需要可迭代对象，比如 <span class="hljs-keyword">for</span>...<span class="hljs-keyword">of</span> 循环、展开语法、<span class="hljs-keyword">yield</span>*，和解构赋值。<br><br>+ 简单迭代器<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeIterator</span>(<span class="hljs-params">array</span>) &#123;<br>        <span class="hljs-keyword">let</span> nextIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> &#123;<br>           <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>               <span class="hljs-keyword">return</span> nextIndex &lt; array.<span class="hljs-property">length</span> ? &#123;<br>                   <span class="hljs-attr">value</span>: array[nextIndex++],<br>                   <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span><br>               &#125; : &#123;<br>                   <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span><br>               &#125;;<br>           &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> it = <span class="hljs-title function_">makeIterator</span>([<span class="hljs-string">&#x27;哟&#x27;</span>, <span class="hljs-string">&#x27;呀&#x27;</span>]);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &#x27;哟&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &#x27;呀&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(it.<span class="hljs-title function_">next</span>().<span class="hljs-property">done</span>);  <span class="hljs-comment">// true</span><br><br>++ 使用生成器<br>        <span class="hljs-keyword">function</span>* <span class="hljs-title function_">makeSimpleGenerator</span>(<span class="hljs-params">array</span>) &#123;<br>        <span class="hljs-keyword">let</span> nextIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(nextIndex &lt; array.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">yield</span> array[nextIndex++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">makeSimpleGenerator</span>([<span class="hljs-string">&#x27;哟&#x27;</span>, <span class="hljs-string">&#x27;呀&#x27;</span>]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &#x27;哟&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// &#x27;呀&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">done</span>);  <span class="hljs-comment">// true</span><br><br><br>    <span class="hljs-keyword">function</span>* <span class="hljs-title function_">idMaker</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">yield</span> index++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> gen = <span class="hljs-title function_">idMaker</span>();<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 0</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// ...</span><br><br>+++ <span class="hljs-keyword">class</span> 中的迭代器<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClass</span> &#123;<br>      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data<br>      &#125;<br><br>      [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-comment">// Use a new index for each iterator. This makes multiple</span><br>        <span class="hljs-comment">// iterations over the iterable safe for non-trivial cases,</span><br>        <span class="hljs-comment">// such as use of break or nested looping over the same iterable.</span><br>        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">next</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>) &#123;<br>              <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[index++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> simple = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleClass</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> val <span class="hljs-keyword">of</span> simple) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)   <span class="hljs-comment">// 1 2 3 4 5</span><br>    &#125;<br><br>++++  生成器对象既是迭代器，也是可迭代对象：<br>            <span class="hljs-keyword">let</span> aGeneratorObject = <span class="hljs-keyword">function</span>* ()&#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>        &#125;();<br><br>        <span class="hljs-keyword">typeof</span> aGeneratorObject.<span class="hljs-property">next</span>;<br>        <span class="hljs-comment">// 返回&quot;function&quot;, 因为有一个 next 方法，所以这是一个迭代器</span><br><br>        <span class="hljs-keyword">typeof</span> aGeneratorObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>];<br>        <span class="hljs-comment">// 返回&quot;function&quot;, 因为有一个 @@iterator 方法，所以这是一个可迭代对象</span><br><br>        aGeneratorObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() === aGeneratorObject;<br>        <span class="hljs-comment">// 返回 true，因为 @@iterator 方法返回自身（即迭代器），所以这是一个格式良好的可迭代对象</span><br><br>        [...aGeneratorObject];<br>        <span class="hljs-comment">// 返回 [1, 2, 3]</span><br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span> <span class="hljs-keyword">in</span> aGeneratorObject)<br>        <span class="hljs-comment">// 返回 true，因为 @@iterator 方法是 aGeneratorObject 的一个属性</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> authors = &#123;<br>  <span class="hljs-attr">allAuthors</span>: &#123;<br>    <span class="hljs-attr">fiction</span>: [<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;22&#x27;</span>, <span class="hljs-string">&#x27;33&#x27;</span>],<br>    <span class="hljs-attr">scienceFiction</span>: [<span class="hljs-string">&#x27;44&#x27;</span>, <span class="hljs-string">&#x27;55&#x27;</span>, <span class="hljs-string">&#x27;66&#x27;</span>,<span class="hljs-string">&#x27;77&#x27;</span>],<br>    <span class="hljs-attr">fantasy</span>: [<span class="hljs-string">&#x27;J.R.Tole&#x27;</span>, <span class="hljs-string">&#x27;J.M.R&#x27;</span>, <span class="hljs-string">&#x27;Terry P.K&#x27;</span>]<br>  &#125;,<br>&#125;<br><br><span class="hljs-comment">//生成器写法（本质也是生成一个可迭代对象）</span><br>authors[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>* ()&#123;<br>    <span class="hljs-keyword">let</span> allAuthors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">allAuthors</span>;<br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(allAuthors);<br>    <span class="hljs-keyword">let</span> valueOutput = [];<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!valueOutput.<span class="hljs-property">length</span>)&#123;<br>            <span class="hljs-comment">//首次执行或者valueOutput为空的时候进入</span><br>            <span class="hljs-comment">//获取keys[0] 赋值给valueOutput</span><br>            <span class="hljs-keyword">if</span>(keys.<span class="hljs-property">length</span>)&#123;<br>                valueOutput = allAuthors[keys[<span class="hljs-number">0</span>]];<br>                keys.<span class="hljs-title function_">shift</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// valueOutput   keys也空 退出迭代</span><br>            &#125;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//valueOutput不为空的时候进入逐个迭代，直至valueOutput为空</span><br>            <span class="hljs-keyword">yield</span> valueOutput.<span class="hljs-title function_">shift</span>();<br>            <br>        &#125;<br>    &#125;<br>    &#125;;<br><br><br><span class="hljs-comment">//可迭代对象写法</span><br>authors[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> allAuthors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">allAuthors</span>;<br>    <span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(allAuthors);<br>    <span class="hljs-keyword">let</span> valueOutput = [];<br><br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>(!valueOutput.<span class="hljs-property">length</span>)&#123;<br>                <span class="hljs-keyword">if</span>(keys.<span class="hljs-property">length</span>)&#123;<br>                    valueOutput=allAuthors[keys[<span class="hljs-number">0</span>]];<br>                    keys.<span class="hljs-title function_">shift</span>();<br>                &#125;<br>            &#125;<br>           <span class="hljs-keyword">return</span> &#123;<br>                    <span class="hljs-attr">done</span>:!valueOutput.<span class="hljs-property">length</span>,<br>                    <span class="hljs-attr">value</span>:valueOutput.<span class="hljs-title function_">shift</span>()<br>                &#125;            <br>        &#125;<br>    &#125;    <br>&#125;;<br><br><span class="hljs-keyword">let</span> r = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> authors)&#123;<br>    r.<span class="hljs-title function_">push</span>(p)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)<br></code></pre></td></tr></table></figure><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JS">建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。<br>函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。<br><br><span class="hljs-comment">/*-----export [test.js]-----*/</span><br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot;Tom&quot;</span>;<br><span class="hljs-comment">//也可以逐个输出 比如 export let myName = &quot;Tom&quot;;</span><br><span class="hljs-keyword">let</span> myAge = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> myfn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;My name is&quot;</span> + myName + <span class="hljs-string">&quot;! I&#x27;m &#x27;&quot;</span> + myAge + <span class="hljs-string">&quot;years old.&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> myClass =  <span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span> &#123;<br>    <span class="hljs-keyword">static</span> a = <span class="hljs-string">&quot;yeah!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> mydefalut =  <span class="hljs-keyword">class</span> <span class="hljs-title class_">mydefalut</span> &#123;<br>    <span class="hljs-keyword">static</span> a = <span class="hljs-string">&quot;defalut!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">export</span> defalut mydefalut<br><span class="hljs-keyword">export</span> &#123; myName, myAge, myfn, myClass &#125;<br> <br><span class="hljs-comment">/*-----import [xxx.js]-----*/</span><br><span class="hljs-keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myfn</span>());<span class="hljs-comment">// My name is Tom! I&#x27;m 20 years old.</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myAge);<span class="hljs-comment">// 20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<span class="hljs-comment">// Tom</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myClass.<span class="hljs-property">a</span> );<span class="hljs-comment">// yeah!</span><br><br><span class="hljs-comment">//使用as</span><br><span class="hljs-keyword">import</span> &#123; myName <span class="hljs-keyword">as</span> myName2, myAge, myfn, myClass &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName2);<span class="hljs-comment">// Tom</span><br><br><span class="hljs-comment">//使用*  接收全部</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">myName2</span>);<span class="hljs-comment">// Tom</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">defult</span>.<span class="hljs-property">myName2</span>);<span class="hljs-comment">// Tom</span><br><br><br>+<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 命令<br>在一个文件或模块中，<span class="hljs-keyword">export</span>、<span class="hljs-keyword">import</span> 可以有多个，<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 仅有一个。<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 中的 <span class="hljs-keyword">default</span> 是对应的导出接口变量。<br>通过 <span class="hljs-keyword">export</span> 方式导出，在导入时要加&#123; &#125;，<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 则不需要。<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 向外暴露的成员，可以使用任意变量来接收。<br><br></code></pre></td></tr></table></figure><h2 id="2-ES7-2016"><a href="#2-ES7-2016" class="headerlink" title="2.ES7(2016)"></a>2.ES7(2016)</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS">+ <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">includes</span><br><span class="hljs-comment">//判断数组中是否包含一个指定的值，根据情况如果包含则返回true，否则返回false</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">40</span>))  <br><br></code></pre></td></tr></table></figure><h3 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow"></a>Math.pow</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Math.pow() 函数返回基数（base）的指数（exponent）次幂，即 baseexponent</span><br><span class="hljs-comment">//ES7之前的写法</span><br><span class="hljs-keyword">const</span> x1 = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>)   <span class="hljs-comment">//2的8次方</span><br><span class="hljs-comment">//ES7的写法</span><br><span class="hljs-keyword">const</span> x2 = <span class="hljs-number">2</span>**<span class="hljs-number">8</span><br><br><br></code></pre></td></tr></table></figure><h2 id="3-ES8-2017"><a href="#3-ES8-2017" class="headerlink" title="3.ES8(2017)"></a>3.ES8(2017)</h2><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>+ <span class="hljs-keyword">async</span> 函数显式返回的不是 <span class="hljs-title class_">Promise</span> 的话，会自动包装成 <span class="hljs-title class_">Promise</span> 对象<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">firstAsync</span> () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">27</span>  <span class="hljs-comment">//等同于  return Promise.resolve(27)</span><br>    &#125;<br>    <span class="hljs-title function_">firstAsync</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 27</span><br><br>+<span class="hljs-keyword">await</span> 后面一定是 <span class="hljs-title class_">Promise</span> 对象，如果不是会自动包装成 <span class="hljs-title class_">Promise</span> 对象<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">firstAsync</span> () &#123;<br>      <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;now it is done&#x27;</span>)<br>        &#125;, <span class="hljs-number">1000</span>)<br>      &#125;)<br><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> promise)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">40</span>))<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">firstAsync</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(’done‘)<br>    &#125;)<br><br><span class="hljs-comment">//输出  &#x27;now it is done&#x27;   40  2  3  ’done‘</span><br><br></code></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JS">+<span class="hljs-title class_">Object</span>.<span class="hljs-property">values</span><br><span class="hljs-comment">//返回给定对象自身可枚举值的数组。</span><br>+<span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span><br><span class="hljs-comment">//返回一个包含所有给定对象自身可枚举属性名称的数组。</span><br>+<span class="hljs-title class_">Object</span>.<span class="hljs-property">entries</span><br>    <span class="hljs-comment">//返回给定对象自身可枚举属性的[key, value]数组。//一级属性</span><br>    <span class="hljs-comment">//new Map() 构造函数接受一个可迭代的entries。</span><br>    <span class="hljs-comment">//借助Object.entries方法你可以很容易的将Object转换为Map:</span><br>        <span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> &#125;;<br>        <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj));<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map); <span class="hljs-comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br>+<span class="hljs-title class_">Object</span>.<span class="hljs-property">getOwnPropertyDescriptor</span><br><span class="hljs-comment">//返回对象指定的属性配置。如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</span><br><span class="hljs-comment">//属性配置  value/writeable/get/set/configurable</span><br><span class="hljs-comment">//Object.getOwnPropertyDescriptors(obj) 方法用来获取一个对象的所有自身属性的描述符。</span><br>  -逆向操作是<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, prop, descriptor)<br>    <span class="hljs-comment">//给对象添加一个属性并指定该属性的配置。</span><br>    <span class="hljs-comment">//descriptor 要定义或修改的属性描述符。</span><br><br></code></pre></td></tr></table></figure><h3 id="String-padding"><a href="#String-padding" class="headerlink" title="String padding"></a>String padding</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">i.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;*#&#x27;</span>)   <span class="hljs-comment">//固定字符串长度为5位 不足则起始位用*#补齐，如*#*#1  *#*02  *#003  *0004</span><br>i.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;*#&#x27;</span>)   <span class="hljs-comment">//固定字符串长度为5位 不足则结束位用*#补齐</span><br></code></pre></td></tr></table></figure><h2 id="4-ES9-2018"><a href="#4-ES9-2018" class="headerlink" title="4.ES9 (2018)"></a>4.ES9 (2018)</h2><h3 id="for-await-of"><a href="#for-await-of" class="headerlink" title="for await of"></a>for await of</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Gen</span> (time) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">resolve</span>(time)<br>    &#125;, time)<br>  &#125;)<br>&#125;<br><br>+ 正常遍历(同步操作)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> () &#123;<br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-title class_">Gen</span>(<span class="hljs-number">2000</span>), <span class="hljs-title class_">Gen</span>(<span class="hljs-number">100</span>), <span class="hljs-title class_">Gen</span>(<span class="hljs-number">3000</span>)]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), item.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>))<br>  &#125;<br>&#125;<br><span class="hljs-title function_">test</span>()<br><span class="hljs-comment">//执行顺序  先执行for of循环 第一个item  执行Date.now(),item.then返回一个promise实例，此时promise状态为pending；</span><br><span class="hljs-comment">//重复其余for of循环 注意for of循环的事件很短 很快就完成了</span><br><span class="hljs-comment">//每个promise实例依次完成resolve，执行promise.then(console.log)</span><br><br>+普通异步函数<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> () &#123;<br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-title class_">Gen</span>(<span class="hljs-number">2000</span>), <span class="hljs-title class_">Gen</span>(<span class="hljs-number">100</span>), <span class="hljs-title class_">Gen</span>(<span class="hljs-number">3000</span>)]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), <span class="hljs-keyword">await</span> item.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;66&#x27;</span>)))<br>  &#125;<br>&#125;<br><span class="hljs-title function_">test</span>()<br><span class="hljs-comment">//先执行for of循环  第一个item  读取到Date.now(), await item.then(console.log)</span><br><span class="hljs-comment">//需要先执行await异步操作  item返回一个promise实例 且该实例是resoved的  且需要异步操作 此时then被调用</span><br><span class="hljs-comment">//执行语句 console.log(&#x27;66&#x27;)   输出66</span><br><span class="hljs-comment">//promise实例的resove执行完毕 value返回2000， 及await接收到返回值2000 ，此时输出 console.log(Date.now(), 2000)</span><br><span class="hljs-comment">//其他同理</span><br><br><br>+<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">of</span> 写法<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> () &#123;<br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-title class_">Gen</span>(<span class="hljs-number">2000</span>), <span class="hljs-title class_">Gen</span>(<span class="hljs-number">100</span>), <span class="hljs-title class_">Gen</span>(<span class="hljs-number">3000</span>)]<br>  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), item)<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">test</span>()<br><br><span class="hljs-comment">//for await读取到item 执行函数体 console.log(xxx)</span><br><span class="hljs-comment">//其中item在未成功返回之前 才会进入下一次的循环</span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">+自定义异步数据增加可迭代协议<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-title class_">Gen</span> (time) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123; <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: time &#125;)<br>      &#125;, time)<br>    &#125;)<br>  &#125;,<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>] () &#123;<br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      next () &#123;<br>        self.<span class="hljs-property">count</span>++<br>        <span class="hljs-keyword">if</span> (self.<span class="hljs-property">count</span> &lt; <span class="hljs-number">4</span>) &#123;<br>          <span class="hljs-keyword">return</span> self.<span class="hljs-title class_">Gen</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(&#123;<br>            <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span><br>          &#125;)<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span> () &#123;<br>  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> obj) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(), item)<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">test</span>()<br></code></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Gen</span> = (<span class="hljs-params">time</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (time &lt; <span class="hljs-number">500</span>) &#123;<br>        <span class="hljs-title function_">reject</span>(time)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(time)<br>      &#125;<br>    &#125;, time)<br>  &#125;)<br>&#125;<br><br><span class="hljs-title class_">Gen</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">1000</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, val))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject&#x27;</span>, err))<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finish&#x27;</span>) &#125;)<br><br></code></pre></td></tr></table></figure><h3 id="Object-Rest-Spread"><a href="#Object-Rest-Spread" class="headerlink" title="Object Rest Spread"></a>Object Rest Spread</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">const</span> test = &#123;<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">const</span> output = &#123;<br>  ...input,<br>  ...test,<br>  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input, output)<br><br><span class="hljs-comment">//浅复制 不是引用所以不会引起修改</span><br>input.<span class="hljs-property">a</span> = <span class="hljs-number">4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input, output)<br><br><span class="hljs-keyword">const</span> input = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attr">e</span>: <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; a, b, ...rest &#125; = input<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, rest)<br><br></code></pre></td></tr></table></figure><h3 id="RegExp-Updates"><a href="#RegExp-Updates" class="headerlink" title="RegExp Updates"></a>RegExp Updates</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js">+dotAll<br>    dotAll 属性表明是否在正则表达式中一起使用<span class="hljs-string">&quot;s&quot;</span>修饰符（引入/s 修饰符，使得。可以匹配任意单个字符）。<br>    dotAll 是一个只读的属性，属于单个正则表达式实例。<br>    <span class="hljs-string">&quot;s&quot;</span>修饰符表示，特殊字符<span class="hljs-string">&quot;.&quot;</span>应另外匹配字符串中的下述行终结符（line terminator characters），否则将会失配：<br>        U+000A 换行符（<span class="hljs-string">&quot;\n&quot;</span>）<br>        U+000D 回车符（<span class="hljs-string">&quot;\r&quot;</span>）<br>        U+<span class="hljs-number">2028</span> 行分隔符（line separator）<br>        U+<span class="hljs-number">2029</span> 段分隔符（paragraph separator）<br>    这实际上意味着<span class="hljs-string">&quot;.&quot;</span>将会匹配任意的单个 <span class="hljs-title class_">Unicode</span> <span class="hljs-title class_">Basic</span> <span class="hljs-title class_">Multilingual</span> <span class="hljs-title class_">Plane</span> (<span class="hljs-variable constant_">BMP</span>) 字符。若要使其与 astral 字符（大于 \uFFFF 的 <span class="hljs-title class_">Unicode</span> 字符）匹配，你应当使用<span class="hljs-string">&quot;u&quot;</span>（<span class="hljs-title class_">Unicode</span>）修饰符。一起使用这两个修饰符，<span class="hljs-string">&quot;.&quot;</span>将无一例外地匹配任意 <span class="hljs-title class_">Unicode</span> 字符。<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/foo.bar/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;foo\nbar&#x27;</span>))  <br>    <span class="hljs-comment">// 返回false    默认情况下的任意字符’.‘ 并不任意匹配 </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/foo.bar/u</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;foo\nbar&#x27;</span>))  <br>    <span class="hljs-comment">// 返回false   unicode编码模式也无效</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-regexp">/foo.bar/</span>s.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;foo\nbar&#x27;</span>))<br>    <span class="hljs-comment">//返回true</span><br>    <span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/foo.bar/</span>sugi<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">dotAll</span>)   <span class="hljs-comment">//返回true</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re.<span class="hljs-property">flags</span>)  <span class="hljs-comment">//返回sugi</span><br><br><br>+命名分组捕获<br>    <span class="hljs-keyword">const</span> t = <span class="hljs-string">&#x27;2022-08-20&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t[<span class="hljs-number">1</span>])  <span class="hljs-comment">//2022</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t[<span class="hljs-number">2</span>])  <span class="hljs-comment">//08 </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t[<span class="hljs-number">3</span>])  <span class="hljs-comment">//20</span><br><br>    <span class="hljs-comment">//如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</span><br>    <span class="hljs-comment">//如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。</span><br>    <span class="hljs-comment">//捕获组参照上述内容  一个正则语句内有多个捕获条件</span><br><br>    <span class="hljs-comment">//groups: 一个命名捕获组对象，其键是捕获组名称，值是捕获组，如果未定义命名捕获组，则为 undefined。有关详细信息，请参阅组和范围。</span><br>    <span class="hljs-comment">//index: 匹配的结果的开始位置</span><br>    <span class="hljs-comment">//input: 搜索的字符串。</span><br>    -捕获组命名<br>        <span class="hljs-keyword">const</span> t = <span class="hljs-string">&#x27;2019-06-07&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t.<span class="hljs-property">groups</span>.<span class="hljs-property">year</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t.<span class="hljs-property">groups</span>.<span class="hljs-property">month</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t.<span class="hljs-property">groups</span>.<span class="hljs-property">day</span>)<br><br>+后行断言<br><br>    <span class="hljs-keyword">let</span> test = <span class="hljs-string">&#x27;hello world&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/hello(?=\sworld)/</span>))<span class="hljs-comment">//正常先行断言 查到找hello后匹配后面的捕获内容</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(?&lt;!helle\s)world/</span>))<span class="hljs-comment">//新增后行断言 查到找world后匹配后面的捕获内容</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">标志描述<br>g全局搜索。<br>i不区分大小写搜索。<br>m多行搜索。<br>s允许 . 匹配换行符。<br>u使用 unicode 码的模式进行匹配。<br>y执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。<br></code></pre></td></tr></table></figure><h2 id="5-ES10-2019"><a href="#5-ES10-2019" class="headerlink" title="5.ES10(2019)"></a>5.ES10(2019)</h2><h3 id="Array-1"><a href="#Array-1" class="headerlink" title="Array"></a>Array</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flat</span><br>    <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">22</span>, <span class="hljs-number">33</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>]]]]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>())  <span class="hljs-comment">//[1, 22, 33, 4, 5, Array(3)]  默认扁平化一级</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>))  <span class="hljs-comment">// [1, 22, 33, 4, 5, 6, 7, Array(2)]   8 9 需要flat（3）才能展开 就看数据对应左侧距离‘，’有几个中括号就是几级</span><br><br>+<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">flatmap</span>（<span class="hljs-keyword">function</span>）<br><span class="hljs-comment">//只能针对一维数组 嵌套数组无法执行</span><br>    <span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> [item * <span class="hljs-number">2</span>]).<span class="hljs-title function_">flat</span>())<span class="hljs-comment">//[2, 4, 6]</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> [item * <span class="hljs-number">2</span>]))<span class="hljs-comment">//[2, 4, 6]</span><br><span class="hljs-comment">//map是个伪数组</span><br><br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">trimStart</span>  <span class="hljs-comment">//去掉字符串起始空格</span><br>+<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">trimEnd</span>   <span class="hljs-comment">//去掉字符串结束处空格</span><br>+<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">trim</span>    <span class="hljs-comment">//去掉首尾空格字符</span><br>+<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">matchAll</span>(regexp)<br><span class="hljs-comment">//返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">select</span> (regExp, str) &#123;<br>      <span class="hljs-keyword">const</span> matches = []<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> str.<span class="hljs-title function_">matchAll</span>(regExp)) &#123;<br>        matches.<span class="hljs-title function_">push</span>(match[<span class="hljs-number">1</span>])<br>      &#125;<br>      <span class="hljs-keyword">return</span> matches<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">select</span>(<span class="hljs-regexp">/&quot;([^&quot;]*)&quot;/g</span>, str))<br><span class="hljs-comment">//如果使用 matchAll ，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用 /g 标志）。使用 matchAll 会得到一个迭代器的返回值，配合 for...of, array spread, 或者 Array.from() 可以更方便实现功能.如果没有 /g 标志，matchAll 会抛出异常。</span><br></code></pre></td></tr></table></figure><h3 id="Object-1"><a href="#Object-1" class="headerlink" title="Object"></a>Object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">const</span> arr = [[<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">2</span>]]<br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(arr)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">bar</span>)<br><br>    <span class="hljs-keyword">const</span> obj = &#123;<br>      <span class="hljs-attr">abc</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">def</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">ghksks</span>: <span class="hljs-number">3</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">[key, val]</span>) =&gt;</span> key.<span class="hljs-property">length</span> === <span class="hljs-number">3</span>)<br>    )<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br></code></pre></td></tr></table></figure><h2 id="6-ES11-2020"><a href="#6-ES11-2020" class="headerlink" title="6.ES11(2020)"></a>6.ES11(2020)</h2><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-keyword">class</span>  的私有属性需要在其前面加#，无法在外部通过静态方法调用，只能在<span class="hljs-keyword">class</span> 内部调用 <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>            <span class="hljs-comment">//公有属性</span><br>            name;<br>            <span class="hljs-comment">//私有属性  </span><br>            #age;<br>            #weight;<br>            <span class="hljs-comment">//构造方法</span><br>            <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, weight</span>)&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>                <span class="hljs-variable language_">this</span>.#age = age;<br>                <span class="hljs-variable language_">this</span>.#weight = weight;<br>            &#125;<br><br>            <span class="hljs-title function_">intro</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#age);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#weight);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//实例化</span><br>        <span class="hljs-keyword">const</span> girl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;晓红&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;45kg&#x27;</span>);<br><br>        <span class="hljs-comment">// console.log(girl.name);</span><br>        <span class="hljs-comment">// console.log(girl.#age);</span><br>        <span class="hljs-comment">// console.log(girl.#weight);</span><br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span>  接收一个数组参数，数组元素均为promise对象<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span> 返回一个promise实例，<br>[[<span class="hljs-title class_">PromiseState</span>]]: <span class="hljs-string">&quot;fulfilled&quot;</span> 状态固定为已完成<br>    [[<span class="hljs-title class_">PromiseResult</span>]]:<span class="hljs-title class_">Array</span>   <span class="hljs-comment">//返回内容是数组中promise对象的执行状态</span><br><br><br><br><span class="hljs-comment">//声明两个promise对象</span><br>        <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;商品数据 - 1&#x27;</span>);<br>            &#125;,<span class="hljs-number">1000</span>)<br>        &#125;);<br><br>        <span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-comment">//resolve(&#x27;商品数据 - 2&#x27;);</span><br>                <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错啦!&#x27;</span>);<br>            &#125;,<span class="hljs-number">1000</span>)<br>        &#125;);<br><br>        <span class="hljs-comment">//调用 allsettled 方法</span><br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1, p2]);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">//[[PromiseState]]: &quot;fulfilled&quot;</span><br><br>        <br>        <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2]);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>[[<span class="hljs-title class_">PromiseState</span>]]: <span class="hljs-string">&quot;rejected&quot;</span><br></code></pre></td></tr></table></figure><h3 id="String-prototype-matchALL"><a href="#String-prototype-matchALL" class="headerlink" title="String.prototype.matchALL"></a>String.prototype.matchALL</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">matchALL</span>（<span class="hljs-title class_">RegExp</span>）<br>正则批量匹配，返回一个可迭代的对象<br>        <span class="hljs-keyword">let</span> str = <span class="hljs-string">`&lt;ul&gt;</span><br><span class="hljs-string">            &lt;li&gt;</span><br><span class="hljs-string">                &lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="hljs-string">                &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;</span><br><span class="hljs-string">            &lt;/li&gt;</span><br><span class="hljs-string">            &lt;li&gt;</span><br><span class="hljs-string">                &lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="hljs-string">                &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;</span><br><span class="hljs-string">            &lt;/li&gt;</span><br><span class="hljs-string">        &lt;/ul&gt;`</span>;<br><br>        <span class="hljs-comment">//声明正则</span><br>        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/</span>sg<br><br>        <span class="hljs-comment">//调用方法</span><br>        <span class="hljs-keyword">const</span> result = str.<span class="hljs-title function_">matchAll</span>(reg); <span class="hljs-comment">//返回一个可迭代对象  RegExpStringIterator</span><br><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> result)&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);   &#125;<br><span class="hljs-comment">// v是一个对象   第一个v是下面内容  0是匹配正则的语句，1~2是捕获组（可能未定义的内容）</span><br>                    <span class="hljs-number">0</span>: <span class="hljs-string">&quot;&lt;li&gt;\n &lt;a&gt;肖生克的救赎&lt;/a&gt;\n &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;&quot;</span><br>                    <span class="hljs-number">1</span>: <span class="hljs-string">&quot;肖生克的救赎&quot;</span><br>                    <span class="hljs-number">2</span>: <span class="hljs-string">&quot;上映日期: 1994-09-10&quot;</span><br>                    <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span><br>                    <span class="hljs-attr">index</span>: <span class="hljs-number">17</span><br>                    <span class="hljs-attr">input</span>: <span class="hljs-comment">//就是整个str</span><br>                    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br><br>        <span class="hljs-keyword">const</span> arr = [...result];<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br><br></code></pre></td></tr></table></figure><h3 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">+可选链就是一个问号？   <br>比如   a.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>  如果a或者b是<span class="hljs-literal">undefined</span>的情况下  读取c则会报错   不能再一个<span class="hljs-literal">undefined</span>的对象上读取属性<br>此时如果用可选链  a?.<span class="hljs-property">b</span>?.<span class="hljs-property">c</span>   此时无论a或b是否存在，c都会不会报错，如果a或b为<span class="hljs-literal">undefined</span>，则此时c返回<span class="hljs-literal">undefined</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">config</span>)&#123;<br>            <span class="hljs-comment">//  之前的写法  需要判断是否存在</span><br>            <span class="hljs-comment">//均为真返回最后一个结果  </span><br>            <span class="hljs-comment">//const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host;   </span><br>            <span class="hljs-keyword">const</span> dbHost = config?.<span class="hljs-property">db</span>?.<span class="hljs-property">host</span>;<br><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dbHost);<br>        &#125;<br><br>        <span class="hljs-title function_">main</span>(&#123;<br>            <span class="hljs-attr">db</span>: &#123;<br>                <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;192.168.1.100&#x27;</span>,<br>                <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">cache</span>: &#123;<br>                <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;192.168.1.200&#x27;</span>,<br>                <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;admin&#x27;</span><br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="动态import"><a href="#动态import" class="headerlink" title="动态import"></a>动态import</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">import</span> (<span class="hljs-string">&#x27;.xxx.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span>=&gt;</span>&#123;<br>        <span class="hljs-variable language_">module</span>.<span class="hljs-property">xxxx</span>  <span class="hljs-comment">//调用模块中的方法等</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-ES12-2021"><a href="#7-ES12-2021" class="headerlink" title="7.ES12(2021)"></a>7.ES12(2021)</h2><h3 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll"></a>String.prototype.replaceAll</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">+把字符串中符合的内容全部替换    之前的方法需要使用正则且开启全局匹配<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">S1</span>=<span class="hljs-string">&#x27;A cat sit on the  cat mat&#x27;</span>;<br>    <span class="hljs-keyword">const</span> output1=<span class="hljs-variable constant_">S1</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>);<br>    <span class="hljs-keyword">const</span> output2=<span class="hljs-variable constant_">S1</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/cat/</span>,<span class="hljs-string">&#x27;dog&#x27;</span>);<br>    <span class="hljs-keyword">const</span> output3=<span class="hljs-variable constant_">S1</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/cat/g</span>,<span class="hljs-string">&#x27;dog&#x27;</span>);<br>    <span class="hljs-keyword">const</span> output4=<span class="hljs-variable constant_">S1</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output1);  <span class="hljs-comment">//A dog sit on the  cat mat</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output2);  <span class="hljs-comment">//A dog sit on the  cat mat</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output3);  <span class="hljs-comment">//A dog sit on the  dog mat</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output4);  <span class="hljs-comment">//A dog sit on the  dog mat</span><br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">+<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>() 接收一个由 <span class="hljs-title class_">Promise</span> 所组成的可迭代对象，该方法会返回一个新的 promise，一旦可迭代对象内的任意一个 promise 变成了兑现状态，那么由该方法所返回的 promise 就会变成兑现状态，并且它的兑现值就是可迭代对象内的首先兑现的 promise 的兑现值。如果可迭代对象内的 promise 最终都没有兑现（即所有 promise 都被拒绝了），那么该方法所返回的 promise 就会变成拒绝状态，并且它的拒因会是一个 <span class="hljs-title class_">AggregateError</span> 实例，这是 <span class="hljs-title class_">Error</span> 的子类，用于把单一的错误集合在一起。<br><br><br>+promise.<span class="hljs-title function_">race</span>()的区别<br> promise.<span class="hljs-title function_">race</span>()关注的是哪个promise对象先行返回（无论promise状态）；promise.<span class="hljs-title function_">any</span>()关注的是第一个返回的resolve的对象<br>    <br>        <span class="hljs-keyword">const</span> pErr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;总是失败&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">const</span> pSlow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&quot;最终完成&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">const</span> pFast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;很快完成&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([pErr, pSlow, pFast]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);    <span class="hljs-comment">// pFa &#x27;&#x27;很快完成&quot;</span><br>            <br>         <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([pErr, pSlow, pFast]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);    <span class="hljs-comment">// &quot;总是失败&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Logical-Assignment-Operators"><a href="#Logical-Assignment-Operators" class="headerlink" title="Logical Assignment Operators"></a>Logical Assignment Operators</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">+就是个语法糖<br>a || = b，如果a为<span class="hljs-literal">false</span>，则把b赋值给a，实际编译就是a|| (a=b)<br>a &amp;&amp; = b，如果a b均为<span class="hljs-literal">true</span> ，则把b赋值给a，实际编译就是 a&amp;&amp; (a=b)<br></code></pre></td></tr></table></figure><h3 id="Number-Separators（数值分隔符）"><a href="#Number-Separators（数值分隔符）" class="headerlink" title="Number Separators（数值分隔符）"></a>Number Separators（数值分隔符）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">在数据类型中增加下划线_辅助阅读<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10000000000</span> === <span class="hljs-number">10_000_000_000</span>)    <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6-ES12</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript原型原型链</title>
    <link href="/2022/09/02/JavaScript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/09/02/JavaScript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript原型原型链"><a href="#JavaScript原型原型链" class="headerlink" title="JavaScript原型原型链"></a>JavaScript原型原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在 JavaScript 中，对象有一个特殊的隐藏属性 <code>[[Prototype]]</code>，它要么为 <code>null</code>，要么就是对另一个对象的引用，该对象被称为“原型”。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p><strong>当我们从对象中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。</strong> 在编程中，这种行为被称为“原型继承”。</p><p>对象实例并没有<code>toString</code>方法，对象原型Object上有<code>toString</code>方法，看到<code>toString</code>方法就是原型链到头了</p><h2 id="设置原型的三种方法"><a href="#设置原型的三种方法" class="headerlink" title="设置原型的三种方法"></a>设置原型的三种方法</h2><h3 id="1-proto-隐式原型"><a href="#1-proto-隐式原型" class="headerlink" title="1.__proto__ (隐式原型)"></a>1.<code>__proto__</code> (隐式原型)</h3><p>使用特殊的名字 <code>__proto__</code>，在现代JavaScript中，<code>__proto__</code> 是可读可写的。</p><ul><li><p>原型链不能形成闭环。</p></li><li><p><code>__proto__</code>的值只能是对象或者<code>null</code>，其他的类型都会被忽略。</p></li><li><p>一个对象不能从其他两个对象获得继承。一个对象只能有一个 <code>[[Prototype]]</code>。</p></li><li><p><code>_proto__</code> 与内部的 <code>[[Prototype]]</code> <strong>不一样</strong>。<code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter&#x2F;setter。</p></li></ul><h3 id="2-Object-setPrototypeOf"><a href="#2-Object-setPrototypeOf" class="headerlink" title="2.Object.setPrototypeOf()"></a>2.<code>Object.setPrototypeOf()</code></h3><p>尽管连node也支持<code>__proto__</code>这种写法，但是我们应该使用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>来替代。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>&#125;;<br><span class="hljs-keyword">let</span> rabbit = &#123;<span class="hljs-attr">jumps</span>:<span class="hljs-literal">true</span>&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(rabbit,animal); <span class="hljs-comment">//将animal设置为rabbit的原型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit);  <span class="hljs-comment">//rabbit可以通过原型链访问到eats属性</span><br></code></pre></td></tr></table></figure><h3 id="3-Object-create-proto"><a href="#3-Object-create-proto" class="headerlink" title="3.Object.create(proto)"></a>3.Object.create(proto)</h3><p>使用<code>Object.create(proto)</code>，用给定的 <code>proto</code> 作为原型创建一个空对象。</p><p>我们使用对象字面量或者Object构造函数创建的对象会默认继承自<code>Object.prototype</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>&#125;;<br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal); <span class="hljs-comment">//让animal作为rabbit的原型</span><br></code></pre></td></tr></table></figure><h2 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h2><h3 id="常规prototype"><a href="#常规prototype" class="headerlink" title="常规prototype"></a>常规prototype</h3><p>通过<code>new 构造函数名()</code>来创建一个新的对象。在这里，将构造函数名简写为<code>F</code>，也即 <code>new F()</code>。</p><p>其实不仅构造函数，任何函数都有 <code>prototype</code> 属性，即使我们没有提供它。</p><p><strong>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</strong></p><p>这里的 <code>F.prototype</code> 指的是 <code>F</code> 的一个名为 <code>&quot;prototype&quot;</code> 的常规属性。这听起来与“原型”这个术语很类似，但这里我们实际上指的是具有该名字的常规属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> animal = &#123;<span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params">name</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// 将Rabbit函数的prototype属性值设置为animal对象</span><br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal;<br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(<span class="hljs-string">&quot;White Rabbit&quot;</span>);<br><span class="hljs-comment">// rabbit.__proto__ == animal</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit.<span class="hljs-property">eats</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>设置 <code>Rabbit.prototype = animal</code> 的字面意思是：“当创建了一个 <code>new Rabbit</code> 时，把它的 <code>[[Prototype]]</code> 赋值为 <code>animal</code>”。</p><p><code>F.prototype</code> 属性仅在 <code>new F</code> 被调用时使用，它为新对象的 <code>[[Prototype]]</code> 赋值。</p><p>如果在创建之后，<code>F.prototype</code> 属性有了变化（<code>F.prototype = &lt;another object&gt;</code>），那么通过 <code>new F</code> 创建的新对象也将随之拥有新的对象作为 <code>[[Prototype]]</code>，但已经存在的对象将保持旧有的值。</p><h3 id="默认prototype"><a href="#默认prototype" class="headerlink" title="默认prototype"></a>默认prototype</h3><p>每个函数都有<code>prototype</code>属性，默认的 <code>&quot;prototype&quot;</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">Rabbit</span> =&#123;<br>prototype：&#123;<br>constructor：<span class="hljs-title class_">Rabbit</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//如果我们什么都不做，constructor 属性可以通过 [[Prototype]] 给所有 rabbits 使用：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// by default:</span><br><span class="hljs-comment">// Rabbit.prototype = &#123; constructor: Rabbit &#125; </span><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(); <span class="hljs-comment">// 继承自&#123;constructor: Rabbit&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Rabbit</span>); <span class="hljs-comment">// true (from prototype)</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//我们可以使用 `constructor` 属性来创建一个新对象，该对象使用与现有对象相同的构造器。因为新创建的对象继承的constuctor指向原来的构造函数！</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params">name</span>) &#123; <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br><span class="hljs-title function_">alert</span>(name);<br>&#125; <br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <br><span class="hljs-keyword">let</span> rabbit2 = <span class="hljs-keyword">new</span> rabbit.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">&quot;Black Rabbit&quot;</span></span>);<br><br><span class="hljs-comment">//JavaScript 自身并不能确保正确的 &quot;constructor&quot; 函数值。</span><br><br><span class="hljs-comment">//比如我们如果将函数的prototype属性直接替换掉，那就不会存在constructor属性。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rabbit</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>&#125;;<br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rabbit</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rabbit.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Rabbit</span>); <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//此时JS 会好给原型添加一个constructor属性，而且 constructor会指向 Object 构造函数。</span><br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>  ===object<br><br><span class="hljs-comment">//因此我们就不能依靠 constructor 辨别创建的对象类型了。虽然，instanceOf 还是能可靠地返回对象的类型。</span><br>rebbit <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Rabbit</span>  <span class="hljs-comment">//true</span><br>rabbit.<span class="hljs-property">constructor</span> ===<span class="hljs-title class_">Rabbit</span>  <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//为了确保正确的 &quot;constructor&quot;，我们可以选择添加/删除属性到默认 &quot;prototype&quot;，而不是将其整个覆盖，或者手动重新创建</span><br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">jumps</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123; <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Rabbit</span>&#125;;<br><span class="hljs-comment">// 默认的 Rabbit.prototype.constructor 被保留了下来</span><br><br><span class="hljs-comment">//这种手动添加 constructor 属性也有一点小问题，那就是原生的 constructor 属性是不可枚举的。而这种直接添加的方法，constructor 属性是可枚举的，也即Enumerable属性为true。所以，我们应该使用 Object.defineProperty() 方法来添加 constructor属性。</span><br><br><span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">jumps</span>:<span class="hljs-literal">true</span>&#125;;<br><span class="hljs-comment">// 给Rabbit.prototype 添加 constructor属性，其值指向Rabbit函数且不可枚举</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Rabbit</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<span class="hljs-string">&#x27;constructor&#x27;</span>,&#123;<br><span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">value</span>: <span class="hljs-title class_">Rabbit</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p><code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建新对象</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">//默认进行了</span><br>obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>另外 <code>Object.prototype</code> 上方的链中没有更多的 <code>[[Prototype]]</code>。也不能给<code>Object.prototype</code>继续设置原型对象了（会报错）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>   <span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure><h2 id="其他内建对象prototype"><a href="#其他内建对象prototype" class="headerlink" title="其他内建对象prototype"></a>其他内建对象prototype</h2><p>其他内建对象，像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</p><p>例如，当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p><p>按照规范，所有的内建原型顶端都是 <code>Object.prototype</code>。这就是为什么有人说“一切都从对象继承而来”。</p><p><a href='https://jiaqicoder.com/2021/07/31/%E5%9B%BE%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/' >本文出处</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型链</tag>
      
      <tag>prototype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记(基于ES5)</title>
    <link href="/2022/08/31/JavaScript%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8EES5/"/>
    <url>/2022/08/31/JavaScript%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8EES5/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript笔记-基于ES5"><a href="#JavaScript笔记-基于ES5" class="headerlink" title="JavaScript笔记(基于ES5)"></a>JavaScript笔记(基于ES5)</h1><h2 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h2><h3 id="1-对象（Object）"><a href="#1-对象（Object）" class="headerlink" title="1.对象（Object）"></a>1.对象（Object）</h3><pre><code class="hljs">- 对象是JS中的引用数据类型- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性- 使用typeof检查一个对象时，会返回object- 创建对象    - 方式一：        - var obj = new Object();    - 方式二：        - var obj = &#123;&#125;;- 向对象中添加属性    - 语法：        对象.属性名 = 属性值;        对象[&quot;属性名&quot;] = 属性值;                - 对象的属性名没有任何要求，不需要遵守标识符的规范，            但是在开发中，尽量按照标识符的要求去写。        - 属性值也可以任意的数据类型。- 读取对象中的属性    - 语法：        对象.属性名        对象[&quot;属性名&quot;]    - 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined    - 删除对象中的属性    - 语法：        delete 对象.属性名        delete 对象[&quot;属性名&quot;]        - 使用in检查对象中是否含有指定属性    - 语法：&quot;属性名&quot; in 对象        - 如果在对象中含有该属性，则返回true            如果没有则返回false            - 使用对象字面量，在创建对象时直接向对象中添加属性    语法：        var obj = &#123;                        属性名:属性值,                        属性名:属性值,                        属性名:属性值,                        属性名:属性值                &#125;                - 基本数据类型和引用数据类型    - 基本数据类型        String Number Boolean Null Undefined    - 引用数据类型        Object    - 基本数据类型的数据，变量是直接保存的它的值。        变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。    - 引用数据类型的数据，变量是保存的对象的引用（内存地址）。        如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。    - 比较两个变量时，对于基本数据类型，比较的就是值，        对于引用数据类型比较的是地址，地址相同才相同</code></pre><h3 id="2-函数（Function）"><a href="#2-函数（Function）" class="headerlink" title="2.函数（Function）"></a>2.函数（Function）</h3><pre><code class="hljs">- 函数也是一个对象，也具有普通对象的功能- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码- 使用typeof检查一个函数时会返回function- 创建函数    - 函数声明        function 函数名([形参1,形参2...形参N])&#123;            语句...        &#125;    - 函数表达式        var 函数名 = function([形参1,形参2...形参N])&#123;            语句...        &#125;;        - 调用函数    - 语法：函数对象([实参1,实参2...实参N]);        fun() sum() alert() Number() parseInt()    - 当我们调用函数时，函数中封装的代码会按照编写的顺序执行- 形参和实参    - 形参：形式参数        - 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开            定义形参就相当于在函数内声明了对应的变量但是并不赋值，            形参会在调用时才赋值。                - 实参：实际参数        - 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,            调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。            如果实参的数量大于形参，多余实参将不会赋值，            如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined    - 返回值，就是函数执行的结果。        - 使用return 来设置函数的返回值。        - 语法：return 值;            - 该值就会成为函数的返回值，可以通过一个变量来接收返回值        - return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。        - return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。        - 如果return后不跟值，或者是不写return则函数默认返回undefined。        - break、continue和return            - break                - 退出循环            - continue                - 跳过当次循环            - return                - 退出函数                    - 参数，函数的实参也可以是任意的数据类型。    - 在调用函数时，浏览器每次都会传递进两个隐含的参数        1.函数的上下文对象this        2.封装实参的对象arguments            arguments是一个类数组对象，            在调用函数的时候，我们所传递的实参都会在arguments中保存            arguments.length可以用来获取实参的长度    - 方法（method）        - 可以将一个函数设置为一个对象的属性，            当一个对象的属性是一个函数时，                我们称这个函数是该对象的方法。        - 对象.方法名();        - 函数名();    - call()    - apply()        - 这两个方法都是函数对象的方法需要通过函数对象来调用        - 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this        fun.call(obj)  执行的时候fun中的this就是obj，有点类似于obj.fun        - 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递        call(obj,a,b)        apply([obj,a,b])    - arguments        - arguments和this类似，都是函数中的隐含的参数        - arguments是一个类数组元素，它用来封装函数执行过程中的实参            所以即使不定义形参，也可以通过arguments来使用实参        - arguments中有一个属性callee表示当前执行的函数对象            - this        - this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象            1.以函数的形式调用时，this是window            2.以方法的形式调用时，this是调用方法的对象            3.以构造函数的形式调用时，this是新建的那个对象            4.使用call和apply调用时，this是指定的那个对象            5.在全局作用域中this代表window</code></pre><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3.作用域"></a>3.作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">- 作用域简单来说就是一个变量的作用范围。<br>- 在<span class="hljs-variable constant_">JS</span>中作用域分成两种：<br><span class="hljs-number">1.</span>全局作用域<br>- 直接在script标签中编写的代码都运行在全局作用域中<br>- 全局作用域在打开页面时创建，在页面关闭时销毁。<br>- 全局作用域中有一个全局对象<span class="hljs-variable language_">window</span>，<span class="hljs-variable language_">window</span>对象由浏览器提供，<br>可以在页面中直接使用，它代表的是整个的浏览器的窗口。<br>- 在全局作用域中创建的变量都会作为<span class="hljs-variable language_">window</span>对象的属性保存<br>在全局作用域中创建的函数都会作为<span class="hljs-variable language_">window</span>对象的方法保存<br>- 在全局作用域中创建的变量和函数可以在页面的任意位置访问。<br>在函数作用域中也可以访问到全局作用域的变量。<br>- 尽量不要在全局中创建变量<br><br><span class="hljs-number">2.</span>函数作用域<br>- 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。<br>- 函数作用域在函数执行时创建，在函数执行结束时销毁。<br>- 在函数作用域中创建的变量，不能在全局中访问。<br>- 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，<br>如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，<br>如果找到了则使用，找不到则继续向上找，一直会<br><br>- 变量的声明提前<br>- 在全局作用域中，使用<span class="hljs-keyword">var</span>关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。<br>所以我们可以在变量声明前使用变量。但是不使用<span class="hljs-keyword">var</span>关键字声明的变量不会被声明提前。<br>- 在函数作用域中，也具有该特性，使用<span class="hljs-keyword">var</span>关键字声明的变量会在函数所有的代码执行前被声明，<br>如果没有使用<span class="hljs-keyword">var</span>关键字声明变量，则变量会变成全局变量<br><br>- 函数的声明提前<br>- 在全局作用域中，使用函数声明创建的函数（<span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;&#125;）,会在所有的代码执行之前被创建，<br>也就是我们可以在函数声明前去调用函数，但是使用函数表达式(<span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)创建的函数没有该特性<br>- 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。<br><br>  <span class="hljs-number">3.</span><span class="hljs-variable language_">this</span>（上下文对象）<br> - 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>   使用<span class="hljs-variable language_">this</span>来引用上下文对象，根据函数的调用形式不同，<span class="hljs-variable language_">this</span>的值也不同。<br>   - <span class="hljs-variable language_">this</span>的不同的情况：<br>     <span class="hljs-number">1.</span>以函数的形式调用时，<span class="hljs-variable language_">this</span>是<span class="hljs-variable language_">window</span><br>     <span class="hljs-number">2.</span>以方法的形式调用时，<span class="hljs-variable language_">this</span>就是调用方法的对象<br>     <span class="hljs-number">3.</span>以构造函数的形式调用时，<span class="hljs-variable language_">this</span>就是新创建的对象<br></code></pre></td></tr></table></figure><ul><li><ul><li></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">4.</span>构造函数<br>- 构造函数是专门用来创建对象的函数<br>- 一个构造函数我们也可以称为一个类<br>- 通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例<br>- 通过同一个构造函数创建的对象，我们称为一类对象<br>- 构造函数就是一个普通的函数，只是他的调用方式不同，<br>如果直接调用，它就是一个普通函数<br>如果使用<span class="hljs-keyword">new</span>来调用，则它就是一个构造函数<br>- 例子：<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;<br><br>- 构造函数的执行流程：<br><span class="hljs-number">1.</span>创建一个新的对象<br><span class="hljs-number">2.</span>将新的对象作为函数的上下文对象（<span class="hljs-variable language_">this</span>）<br><span class="hljs-number">3.</span>执行函数中的代码<br><span class="hljs-number">4.</span>将新建的对象返回<br><br>- <span class="hljs-keyword">instanceof</span> 用来检查一个对象是否是一个类的实例<br>- 语法：对象 <span class="hljs-keyword">instanceof</span> 构造函数<br>- 如果该对象时构造函数的实例，则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>- <span class="hljs-title class_">Object</span>是所有对象的祖先，所以任何对象和<span class="hljs-title class_">Object</span>做<span class="hljs-keyword">instanceof</span>都会返回<span class="hljs-literal">true</span><br><br>- 枚举对象中的属性<br><span class="hljs-keyword">for</span>...<span class="hljs-keyword">in</span><br>语法：<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> 属性名 <span class="hljs-keyword">in</span> 对象)&#123;<br><br>&#125;<br><br><span class="hljs-keyword">for</span>...<span class="hljs-keyword">in</span>语句的循环体会执行多次，对象中有几个属性就会执行几次，<br>每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性<br></code></pre></td></tr></table></figure><h3 id="4-原型（prototype）"><a href="#4-原型（prototype）" class="headerlink" title="4.原型（prototype）"></a>4.原型（prototype）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">- 创建一个函数以后，解析器都会默认在函数中添加一个属性prototype<br>prototype属性指向的是一个对象，这个对象我们称为原型对象。<br>- 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。<br>这个隐含的属性可以通过对象.<span class="hljs-property">__proto__</span>来访问。<br>- 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。<br>我们可以将对象中共有的属性和方法统一添加到原型对象中，<br>这样我们只需要添加一次，就可以使所有的对象都可以使用。<br>- 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，<br>如果在自身中找到了，则直接使用。<br>如果没有找到，则去原型对象中寻找，如果找到了则使用，<br>如果没有找到，则去原型的原型中寻找，依此类推。直到找到<span class="hljs-title class_">Object</span>的原型为止，<span class="hljs-title class_">Object</span>的原型的原型为<span class="hljs-literal">null</span>，<br>如果依然没有找到则返回<span class="hljs-literal">undefined</span><br>- <span class="hljs-title function_">hasOwnProperty</span>()<br>- 这个方法可以用来检查对象自身中是否含有某个属性<br>- 语法：对象.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;属性名&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="5-数组（Array）"><a href="#5-数组（Array）" class="headerlink" title="5.数组（Array）"></a>5.数组（Array）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js">- 数组也是一个对象，是一个用来存储数据的对象<br>和<span class="hljs-title class_">Object</span>类似，但是它的存储效率比普通对象要高<br>- 数组中保存的内容我们称为元素<br>- 数组使用索引（index）来操作元素<br>- 索引指由<span class="hljs-number">0</span>开始的整数<br>- 数组的操作：<br>- 创建数组<br>         <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br>         <span class="hljs-keyword">var</span> arr = [];<br>- 向数组中添加元素<br>- 语法；<br>数组对象[索引] = 值;<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>- 创建数组时直接添加元素<br>- 语法：<br><span class="hljs-keyword">var</span> arr = [元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2.</span>...元素N];<br>- 例子：<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>];<br><br>- 获取和修改数组的长度<br>- 使用length属性来操作数组的长度<br>- 获取长度：<br>数组.<span class="hljs-property">length</span><br>- length获取到的是数组的最大索引+<span class="hljs-number">1</span><br>- 对于连续的数组，length获取到的就是数组中元素的个数<br>- 修改数组的长度<br>数组.<span class="hljs-property">length</span> = 新长度<br>- 如果修改后的length大于原长度，则多出的部分会空出来<br>- 如果修改后的length小于原长度，则原数组中多出的元素会被删除<br>- 向数组的最后添加元素<br>数组[数组.<span class="hljs-property">length</span>] = 值;<br><br>- 数组的方法<br>- <span class="hljs-title function_">push</span>()<br>- 用来向数组的末尾添加一个或多个元素，并返回数组新的长度<br>- 语法：数组.<span class="hljs-title function_">push</span>(元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素N)<br>- <span class="hljs-title function_">pop</span>()<br>- 用来删除数组的最后一个元素，并返回被删除的元素<br>- <span class="hljs-title function_">unshift</span>()<br>- 向数组的前边添加一个或多个元素，并返回数组的新的长度<br>- <span class="hljs-title function_">shift</span>()<br>- 删除数组的前边的一个元素，并返回被删除的元素<br>- <span class="hljs-title function_">slice</span>()<br>- 可以从一个数组中截取指定的元素<br>- 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回<br>- 参数：<br><span class="hljs-number">1.</span>截取开始位置的索引（包括开始位置）<br><span class="hljs-number">2.</span>截取结束位置的索引（不包括结束位置）<br>- 第二个参数可以省略不写，如果不写则一直截取到最后<br>- 参数可以传递一个负值，如果是负值，则从后往前数<br>- <span class="hljs-title function_">splice</span>()<br>- 可以用来删除数组中指定元素，并使用新的元素替换<br>该方法会将删除的元素封装到新数组中返回<br>- 参数：<br><span class="hljs-number">1.</span>删除开始位置的索引<br><span class="hljs-number">2.</span>删除的个数<br><span class="hljs-number">3.</span>三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边<br><span class="hljs-title function_">reverse</span>()<br>- 可以用来反转一个数组，它会对原数组产生影响<br><span class="hljs-title function_">concat</span>()<br>- 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回<br><span class="hljs-title function_">join</span>()<br>- 可以将一个数组转换为一个字符串<br>- 参数：<br>需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素<br>如果不指定连接符则默认使用,<br><span class="hljs-title function_">sort</span>()<br>- 可以对一个数组中的内容进行排序，默认是按照<span class="hljs-title class_">Unicode</span>编码进行排序<br>调用以后，会直接修改原数组。<br>- 可以自己指定排序的规则，需要一个回调函数作为参数：<br>返回一个大于<span class="hljs-number">0</span>的值，元素交换顺序<br>返回一个小于<span class="hljs-number">0</span>的值，元素位置不变<br>返回<span class="hljs-number">0</span>，则认为两个元素相等，不交换位置<br><span class="hljs-title class_">Arr</span>.<span class="hljs-title function_">sort</span>(  <span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> <span class="hljs-keyword">return</span> a-b)   <span class="hljs-comment">//升序</span><br><span class="hljs-title class_">Arr</span>.<span class="hljs-title function_">sort</span>(  <span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> <span class="hljs-keyword">return</span> b-a)   <span class="hljs-comment">//降序</span><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">- 遍历数组        - 遍历数组就是将数组中元素都获取到        - 一般情况我们都是使用for循环来遍历数组：            for(var i=0 ; i&lt;数组.length ; i++)&#123;                //数组[i]            &#125;- 使用forEach()方法来遍历数组（不兼容IE8）            数组.forEach(function(value , index , obj)&#123;                &#125;);                forEach()方法需要一个回调函数作为参数，            数组中有几个元素，回调函数就会被调用几次，            每次调用时，都会将遍历到的信息以实参的形式传递进来，            我们可以定义形参来获取这些信息。            value:正在遍历的元素            index:正在遍历元素的索引            obj:被遍历对象</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs JS">+属性<br><span class="hljs-title class_">Array</span>.<span class="hljs-property">length</span><br>    <span class="hljs-comment">//Array 构造函数的 length 属性，其值为1（注意该属性为静态属性，不是数组实例的 length 属性）。</span><br>    <span class="hljs-comment">//get Array[@@species]返回Array 构造函数。Array.prototype通过数组的原型对象可以为所有数组对象添加属性。</span><br>+方法<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>()从类数组对象或者可迭代对象中创建一个新的数组实例。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>()用来判断某个变量是否是一个数组对象。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>()根据一组参数来创建新的数组实例，支持任意的参数数量和类型。<br>        <br>所有数组实例都会从 <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 继承属性和方法。修改 <span class="hljs-title class_">Array</span> 的原型会影响到所有的数组实例。<br>+实例属性<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> 所有的数组实例都继承了这个属性，它的值就是<span class="hljs-title class_">Array</span>，表明了所有的数组都是由<span class="hljs-title class_">Array</span>构造出来的。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">length</span> 上面说了，因为<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> 也是个数组，所以它也有length属性，这个值为<span class="hljs-number">0</span>，因为它是个空数组。<br>+实例方法--修改器（这些方法会改变数组）<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">copyWithin</span>()在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">fill</span>()将数组中指定区间的所有元素的值，都替换成某个固定的值。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">pop</span>()删除数组的最后一个元素，并返回这个元素。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">push</span>()在数组的末尾增加一个或多个元素，并返回数组的新长度。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">reverse</span>()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">shift</span>()删除数组的第一个元素，并返回这个元素。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">sort</span>()对数组元素进行排序，并返回当前数组。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">splice</span>()在任意的位置给数组添加或删除任意个元素。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">unshift</span>()在数组的开头增加一个或多个元素，并返回数组的新长度。<br> +实例方法--访问方法（这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。）<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">concat</span>()<br>    返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">includes</span>()<br>   判断当前数组是否包含某指定的值，如果是返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span><br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">join</span>()<br>    连接所有数组元素组成一个字符串<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">slice</span>()<br>    抽取当前数组中的一段元素组合成一个新数组<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toSource</span>()<br>    返回一个字符串,代表该数组的源代码.<span class="hljs-title function_">toSource</span>()方法返回一个表示对象源代码的字符串。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>()<br>    返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>()<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toLocaleString</span>()<br>    返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toLocaleString</span>()<br>+ 迭代方法<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">entries</span>()返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">every</span>()如果数组中的每个元素都满足测试函数，则返回<span class="hljs-literal">true</span>，否则返回<span class="hljs-literal">false</span>。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">some</span>()如果数组中至少有一个元素满足测试函数，则返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">filter</span>()将所有在过滤函数中返回<span class="hljs-literal">true</span>的数组元素放进一个新数组中并返回。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">find</span>()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回<span class="hljs-literal">undefined</span>。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">findIndex</span>()找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回-<span class="hljs-number">1</span>。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">keys</span>()返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">map</span>()返回一个由回调函数的返回值组成的新数组。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">reduce</span>()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">reduceRight</span>()从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">values</span>()返回一个数组迭代器对象，该迭代器会包含所有数组元素的值。<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[@@iterator]()和上面的<span class="hljs-title function_">values</span>() 方法是同一个函数。<br></code></pre></td></tr></table></figure><h3 id="6-Date"><a href="#6-Date" class="headerlink" title="6.Date"></a><strong>6.Date</strong></h3><pre><code class="hljs">- 日期的对象，在JS中通过Date对象来表示一个时间- 创建对象    - 创建一个当前的时间对象        var d = new Date();    - 创建一个指定的时间对象           var d = new Date(&quot;月/日/年 时:分:秒&quot;);- 方法：    getDate()        - 当前日期对象是几日（1-31）            getDay()         - 返回当前日期对象时周几（0-6）            - 0 周日            - 1 周一 。。。                getMonth()        - 返回当前日期对象的月份（0-11）        - 0 一月 1 二月 。。。    getFullYear() 从 Date 对象以四位数字返回年份。     getHours() 返回 Date 对象的小时 (0 ~ 23)。     getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。     getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。     getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。         getTime()        - 返回当前日期对象的时间戳        - 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数            计算机底层保存时间都是以时间戳的形式保存的。                Date.now()        - 可以获取当前代码执行时的时间戳</code></pre><h3 id="7-Math"><a href="#7-Math" class="headerlink" title="7.Math"></a>7.Math</h3><pre><code class="hljs">- Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法    我们可以直接使用它来进行数学运算相关的操作        <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext">--属性<br>Math.PI<br><span class="hljs-bullet">-</span> <span class="hljs-string">常量，圆周率</span><br>Math.E<br><span class="hljs-bullet">-</span> <span class="hljs-string">常量，e</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">方法：</span><br>Math.abs()<br><span class="hljs-bullet">-</span> <span class="hljs-string">绝对值运算</span><br>Math.ceil()<br><span class="hljs-bullet">-</span> <span class="hljs-string">向上取整</span><br>Math.floor()<br><span class="hljs-bullet">-</span> <span class="hljs-string">向下取整</span><br>Math.round()<br><span class="hljs-bullet">-</span> <span class="hljs-string">四舍五入取整</span><br>Math.random()<br><span class="hljs-bullet">-</span> <span class="hljs-string">生成一个0-1之间的随机数</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">生成一个x-y之间的随机数</span><br>Math.round(Math.random()*(y-x)+x);<br>Math.pow(x,y)<br><span class="hljs-bullet">-</span> <span class="hljs-string">求x的y次幂</span><br>Math.sqrt()<br><span class="hljs-bullet">-</span> <span class="hljs-string">对一个数进行开方</span><br>Math.max()<br><span class="hljs-bullet">-</span> <span class="hljs-string">求多个数中最大值</span><br>Math.min()<br><span class="hljs-bullet">-</span> <span class="hljs-string">求多个数中的最小值</span><br><br><br>​<br><br><span class="hljs-comment">### 8**字符串的相关的方法**</span><br><br>length<br><span class="hljs-bullet">-</span> <span class="hljs-string">获取字符串的长度</span><br>charAt()<br><span class="hljs-bullet">-</span> <span class="hljs-string">根据索引获取指定的字符</span><br>charCodeAt()<br><span class="hljs-bullet">-</span> <span class="hljs-string">根据索引获取指定的字符编码</span><br>String.fromCharCode()<br><span class="hljs-bullet">-</span> <span class="hljs-string">根据字符编码获取字符</span><br>indexOf()<br>lastIndexOf()<br><span class="hljs-bullet">-</span> <span class="hljs-string">从一个字符串中检索指定内容</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">需要一个字符串作为参数，这个字符串就是要检索的内容，</span><br>如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。<br><span class="hljs-bullet">-</span> <span class="hljs-string">可以指定一个第二个参数，来表示开始查找的位置</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">indexOf()是从前向后找</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">lastIndexOf()是从后向前找</span><br>slice()<br><span class="hljs-bullet">-</span> <span class="hljs-string">可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">参数：</span><br>第一个：截取开始的位置（包括开始）<br>第二个：截取结束的位置（不包括结束）<br><span class="hljs-bullet">-</span> <span class="hljs-string">可以省略第二个参数，如果省略则一直截取到最后</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">可以传负数，如果是负数则从后往前数</span><br>substr()<br><span class="hljs-bullet">-</span> <span class="hljs-string">和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量</span><br><br>substring()<br><span class="hljs-bullet">-</span> <span class="hljs-string">和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，</span><br>substring()中如果第二个参数小于第一个，自动调整位置<br>toLowerCase() <br><span class="hljs-bullet">-</span> <span class="hljs-string">将字符串转换为小写并返回</span><br>toUpperCase() <br><span class="hljs-bullet">-</span> <span class="hljs-string">将字符串转换为大写并返回</span><br>split()<br><span class="hljs-bullet">-</span> <span class="hljs-string">可以根据指定内容将一个字符串拆分为一个数组</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">参数：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">需要一个字符串作为参数，将会根据字符串去拆分数组</span><br>可以接收一个正则表达式，此时会根据正则表达式去拆分数组<br>             -这个方法即使不指定全局匹配，也会全都插分<br><br>match() <br><span class="hljs-bullet">-</span> <span class="hljs-string">可以将字符串中和正则表达式匹配的内容提取出来</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">参数：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来</span><br>默认情况下 match只会找到第一个符合要求的内容，找到以后就停止检索<br>我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容<br>可以为一个正则表达式设置多个匹配模式，且顺序无所谓<br>match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果<br><br>replace()  <br><span class="hljs-bullet">-</span> <span class="hljs-string">可以将字符串中指定内容替换为新的内容</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">参数：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">第一个：被替换的内容，可以是一个正则表达式</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">第二个：替换的新内容</span><br><br>search() <br><span class="hljs-bullet">-</span> <span class="hljs-string">可以根据正则表达式去字符串中查找指定的内容</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">参数：</span><br>正则表达式，将会根据该表达式查询内容，<br>并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。<br>-serach()只会查找第一个，即使设置全局匹配也没用<br><br><span class="hljs-comment">### 9.包装类</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">在JS中为我们提供了三个包装类：</span><br>String() Boolean() Number()<br><span class="hljs-bullet">-</span> <span class="hljs-string">通过这三个包装类可以创建基本数据类型的对象</span><br>例子：<br>var num = new Number(2);<br>var str = new String(&quot;hello&quot;);<br>var bool = new Boolean(true);<br><span class="hljs-bullet">-</span> <span class="hljs-string">但是在实际应用中千万不要这么干。</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">当我们去操作一个基本数据类型的属性和方法时，</span><br>解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，<br>操作完成以后再将这个临时对象进行销毁。<br><br><span class="hljs-comment">### 10.正则表达式</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，</span><br>也可以将一个字符串中符合规则的内容提取出来。<br><span class="hljs-bullet">-</span> <span class="hljs-string">创建正则表达式</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">var reg = new RegExp(&quot;正则&quot;,&quot;匹配模式&quot;);</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">var reg = /正则表达式/匹配模式</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">语法：</span><br>匹配模式：<br>i:忽略大小写<br>g:全局匹配模式<br><span class="hljs-bullet">-</span> <span class="hljs-string">设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求</span><br><br><span class="hljs-attribute">正则语法</span><br><span class="hljs-attribute">| 或</span><br><span class="hljs-attribute">[] 或</span><br><span class="hljs-attribute">[^ ] 除了</span><br><span class="hljs-attribute">[a-z] 小写字母</span><br><span class="hljs-attribute">[A-Z] 大写字母</span><br><span class="hljs-attribute">[A-z] 任意字母</span><br><span class="hljs-attribute">[0-9] 任意数字</span><br><span class="hljs-attribute">- 量词</span><br><span class="hljs-attribute">&#123;n&#125; 正好n次</span><br><span class="hljs-attribute">&#123;m,n&#125; m-n次</span><br><span class="hljs-attribute">&#123;m,&#125; 至少m次</span><br><span class="hljs-attribute">+至少1次 &#123;1,&#125;</span><br><span class="hljs-attribute">?   0次或1次 &#123;0,1&#125;</span><br><span class="hljs-attribute">*   0次或多次 &#123;0,&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">- 转义字符</span><br><span class="hljs-attribute">\ 在正则表达式中使用\作为转义字符</span><br><span class="hljs-attribute">\. 表示.</span><br><span class="hljs-attribute">. 表示任意字符</span><br><span class="hljs-attribute">\\ 表示 \</span><br><span class="hljs-attribute">\w   - 相当于[A-z0-9_]</span><br><span class="hljs-attribute">\W- 相当于[^A-z0-9_]</span><br><span class="hljs-attribute">\d- 任意数字</span><br><span class="hljs-attribute">\D- 除了数字</span><br><span class="hljs-attribute">\s- 空格</span><br><span class="hljs-attribute">\S- 除了空格</span><br><span class="hljs-attribute">\b- 单词边界</span><br><span class="hljs-attribute">\B- 除了单词边界</span><br><span class="hljs-attribute">^ 表示开始</span><br><span class="hljs-attribute">$ 表示结束</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">​</span><br><span class="hljs-attribute">​</span><br><span class="hljs-attribute">​</span><br><span class="hljs-attribute">​- 方法：</span><br><span class="hljs-attribute">​RegExp.test(string)</span><br><span class="hljs-attribute">​- 可以用来检查一个字符串是否符合正则表达式</span><br><span class="hljs-attribute">​- 如果符合返回true，否则返回false</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">## JavaScript DOM</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">### 1.DOM概念</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">- Document Object Model</span><br><span class="hljs-attribute">- 文档对象模型，通过DOM可以来任意来修改网页中各个内容</span><br><span class="hljs-attribute">- 文档</span><br><span class="hljs-attribute">- 文档指的是网页，一个网页就是一个文档</span><br><span class="hljs-attribute">- 对象</span><br><span class="hljs-attribute">- 对象指将网页中的每一个节点都转换为对象</span><br><span class="hljs-attribute">转换完对象以后，就可以以一种纯面向对象的形式来操作网页了</span><br><span class="hljs-attribute">- 模型</span><br><span class="hljs-attribute">- 模型用来表示节点和节点之间的关系，方便操作页面</span><br><span class="hljs-attribute">- 节点（Node）</span><br><span class="hljs-attribute">- 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点</span><br><span class="hljs-attribute">- 虽然都是节点，但是节点的类型却是不同的</span><br><span class="hljs-attribute">- 常用的节点</span><br><span class="hljs-attribute">- 文档节点 （Document），代表整个网页</span><br><span class="hljs-attribute">- 元素节点（Element），代表网页中的标签</span><br><span class="hljs-attribute">- 属性节点（Attribute），代表标签中的属性</span><br><span class="hljs-attribute">- 文本节点（Text），代表网页中的文本内容</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">### 2.DOM操作</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">- DOM查询</span><br><span class="hljs-attribute">- 在网页中浏览器已经为我们提供了document对象，</span><br><span class="hljs-attribute">它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。</span><br><span class="hljs-attribute">- document查询方法：</span><br><span class="hljs-attribute">- 根据元素的id属性查询一个元素节点对象：</span><br><span class="hljs-attribute">- document.getElementById(&quot;id属性值&quot;);</span><br><span class="hljs-attribute">- 根据元素的name属性值查询一组元素节点对象</span><span class="hljs-punctuation">:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">document.getElementsByName(&quot;name属性值&quot;);</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">根据标签名来查询一组元素节点对象：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">document.getElementsByTagName(&quot;标签名&quot;);</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素的属性：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">读取元素的属性：</span><br>语法：元素.属性名<br>例子：ele.name  <br>  ele.id  <br>  ele.value <br>  ele.className<br>  <br><span class="hljs-bullet">-</span> <span class="hljs-string">修改元素的属性：</span><br>语法：元素.属性名 = 属性值<br><br><span class="hljs-bullet">-</span> <span class="hljs-string">innerHTML</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">使用该属性可以获取或设置元素内部的HTML代码</span><br><br><span class="hljs-comment">### 3.文档的加载</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，</span><br>此时将会无法正常获取到DOM对象，导致DOM操作失败。<br><span class="hljs-bullet">-</span> <span class="hljs-string">解决方式一：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">可以将js代码编写到body的下边</span><br>&lt;body&gt;<br>&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;<br>&lt;script&gt;<br>var btn = document.getElementById(&quot;btn&quot;);<br>btn.onclick = function()&#123;<br><br>&#125;;<br>&lt;/script&gt;<br>&lt;/body&gt;<br><br><span class="hljs-bullet">-</span> <span class="hljs-string">解决方式二：</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">将js代码编写到window.onload = function()&#123;&#125;中</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">window.onload 对应的回调函数会在整个页面加载完毕以后才执行，</span><br>所以可以确保代码执行时，DOM对象已经加载完毕了<br>&lt;script&gt;<br>window.onload = function()&#123;<br>var btn = document.getElementById(&quot;btn&quot;);<br>btn.onclick = function()&#123;<br><br>&#125;;<br>&#125;;<br><br>&lt;/script&gt;<br><br><span class="hljs-comment">### 4.DOM查询</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">通过具体的元素节点来查询</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.getElementsByTagName()</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">通过标签名查询当前元素的指定后代元素</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.childNodes</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的所有子节点</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">会获取到空白的文本子节点</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.children</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的所有子元素</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.firstChild(包含空白文本节点)</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的第一个子节点</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.lastChild(包含空白文本节点)</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的最后一个子节点</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.firstElementChild(不包含空白文本节点)</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的第一个子节点</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.lastElementChild(包含空白文本节点)</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的最后一个子节点</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.parentNode</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的父元素</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.previousSibling</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的前一个兄弟节点</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">元素.nextSibling</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">获取当前元素的后一个兄弟节点</span><br><br><br>​<br><br>innerHTML和innerText<br><span class="hljs-bullet">-</span> <span class="hljs-string">这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">两个属性作用类似，都可以获取到标签内部的内容，</span><br>不同是innerHTML会获取到html标签，而innerText会自动去除标签<br><span class="hljs-bullet">-</span> <span class="hljs-string">如果使用这两个属性来设置标签内部的内容时，没有任何区别的</span><br><br>读取标签内部的文本内容<br>&lt;h1&gt;h1中的文本内容&lt;/h1&gt;<br>元素.firstChild.nodeValue<br><br><br></code></pre></td></tr></table></figure></code></pre><ul><li>document对象的其他的属性和方法<br>  document.all<br>  - 获取页面中的所有元素，相当于document.getElementsByTagName(“*”);<br><br>  document.documentElement<br>  - 获取页面中html根元素<br><br>  document.body<br>  - 获取页面中的body元素<br><br>  document.getElementsByClassName()<br>  - 根据元素的class属性值查询一组元素节点对象<br>  - 这个方法不支持IE8及以下的浏览器<br><br>  document.querySelector()<br>  - 根据CSS选择器去页面中查询一个元素<br>  - 如果匹配到的元素有多个，则它会返回查询到的第一个元素<br><br>  document.querySelectorAll()<br>  - 根据CSS选择器去页面中查询一组元素<br>  - 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个</li></ul><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br><span class="hljs-comment">### 5.DOM修改</span><br><br>document.createElement()<br><span class="hljs-bullet">-</span> <span class="hljs-string">可以根据标签名创建一个元素节点对象</span><br><br>document.createTextNode()<br><span class="hljs-bullet">-</span> <span class="hljs-string">可以根据文本内容创建一个文本节点对象</span><br><br>父节点.appendChild(子节点)<br><span class="hljs-bullet">-</span> <span class="hljs-string">向父节点中添加指定的子节点</span><br><br>父节点.insertBefore(新节点,旧节点)<br><span class="hljs-bullet">-</span> <span class="hljs-string">将一个新的节点插入到旧节点的前边</span><br><br>父节点.replaceChild(新节点,旧节点)<br><span class="hljs-bullet">-</span> <span class="hljs-string">使用一个新的节点去替换旧节点</span><br><br>父节点.removeChild(子节点)<br><span class="hljs-bullet">-</span> <span class="hljs-string">删除指定的子节点</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">推荐方式：子节点.parentNode.removeChild(子节点)</span><br><br><span class="hljs-comment">### 6.通过DOM操作CSS</span><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">- 读取和修改内联样式    - 使用style属性来操作元素的内联样式    - 读取内联样式：        语法：元素.style.样式名        - 例子：            元素.style.width            元素.style.height            - 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法                将-去掉，然后-后的字母改大写            - 比如：background-color --&gt; backgroundColor                    border-width ---&gt; borderWidth                        - 修改内联样式：        语法：元素.style.样式名 = 样式值        - 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，            所以我们通过JS来修改的样式，往往会立即生效，            但是如果样式中设置了!important，则内联样式将不会生效。            - 读取元素的当前样式    - 正常浏览器        - 使用getComputedStyle()        - 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式        - 参数：            1.要获取样式的元素            2.可以传递一个伪元素，一般传null        - 例子：            获取元素的宽度                getComputedStyle(box , null)[&quot;width&quot;];        - 通过该方法读取到样式都是只读的不能修改    - IE8        - 使用currentStyle        - 语法：            元素.currentStyle.样式名        - 例子：            box.currentStyle[&quot;width&quot;]        - 通过这个属性读取到的样式是只读的不能修改- 其他的样式相关的属性    注意：以下样式都是只读的    clientHeight        - 元素的可见高度，指元素的内容区和内边距的高度    clientWidth        - 元素的可见宽度，指元素的内容区和内边距的宽度    offsetHeight        - 整个元素的高度，包括内容区、内边距、边框    offfsetWidth        - 整个元素的宽度，包括内容区、内边距、边框    offsetParent        - 当前元素的定位父元素        - 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body    offsetLeft    offsetTop        - 当前元素和定位父元素之间的偏移量        - offsetLeft水平偏移量  offsetTop垂直偏移量        scrollHeight    scrollWidth        - 获取元素滚动区域的高度和宽度        scrollTop    scrollLeft        - 获取元素垂直和水平滚动条滚动的距离            判断滚动条是否滚动到底        - 垂直滚动条            scrollHeight - scrollTop = clientHeight                    - 水平滚动            scrollWidth - scrollLeft = clientWidth</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>## JavaScript 事件<br><br>### 1.事件定义<br><br>- 事件（Event）<br>- 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。<br>- 我们可以为事件来绑定回调函数来响应事件。<br>- 绑定事件的方式：<br>1.可以在标签的事件属性中设置相应的JS代码<br>例子：<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;js代码。。。&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件<br>例子：<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);</span><br><span class="language-javascript">btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;....</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>### 2.事件冒泡<br><br>```- 事件的冒泡（Bubble）<br>- 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。<br>- 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消<br>- 可以将事件对象的cancelBubble设置为true，即可取消冒泡<br>- 例子：<br>元素.事件 = function(event)&#123;<br>event = event || window.event;<br>event.cancelBubble = true;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-事件委派"><a href="#3-事件委派" class="headerlink" title="3.事件委派"></a>3.事件委派</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">事件的委派<br>- 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素<br>从而通过祖先元素的响应函数来处理事件。<br>- 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能<br>    - event中的target表示的触发事件的对象   <br></code></pre></td></tr></table></figure><h3 id="4-事件绑定"><a href="#4-事件绑定" class="headerlink" title="4.事件绑定"></a>4.事件绑定</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html">/*<br>* 使用 对象.事件 = 函数 的形式绑定响应函数，<br>* 它只能同时为一个元素的一个事件绑定一个响应函数，<br>* 不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的<br>*/<br><br>* addEventListener()<br>* - 通过这个方法也可以为元素绑定响应函数<br>*  - 参数：<br>* 1.事件的字符串，不要on<br>* 2.回调函数，当事件触发时该函数会被调用<br>* 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false<br>* <br>* 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，<br>* 这样当事件被触发时，响应函数将会按照函数的绑定顺序执行<br><br><br><br>* attachEvent()<br>* - 在IE8中可以使用attachEvent()来绑定事件<br>*  - 参数：<br>* 1.事件的字符串，要on<br>* 2.回调函数<br>* <br>*  - 这个方法也可以同时为一个事件绑定多个处理函数，<br>* 不同的是它是后绑定先执行，执行顺序和addEventListener()相反<br>*/<br></code></pre></td></tr></table></figure><h3 id="5-事件的传播"><a href="#5-事件的传播" class="headerlink" title="5.事件的传播"></a>5.事件的传播</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html">事件的传播<br>- 关于事件的传播网景公司和微软公司有不同的理解<br>- 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，<br>然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。<br> - 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，<br>然后在向内传播给后代元素<br>- W3C综合了两个公司的方案，将事件传播分成了三个阶段<br>1.捕获阶段<br>- 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件<br>2.目标阶段<br>- 事件捕获到目标元素，捕获结束开始在目标元素上触发事件<br>3.冒泡阶段<br>- 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件<br><br>- 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true<br>一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false<br><br>- IE8及以下的浏览器中没有捕获阶段<br><br></code></pre></td></tr></table></figure><h2 id="JavaScript-BOM"><a href="#JavaScript-BOM" class="headerlink" title="JavaScript BOM"></a>JavaScript BOM</h2><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html">BOM<br>- 浏览器对象模型<br>- BOM可以使我们通过JS来操作浏览器<br>- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作<br>- BOM对象<br>Window<br>- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象<br>Navigator<br>- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器<br>Location<br>- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面<br>History<br>- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录<br>由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页<br>而且该操作只在当次访问时有效<br>Screen<br>- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息<br><br><br>这些BOM对象在浏览器中都是作为window对象的属性保存的，<br>可以通过window对象来使用，也可以直接使用<br>  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本对象</tag>
      
      <tag>事件</tag>
      
      <tag>DOM</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/31/hello-world/"/>
    <url>/2022/08/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>创建新文章，默认发表在post页面<br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Create-a-new-page"><a href="#Create-a-new-page" class="headerlink" title="Create a new page"></a>Create a new page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo creat <span class="hljs-string">&quot;About&quot;</span><br></code></pre></td></tr></table></figure><p>创建新页面</p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="个人备忘"><a href="#个人备忘" class="headerlink" title="个人备忘"></a><strong>个人备忘</strong></h3><p>执行<code>hexo g </code> 报错 提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Something</span><span class="hljs-string">&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="hljs-string">Template render error: (unknown path)</span><br><span class="hljs-string">  Error: filter not found: 过滤器名</span><br></code></pre></td></tr></table></figure><p>原因：hexo<a href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89&spm=1001.2101.3001.7020">转义</a>时候发生的错误，你文章中可能出现了<code>&#123;&#123;&#125;&#125;，&#123;% %&#125;</code>这种hexo无法转义的字符,<br>可以将出现的代码，用&#96;进行注释下就可以</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
